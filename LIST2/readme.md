## 501. 分隔长廊的方案数
* 给你一个字符串`corridor`，包含字母`'S'`和`'P'`，其中每个`'S'`表示座位，每个`'P'`表示植物。 字符串两侧分别各放了一个屏风，还需要额外在任意两个字符之间放置一些屏风，将走廊用屏风划分为若干段，且每一段内都恰好有两个座位。请你返回划分走廊的方案数。 

## 502. 元素计数
* 给你一个整数数组`nums`，统计并返回在`nums`中同时具有一个严格较小元素和一个严格较大元素的元素数目

## 503. 按符号重排数组
* 重排`nums`中的元素，使修改后的数组满足下述条件： 任意连续的两个整数符号相反；对于符号相同的所有整数，保留它们在`nums`中的顺序； 重排后数组以正整数开头。

## 504. 找出数组中的所有孤独数字
* 给你一个整数数组`nums`。如果数字`x`在数组中仅出现一次，且`x + 1`和`x - 1`不出现在数组中，则认为数字`x`是孤独数字 。 返回`nums`中的所有孤独数字

## 505. 基于陈述统计最多好人数
* 游戏中存在两种角色： 好人：该角色只说真话； 坏人：该角色可能说真话，也可能说假话。 给你一个二维整数数组`statements`表示`n`个玩家对彼此角色的陈述。`statements[i][j]`可以是下述值之一：`0`表示`i`的陈述认为`j`是坏人；`1`表示`i`的陈述认为`j`是好人；`2`表示`i`没有对`j`作出陈述。根据这`n`个玩家的陈述，返回可以认为是好人的最大数目。

## 506. 比赛中的配对次数
* 给你一个整数`n`，表示比赛中的队伍数。 如当前队伍数是偶数 ，进行`n / 2`场比赛，且产生`n / 2`支队伍进入下一轮； 如果当前队伍数为奇数 ，那么随机轮空并晋级一支队伍，其余的队伍配对进行`(n - 1) / 2`场比赛，产生`(n - 1) / 2 + 1`支队伍进入下一轮。 返回在比赛直到决出获胜队伍为止配对次数

## 507. 有序链表转换二叉搜索树
* 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

## 508. 加油站
* 在一条环路上有若干加油站，其中第`i`个加油站有汽油`gas[i]`升。 有一辆车，从第`i`个加油站开往第`i+1`个加油站需要消耗汽油`cost[i]`升。开始时油箱为空。 如可以绕环路行驶一周，则返回出发时加油站的编号。

## 509. 只出现一次的数字 II
* 给你一数组`nums`，除某个元素仅出现`1`次外，其余每个元素都恰出现`3`次 。请你找出并返回那个只出现了一次的元素。

## 510. 游戏中弱角色的数量
* 给你一个二维整数数组`properties`，其中`properties[i] = [attacki, defensei]`表示游戏中第`i`个角色的属性。如果认为角色`i`弱于角色`j`，那么`attackj > attacki`且`defensej > defensei`。返回弱角色的数量。

## 511. 地图中的最高点
* 给你一个大小为`m x n`的整数矩阵`isWater`，它代表了一个地图。 如果`isWater[i][j] == 0`，`(i, j)`是陆地； 如果`isWater[i][j] == 1`，`(i, j)`是水域。 按照如下规则给每个单元安排高度： 每个格子的高度都必须是非负的； 如果一个格子是水域，那么它的高度为`0`； 任意相邻的格子高度差 **至多** 为`1`。找到一种安排高度的方案，使得矩阵中的最高高度值最大。

## 512. 交替合并字符串
* 给你两个字符串`word1`和`word2`。请你从`word1`开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。 返回合并后的字符串

## 513. 移动所有球到每个盒子所需的最小操作数
* 给你一个字符串`boxes`，其中`boxes[i]`的值为`'0'`表示第`i`个盒子是空的，而`boxes[i]`的值为`'1'`表示盒子里有一个小球。 在一步操作中，你可以将一个小球移动到与之相邻的盒子中。 返回一个长度为`n`的数组`answer`，其中`answer[i]`是将所有小球移动到第`i`个盒子所需的最小操作数。

## 514. 将数字变成 0 的操作次数
* 给你一个非负整数`num`，请你返回将它变成`0`所需要的步数。 如果当前数字是偶数，你需要把它除以`2`；否则，减去`1`

## 515. 两句话中的不常见单词
* 句子 是一串由空格分隔的单词。每个单词仅由小写字母组成。 如果某个单词在其中一个句子中恰好出现一次，在另一个句子中没有出现 ，那么这个单词就是 **不常见的** 。给你两个句子`s1`和`s2`，返回所有 **不常用单词** 的列表

## 516. 将找到的值乘以 2
* 给你一个整数数组`nums`，另给你一个整数`original`，你需要按下述步骤操作： 如果在`nums`中找到`original`，令`original = 2 * original`， 否则，停止这一过程。 只要能在数组中找到新`original`，就对继续重复过程。 返回`original`的最终值

## 517. 分组得分最高的所有下标
* 给你一个数组`nums`，`nums`可以按下标 `i`划分为：numsleft 和 numsright 。`numsleft`包含`nums`中从下标`0`到`i - 1`的所有元素，而`numsright`包含`nums`中从下标`i`到`n - 1`的所有元素； 如果`i == 0` ，`numsleft`为空 ，而`numsright`将包含`nums`中的所有元素； 如果`i == n`，`numsleft`将包含`nums`中的所有元素，而`numsright`为空； 下标`i`的分组得分为`numsleft`中`0`的个数和`numsright`中`1`的个数之和 。 返回分组得分最高的所有不同下标

## 518. 查找给定哈希值的子串
* 给定整数`p`和`m`，一个长度为`k`的字符串`s`的哈希值按照如下函数计算：`hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m`。 其中`val(s[i])`表示`s[i]`在字母表中的下标，从`val('a') = 1`到`val('z') = 26`。 给你一个字符串`s`和整数`p`，`m`，`k`和`hashValue`。请你返回`s`中第一个长度为`k`的子串`sub`，满足`hash(sub, p, m) == hashValue`

## 519. 最长的美好子字符串
* 当一个字符串`s`包含的每一种字母的大写和小写形式同时出现在`s`中，就称`s`是 **美好字符串** 。给你一个字符串`s`，请你返回`s`最长的 **美好子字符串** 。

## 520. 可以形成最大正方形的矩形数目
* 给你一个数组`rectangles`，其中`rectangles[i] = [li, wi]`表示第`i`个矩形的长为`li`、宽为`wi`。如果存在`k`同时满足`k <= li`、`k <= wi`，就可以将第`i`个矩形切成边长为`k`的正方形。设`maxLen`为可以从矩形数组`rectangles`切分得到的 **最大正方形** 的边长。请你统计有多少个矩形能够切出边长为`maxLen`的正方形

## 521. 黄金矿工
* 网格`grid`标注每个单元格中的黄金数量。按以下规则来开采： 矿工每次可以从当前位置向上下左右四个方向走； 每个单元格只能被开采一次； 不得开采黄金数目为`0`的单元格； 矿工可以从网格中任意单元格出发或停止。求最大开采量

## 522. 拆分数位后四位数字的最小和
* 给你一个四位正整数`num`。请你使用`num`中的数位 ，构成两个新的整数`new1`和`new2`。请你返回可以得到的`new1`和`new2`的最小和

## 523. 根据给定数字划分数组
* 给你一个整数数组`nums`和一个整数`pivot`。请你将`nums`重新排列，使得以下条件均成立： 所有小于`pivot`的元素都出现在所有大于`pivot`的元素之前； 所有等于`pivot`的元素都出现在小于和大于`pivot`的元素中间； 小于`pivot`的元素之间、大于`pivot`的元素之间各自的相对顺序不变。

## 524. 设置时间的最少代价
* 最多输入`4`个数字来设置加热时间，如果你输入的位数不足`4`位，微波炉会自动加前缀`0`来补足。微波炉会将设置好的四位数中，前两位当作分钟数，后两位当作秒数。它们所表示的总时间就是加热时间。给你整数 `startAt`，`moveCost`，`pushCost`和`targetSeconds`。一开始，你的手指在数字`startAt`处。将手指移到任何其他数字 ，需要花费`moveCost`的单位代价。每输入你手指所在位置的数字一次，需要花费`pushCost`的单位代价。 要设置`targetSeconds`秒的加热时间，可能会有多种设置方法。你想要知道这些方法中，总代价最小为多少。注意，虽然微波炉的秒数最多可以设置到`99`秒，但一分钟等于`60`秒。

## 525. 删除元素后和的最小差值
* 给你一个整数数组`nums`，包含`3 * n`个元素。 从`nums`中删除`n`个元素，剩下的`2 * n`个元素将会被分成两个相同大小的部分。 前面`n`个元素属于第一部分，它们的和记为`sumfirst`； 后面`n`个元素属于第二部分，它们的和记为`sumsecond`。 求`sumfirst - sumsecond`最小值。

## 526. 对奇偶下标分别排序
* 给你一个整数数组`nums`。根据下述规则重排`nums`中的值： 按非递增顺序排列`nums` **奇数下标** 上的所有值；按非递减顺序排列`nums` **偶数下标** 上的所有值；

## 527. 重排数字的最小值
* 给你一个整数`num`。重排`num`中的各位数字，使其值最小且不含前导零。注意，重排各位数字后，`num`的符号不会改变。

## 528. 设计位集
* 请你实现`Bitset`类：`Bitset(int size)`用`size`个位初始化`Bitset`，所有位都是`0`；`void fix(int idx)`将下标为`idx`的位上的值更新为`1`；`void unfix(int idx)`将下标为`idx`的位上的值更新为`0`；`void flip()`翻转`Bitset`中每一位上的值；`boolean all()`检查`Bitset`中每一位的值是否都是`1`；`boolean one()`检查`Bitset`中是否至少一位的值是`1`；`int count()`返回`Bitset`中值为`1`的位的总数 ；`String toString()`返回`Bitset`的当前组成情况。

## 529. 和为 K 的最少斐波那契数字数目
* 给你数字`k`，请你返回和为`k`的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。

## 530. 最长快乐字符串
* 如果字符串中不含有任何`'aaa'`，`'bbb'`或`'ccc'`这样的字符串作为子串，那么该字符串就是一个 **快乐字符串** 。 给你三个整数`a`，`b`，`c`，请你返回任意一个满足下列全部条件的字符串`s`： 是一个尽可能长的快乐字符串； 最多有`a`个字母`'a'`、`b`个字母`'b'`、`c`个字母`'c'`； 只含有`'a'`、`'b'` 、`'c'`三种字母。

## 531. 网格照明
* 在的网格`grid`上，每个单元格都有一盏灯，最初灯都处于关闭状态。 给你一个二维数组`lamps`，其中`lamps[i] = [rowi, coli]`表示打开位于`grid[rowi][coli]`的灯。 当一盏灯处于打开状态，它将会照亮自身所在单元格以及 **同一行、同一列、两条对角线** 上的 所有单元格。 另给你一个二维数组`queries`，其中`queries[j] = [rowj, colj]`。如果单元格`[rowj, colj]`是被照亮的，则查询结果为`1`，否则为`0`。在第`j`次查询之后，关闭位于单元格`grid[rowj][colj]`上及相邻八个方向上的任何灯。 返回一个整数数组`ans`作为`queries`的答案

## 532. 子数组最大平均数 I
* 给你一个整数数组`nums`和一个整数`k`。 请你找出平均数最大且长度为`k`的连续子数组，并输出该最大平均数。

## 533. 最简分数
* 给你一个整数`n`，请你返回所有`0`到`1`之间满足分母小于等于`n`的 **最简分数**

## 534. 学生分数的最小差值
* 给你一个整数数组`nums`，其中`nums[i]`表示第`i`名学生的分数。另给你一个整数`k`。 从数组中选出任意`k`名学生的分数，使这`k`个数间最高分和最低分的差值达到最小化

## 535. 得到 0 的操作数
* 给你两个非负整数`num1`和`num2`。 每一步操作中，如果`num1 >= num2`，你必须用`num1`减`num2`；否则，你必须用`num2`减`num1`。返回使`num1 = 0`或`num2 = 0`的操作数

## 536. 使数组变成交替数组的最少操作数
* 给你一个数组`nums`，该数组由`n`个正整数组成。如果满足下述条件，则数组`nums`是一个交替数组 ：`nums[i - 2] == nums[i]`，其中`2 <= i <= n - 1`；`nums[i - 1] != nums[i]`，其中`1 <= i <= n - 1`。 在一步操作中，你可以将`nums[i]`更改为任一正整数。 返回使数组变成交替数组的 **最少操作数** 。

## 537. 拿出最少数目的魔法豆
* 给你一个正整数数组`beans`，其中每个整数表示一个袋子里装的魔法豆的数目。 请你从每个袋子中拿出一些豆子（也可以不拿出），使得剩下的非空袋子中魔法豆的数目相等 。 请你返回你需要拿出魔法豆的 最少数目。

## 538. 飞地的数量
* 给你一个二进制矩阵`grid`，其中`0`表示一个海洋单元格、`1`表示一个陆地单元格。返回网格中无法在任意次数的移动中离开网格边界的陆地单元格的数量。

## 539. “气球” 的最大数量
* 字符串`text`中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词`"balloon"`

## 540. 移除所有载有违禁货物车厢所需的最少时间
* 给你字符串`s`。`s[i] = '0'`表示第`i`节车厢不含违禁货物，`s[i] = '1'`表示第`i`节车厢含违禁货物。 需要清理掉所有载有违禁货物的车厢。你可以不限次数执行下述操作中： 从列车一端移除一节车厢，用去`1`单位时间； 从列车车厢序列的任意位置移除一节车厢，用去`2`单位时间。 返回移除所有载有违禁货物车厢所需要的最少时间。

## 541. 数组的最大与和
* 给你一个长度为`n`的整数数组`nums`和一个整数`numSlots`。总共有`numSlots`个篮子，编号为`1`到`numSlots`。 你需要把所有`n`个整数分到这些篮子中，且每个篮子至多有`2`个整数。方案的 **与和** 定义为：每个数与它所在篮子编号的 **按位与运算** 结果之和。 请你返回将`nums`中所有数放入`numSlots`个篮子中的最大与和。

## 542. 仅仅反转字母
* 给你一个字符串`s`，根据下述规则反转字符串： 所有非英文字母保留在原有位置； 所有英文字母位置反转。

## 543. 超级丑数
* 超级丑数所有质因数都出现在质数数组`primes`中。 给你一个整数`n`和一个整数数组`primes`，返回第`n`个超级丑数

## 544. 球会落何处
* 用一个大小为`m x n`的二维网格`grid`表示一个箱子。你有`n`颗球。箱子中的每个单元格都有一个对角线挡板，挡板跨过左上角和右下角，在网格中用`1`表示；挡板跨过右上角和左下角，在网格中用`-1`表示。 在箱子每一列的顶端各放一颗球，每颗球都可能卡在箱子里或从底部掉出来，或者恰好卡住。 返回数组`answer`，其中`answer[i]`是球放在顶部的第`i`列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回`-1`

## 545. 计算各个位数不同的数字个数
* 给定一个非负整数`n`，计算各位数字都不同的数字`x`的个数，其中`0 ≤ x < 10^n`

## 546. 增量元素之间的最大差值
* 给你一个整数数组`nums`，请你计算`nums[j] - nums[i]`能求得的 最大差值 ，其中`0 <= i < j < n`且`nums[i] < nums[j]`，如果不存在满足要求的`i`和`j`，返回`-1`

## 547. 统计各位数字之和为偶数的整数个数
* 给你一个正整数`num`，请你统计并返回小于或等于`num`且各位数字之和为偶数的正整数的数目

## 548. 合并零之间的节点
* 给你一个链表的头节点`head`，该链表包含由`0`分隔开的一连串整数。链表的开端和末尾的节点都满足`Node.val == 0`。 对于每两个相邻的`0`，请你将它们之间的所有节点合并成一个节点，其值是所有已合并节点的值之和，然后将所有`0`移除。返回修改后链表的头节点`head`

## 549. 构造限制重复的字符串
* 给你一个字符串`s`和一个整数`repeatLimit`，用`s`中的字符构造一个新字符串`repeatLimitedString`，使任何字母连续出现的次数都不超过`repeatLimit`次。你不必使用`s`中的全部字符。 返回字典序最大的`repeatLimitedString`

## 550. 复数乘法
* 复数可以用字符串表示，遵循 "实部+虚部i" 的形式，给你两个字符串表示的复数`num1`和`num2`，请你遵循复数表示形式，返回表示它们乘积的字符串

## 551. Fizz Buzz
* 给你一个整数`n`，找出从`1`到`n`各个整数的`Fizz Buzz`表示，并用字符串数组`answer`返回结果，其中：`answer[i] == "FizzBuzz"`如果`i`同时是`3`和`5`的倍数；`answer[i] == "Fizz"`如果`i`是`3`的倍数；`answer[i] == "Buzz"`如果`i`是`5`的倍数；`answer[i] == i` 如果上述条件全不满足

## 552. 验证二叉树的前序序列化
* 序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值`"#"`记录

## 553. 完美数
* 对于一个正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为完美数。判断数字是否是完美数

## 554. 分发饼干
* 对每个孩子`i`，都有一个胃口值`g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干`j`，都有一个尺寸`s[j]`。如果`s[j]>= g[i]`，我们可以将这个饼干`j`分配给孩子`i`，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值

## 555. 一手顺子
* 有一把牌，她想要重新排列这些牌，分成若干组，使每一组的牌数都是`groupSize`，并且由`groupSize`张连续的牌组成。 给你一个整数数组`hand`其中`hand[i]`是写在第`i`张牌，和一个整数`groupSize`，判断能否重排

## 556. 猫和老鼠
* 

## 557. 划分数组为连续数字的集合
* 给你一个整数数组`nums`和一个正整数`k`，请你判断是否可以把这个数组划分成一些由`k`个连续数字组成的集合。

## 558. 二叉树的镜像
* 输入一个二叉树，该函数输出它的镜像

## 559. 统计包含给定前缀的字符串
* 给你一个字符串数组`words`和一个字符串`pref`。返回`words`中以`pref`作为前缀的字符串的数目

## 560. 使两字符串互为字母异位词的最少步骤数
* 给你两个字符串`s`和`t`。在一步操作中，你可以给`s`或者`t`追加任一字符 。返回使`s`和`t`互为字母异位词所需的最少步骤数

## 561. 完成旅途的最少时间
* 给你一个数组`time`，其中`time[i]`表示第`i`辆公交车完成一趟旅途所需要花费的时间。 每辆公交车连续完成多趟旅途。给你一个整数`totalTrips`，表示所有公交车总共需要完成的旅途数目。请你返回完成至少`totalTrips`趟旅途需要花费的最少时间

## 562. 最优除法
* 给定一组正整数，相邻的整数之间将会进行浮点除法操作。你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，才能得到最大的结果

## 563. 反转链表
* 给你单链表的头节点`head`,请你反转链表,并返回反转后的链表

## 564. 完成比赛的最少时间
* 给你一个二维整数数组`tires`，其中`tires[i] = [fi, ri]`表示第`i`种轮胎如果连续使用，第`x`圈需要耗时`fi * (ri ** (x - 1))`秒。 给你一个整数`changeTime`和一个整数`numLaps`。 比赛总共包含`numLaps`圈，你可以选择任意一种轮胎开始比赛。每一种轮胎都有无数条。每一圈后，你可以选择耗费`changeTime`秒换成任意一种轮胎。请你返回完成比赛需要耗费的最少时间

## 565. 最小栈
* 实现`MinStack`类:`MinStack()`初始化堆栈对象；`void push(int val)`将元素`val`推入堆栈；`void pop()`删除堆栈顶部的元素；`int top()`获取堆栈顶部的元素；`int getMin()`获取堆栈中的最小元素。

## 566. 最多可达成的换楼请求数目
* 我们有`n`栋楼，编号从`0`到`n - 1`。每栋楼有若干员工。给你一个数组`requests`，其中`requests[i] = [fromi, toi]`，表示一个员工请求从编号为`fromi`的楼搬到编号为`toi`的楼。 选出的若干个请求是可行的需要满足每栋楼员工净变化为`0`。返回所有可行列表中最大请求数目。

## 567. 设计停车系统
* 请你实现`ParkingSystem`类：`ParkingSystem(int big, int medium, int small)`初始化`ParkingSystem`类，三个参数分别对应每种停车位的数目；`bool addCar(int carType)`检查是否有`carType`对应的停车位。`carType`分别用数字`1,2,3`表示三种车。如果没有空车位，请返回`false`，否则将该车停入车位并返回`true`。

## 568. 警告一小时内使用相同员工卡大于等于三次的人
* 给你字符串数组`keyName`和`keyTime`，其中`[keyName[i], keyTime[i]]`对应一个人的名字和他在某天内使用员工卡的时间。如果一个员工在一小时时间内使用员工卡的次数大于等于三次，这个系统会自动发布一个警告。请你返回去重后的收到系统警告的员工名字，将它们按字典序升序排序后返回

## 569. 寻找最近的回文数
* 给定一个表示整数的字符串`n`，返回与它最近的回文整数（不包括自身）。如果不止一个，返回较小的那个

## 570. 各位相加
* 给定一个非负整数`num`，反复将各个位上的数字相加，直到结果为一位数。返回这个结果

## 571. 向字符串添加空格
* 给你一个字符串`s`，以及一个整数数组`spaces`。数组`spaces`描述原字符串中需要添加空格的下标。每个空格都应该插入到给定索引处的字符值之前。请你添加空格，并返回修改后的字符串。

## 572. 链表最大孪生和
* 在一个大小为`n`且`n`为偶数的链表中，对于`0 <= i <= (n / 2) - 1`的`i`，第`i`个节点的孪生节点为第`n-1-i`个节点 。**孪生和**定义为一个节点和它孪生节点两者值之和。 给你一个长度为偶数的链表的头节点`head`，请你返回链表的 **最大孪生和**

## 573. 连接两字母单词得到的最长回文串
* 给你一个字符串数组`words`。`words`中每个元素都是一个包含两个小写英文字母的单词。 请你从`words`中选择一些元素并按任意顺序连接它们，并得到一个尽可能长的回文串。每个元素至多只能使用一次。 请你返回你能得到的最长回文串的长度

## 574. 摧毁小行星
* 给你一个整数`mass`，它表示一颗行星的初始质量。再给你一个整数数组`asteroids`，其中`asteroids[i]`是第`i`颗小行星的质量。 你可以按任意顺序重新安排小行星的顺序，然后让行星跟它们发生碰撞。如果行星碰撞时的质量大于等于小行星的质量，那么小行星被摧毁，并且行星会获得这颗小行星的质量。否则，行星将被摧毁。 如果所有小行星都能被摧毁，请返回`true`，否则返回`false`

## 575. 银行中的激光束数量
* 给你一个字符串数组`bank`，表示银行的平面图，这是一个大小为`m x n`的二维矩阵。`bank[i]`表示第`i`行的设备分布，由若干`'0'`和若干`'1'`组成。`'0'`表示单元格是空的，而`'1'`表示单元格有一个安全设备。 对任意两个安全设备而言，如果两个设备位于两个不同行且二者之间的行中无安全设备，则二者之间存在一个激光束： 返回银行中激光束的总数量。

## 576. 子数组范围和
* 给你一个整数数组`nums`。`nums`中，子数组的范围是子数组中最大元素和最小元素的差值。 返回`nums`中所有子数组范围的和

## 577. 环和杆
* 总计有`n`个环，环的颜色可以是红、绿、蓝中的一种。这些环分布穿在编号为`0`到`9`的杆上。 给你一个长度为`2n`的字符串`rings`，表示这`n`个环在杆上的分布。`rings`中每两个字符描述一个环环的颜色和位置。找出所有集齐全部三种颜色环的杆的数量

## 578. 最长特殊序列 Ⅰ
* **特殊序列**为**某字符串独有的子序列**。给你两个字符串`a`和`b`，请返回 这两个字符串中最长的**特殊序列**的长度

## 579. 给植物浇水 II
* `A`和`B`打算给花园植物浇水。植物从左到右编号从`0`到`n - 1`。给你一个`plants`，`plants[i]`为第`i`株植物需要的水量。另有两个整数`capacityA`和`capacityB`分别表示`A`和`B`水罐的容量。`A`从植物`0`开始向右给植物浇水。`Bob`从植物`n - 1`开始向左给植物浇水。 只有没有足够的水完全浇灌下一株植物时，才会立即重新灌满浇水罐。如果没有足够的水 完全 浇灌下一株植物，会立即重新灌满浇水罐。返回两人浇灌所有植物过程中重新灌满水罐的次数 。

## 580. 分配给商店的最多商品的最小值
* 有`n`间零售商店。总共有`m`种产品，整数数组`quantities`表示，其中`quantities[i]`表示第`i`种商品的数目。 将所有商品分配到零售商店，并遵守这些规则： 一间商店至多只能有一种商品，但一间商店拥有的商品数目可以为任意件； 分配后，每间商店都会被分配一定数目的商品，你想最小化分配给任意商店商品数目的最大值`x`。 请你返回最小的可能的`x`

## 581. 所有子字符串中的元音
* 子字符串是字符串中一个连续的字符序列。给你一个字符串`word`，返回`word`的所有子字符串中**元音的总数**

## 582. 网格游戏 
* 给你一个二维数组`grid`，数组大小为`2 x n`，其中`grid[r][c]`表示矩阵中`(r, c)`位置上的点数。 游戏开始，第一个机器人从`(0, 0)`移动到`(1, n-1)`，并收集路径上单元格的全部点数。对于路径上所有单元格的点数会重置为`0`。然后，第二个机器人从`(0, 0)`移动到`(1, n-1)`，同样收集路径上单元的全部点数。每个机器人只会向右一步或向下一步。 第一个机器人想要使第二个机器人的点数最小化,与此相对，第二个机器人想要最大化点数。在理想条件下，返回第二个机器人的点数 。

## 583. 判断单词是否能放入填字游戏内
* 给你一个矩阵`board`，它代表一个填字游戏的初态。填字游戏格子中包含已填入的英文字母，表示可填入的`' '`和表示禁止填入的`'#'`。 如果满足以下条件，那么我们可以填入一个单词： 每个字母对应的格子要么是`' '`要么与`board`中已有字母匹配； 如果单词是水平的，那么该单词左右相邻格子不能为`' '`或英文字母； 如果单词是竖直的，那么该单词上下相邻格子不能为`' '`或英文字母。 给你一个字符串`word`，判断`word`是否可以被放入`board`中

## 584. 数组中紧跟 key 之后出现最频繁的数字
* 给你一个整数数组`nums`，同时给你一个整数`key`，它在`nums`出现过。 统计在`nums`数组中紧跟着`key`后面出现的整数`target`的出现次数。请你返回出现最多次数的`target`

## 585. 将杂乱无章的数字排序
* 给你一个整数数组`mapping`，它表示一个十进制数的映射规则，`mapping[i] = j`表示这个规则下将数位`i`映射为数位`j`。 一个整数映射后的值为将原数字每一个数位`i`映射为`mapping[i]`。 另外给你一个整数数组`nums`，请你将数组`nums`中每个数按照它们映射后对应数字非递减顺序排序后返回

## 586. 有向无环图中一个节点的所有祖先
* 给你一个正整数`n`，它表示一个有向无环图中节点的数目，节点编号为`0 到 n - 1`。 给你一个二维整数数组`edges`，其中`edges[i] = [fromi, toi]`表示图中一条从`fromi`到`toi`的单向边。 请你返回一个数组`answer`，其中`answer[i]`是第`i`个节点的所有 祖先 ，这些祖先节点 升序 排序。

## 587. Excel 表中某个范围内的单元格
* Excel表中的一个单元格`(r, c)`会以字符串`"cr"`的形式进行表示，其中：`c`用英文字母表中的字母标识。`r`用整数标识。 给你一个格式为`"c1r1:c2r2"`的字符串`s`，找出所有满足`r1 <= x <= r2`且`c1 <= y <= c2`的单元格，并以列表形式返回，并以 **先列再行** 的递增顺序排列。

## 588. 向数组中追加 K 个整数
* 给你一个整数数组`nums`和一个整数`k`。请你向`nums`中追加`k`个未出现在`nums`中的、互不相同的正整数，并使结果数组的元素和最小。 返回追加到`nums`中的`k`个整数之和。

## 589. 根据描述创建二叉树
* 给你一个二维整数数组`descriptions`，其中`descriptions[i] = [parenti, childi, isLefti]`表示`parenti`是`childi`的父节点，二叉树中各节点的值互不相同 。此外： 如果`isLefti == 1`，那么`childi`就是`parenti`的左子节点。 如果`isLefti == 0`，那么`childi`就是`parenti`的右子节点。 请你根据`descriptions`的描述来构造二叉树并返回其根节点 。

## 590. 替换数组中的非互质数
* 给你一个整数数组`nums`。请你对数组执行下述操作： 找出任意两个相邻的非互质数，删除这两个数，并替换为它们的最小公倍数。重复直到不再存在这样的数。返回修改后得到的 最终 数组。

## 591. 适合打劫银行的日子
* 你和一群强盗准备打劫银行。给你一个整数数组`security`，其中`security[i]`是第`i`天执勤警卫的数量。同时给你一个整数`time`。果第`i`天满足以下所有条件，我们称它为一个适合打劫银行的日子： 前和后都分别至少有`time`天； 之前连续`time`天警卫数目都是非递增的；之后连续`time`天警卫数目都是非递减的。请你返回一个数组，包含 所有 适合打劫银行的日子

## 592. 七进制数
* 给定一个整数`num`，将其转化为`7`进制，并以字符串形式输出。

## 593. 复制带随机指针的链表
* 给你一个链表，每个节点包含一个额外增加的随机指针`random`，该指针可以指向链表中的任何节点或空节点。 构造这个链表的 深拷贝。

## 594. 二叉搜索树迭代器
* 实现一个二叉搜索树迭代器类`BSTIterator`，表示一个按中序遍历二叉搜索树的迭代器：`BSTIterator(TreeNode root)`：初始化`BSTIterator`类的一个对象。`BST`的根节点`root`会作为构造函数的一部分给出。指针应初始化为一个小于`BST`中的任何元素的数字；`boolean hasNext()`：如果向指针右侧遍历存在数字，则返回`true`；否则返回`false`；`int next()`：将指针向右移动，然后返回指针处的数字。

## 595. 统计数组中相等且可以被整除的数对
* 给你一个整数数组`nums`和一个整数`k`，请你返回满足`0 <= i < j < n`，`nums[i] == nums[j]`且`i * j`能被`k`整除的数对`(i, j)`的数目。

## 596. 找到和为给定整数的三个连续整数
* 给你一个整数`num`，请你返回三个连续的整数，它们的和为`num`。如果`num`无法被表示成三个连续整数的和，请你返回一个空数组

## 597. 拆分成最多数目的正偶数之和
* 给你一个整数`finalSum`。请你将它拆分成若干个互不相同的正偶数之和，且拆分出来的正偶数数目最多

## 598. 得分最高的最小轮调
* 给你一个数组`nums`，我们可以将它按一个非负整数`k`进行轮调，这样可以使数组变为`[nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]`的形式。此后，任何值小于或等于其索引的项都可以记作一分。 在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调下标`k` 

## 599. N 叉树的前序遍历
* 给定一个`n`叉树的根节点`root`，返回 其节点值的前序遍历 。

## 600. 多数元素
* 给定一个大小为`n`的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于`n/2`的元素

## 601. Excel表列名称
* 给你一个整数`columnNumber`，返回它在Excel表中相对应的列名称

## 602. 引爆最多的炸弹
* 炸弹用一个二维整数数组`bombs`表示，其中`bombs[i] = [xi, yi, ri]`。`xi`和`yi`表示第`i`个炸弹的`X`和`Y`坐标，`ri`表示爆炸范围的半径。 当炸弹被引爆时，所有在它爆炸范围内的炸弹都会被引爆。 给你数组`bombs`，请你返回在引爆一个炸弹的前提下，最多能引爆的炸弹数目

## 603. N 叉树的后序遍历
* 给定一个`n`叉树的根节点`root`，返回其节点值的后序遍历

## 604. 找出数组中的所有 K 近邻下标
* 给你一个整数数组`nums`和两个整数`key`和`k`。K近邻下标是`nums`中的一个下标`i`，并满足至少存在一个下标`j`使得`|i - j| <= k`且`nums[j] == key`。 以列表形式返回按递增顺序排序的所有K近邻下标

## 605. 统计可以提取的工件
* 存在一个网格，网格中埋着一些工件。给你一个整数`n`和一个二维整数数组`artifacts`，其中`artifacts[i] = [r1i, c1i, r2i, c2i]`表示第`i`个工件，`(r1i, c1i)`是左上的坐标，`(r2i, c2i)`是右下的坐标。 你将会挖掘网格中的一些单元格。如果一个工件的所有部分都被挖到，你就可以提取该工件。 给你一个二维整数数组`dig`，其中`dig[i] = [ri, ci]`表示你将会挖掘单元格`(ri, ci)`，返回你可以提取的工件数目。

## 606. K 次操作后最大化顶端元素
* 给你一个整数数组`nums`，它表示一个栈，其中`nums[0]`是栈顶的元素。 每一次操作中，你可以执行以下操作之一 ： 如果栈非空，那么删除栈顶端的元素； 如果有删除的元素，你可以从它们中选择任何一个，添加回栈顶。 同时给你一个整数`k`，它表示你总共需要执行操作的次数。 请你返回执行`k`次操作以后，栈顶元素的最大值。如果栈一定为空，请你返回`-1`。

## 607. 得到要求路径的最小带权子图
* 给你一个整数`n`，它表示一个带权有向图的节点数，节点编号为`0`到`n - 1`。 同时给你一个二维整数数组`edges`，其中`edges[i] = [fromi, toi, weighti]`，表示从`fromi`到`toi`有一条边权为`weighti`的有向边。 给你三个互不相同的整数`src1`，`src2`和`dest`，表示图中三个不同的点。 请你从图中选出一个边权和最小的子图，使得从`src1`和`src2`出发，在这个子图中，都可以到达`dest`。如果这样的子图不存在，请返回`-1`

## 608. 两个列表的最小索引总和
* 选择一家餐厅，二人都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。 用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。

## 609. 旋转函数
* 给定一个长度为`n`的整数数组`nums`。 假设`arrk`是数组`nums`顺时针旋转`k`个位置后的数组。我们定义`nums`的旋转函数`F`为：`F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]`。 返回`F(0), F(1), ..., F(n-1)`中的最大值

## 610. 分割等和子集
* 给你一个只包含正整数的非空数组`nums`。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等

## 611. 词典中最长的单词
* 给出一个字符串数组`words`组成的一本英语词典。返回`words`中最长的一个单词，该单词是由`words`词典中其他单词逐步添加一个字母组成。 若其中有多个可行的答案，则返回答案中字典序最小的单词

## 612. 全 O(1) 的数据结构
* 实现`AllOne`类：`AllOne()`初始化数据结构的对象；`inc(String key)`字符串`key`的计数增加`1`。如果数据结构中尚不存在`key`，那么插入计数为`1`的`key`；`dec(String key)`字符串`key`的计数减少`1`。如果`key`的计数在减少后为`0`，那么需要将这个`key`从数据结构中删除；`getMaxKey()`返回任意一个计数最大的字符串。如果没有元素存在，返回一个空字符串`""`；`getMinKey()`返回任意一个计数最小的字符串。如果没有元素存在，返回一个空字符串`""` 

## 613. 将数组划分成相等数对
* 给你一个整数数组`nums`，它包含`2 * n`个整数。 你需要将`nums`划分成`n`个数对，同一数对中的元素相等 。 如果可以将`nums`划分成`n`个数对，请你返回`true`，否则返回`false`

## 614. 字符串中最多数目的子字符串
* 给你一个字符串`text`和另一个长度为`2`的字符串`pattern`，两者都只包含小写英文字母。 你可以在`text`中或在`text`开头结尾任意位置插入一个字符，这个插入的字符必须是`pattern[0]`或者`pattern[1]`。请你返回插入一个字符后，`text`中最多包含多少个等于`pattern`的子序列

## 615. 将数组和减半的最少操作次数
* 给你一个正整数数组`nums`。每一次操作中，你可以从`nums`中选择任意一个数并将它减小到一半。请你返回将`nums`数组和至少减少一半的最少操作数

## 616. 用地毯覆盖后的最少白色砖块
* 给你一个字符串`floor`，它表示地板上砖块的颜色。`floor[i] = '0'`表示地板上第`i`块砖块的颜色是黑色。`floor[i] = '1'`表示地板上第`i`块砖块的颜色是白色。 同时给你`numCarpets`和`carpetLen`。你有`numCarpets`条黑色的地毯，每一条地毯长度都为`carpetLen`块。请你使用这些地毯去覆盖砖块，使得未被覆盖的白色砖块的数目最小。地毯相互之间可以覆盖。 请你返回没被覆盖的白色砖块的最少数目

## 617. 根据二叉树创建字符串
* 你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串

## 618. 统计数组中峰和谷的数量
* 你一个整数数组`nums`。如果两侧距`i`最近的不相等邻居的值均小于`nums[i]`，则下标`i`是`nums`中，某个峰的一部分。类似地，如果两侧距`i`最近的不相等邻居的值均大于`nums[i]`，则下标`i`是`nums`中某个谷的一部分。对于相邻下标`i`和`j` 。 返回`nums`中峰和谷的数量

## 619. 统计道路上的碰撞次数
* 一条无限长的公路上有`n`辆汽车正在行驶，每辆车都在一个位置。 给你一个字符串`directions`，长度为`n`。`directions[i]`可以是`'L'`、`'R'`或`'S'`分别表示第`i`辆车是向左、右或者停留在当前位置。每辆车移动时速度相同。 碰撞次数可以按下述方式计算： 当两辆移动方向相反的车相撞时，碰撞次数加`2`； 当一辆移动的车和一辆静止的车相撞时，碰撞次数加`1`； 碰撞发生后，涉及的车辆将无法继续移动并停留在碰撞位置。 返回在这条道路上发生的碰撞总次数

## 620. 射箭比赛中的最大得分
* 给你整数`numArrows`和一个长度为`12`的整数数组`aliceArrows`，该数组表示A射中`0`到`11`每个计分区域的箭数量。现在，B想要尽可能最大他所能获得的总分。 返回数组`bobArrows`，该数组表示B射中`0`到`11`每个计分区域的箭数量。且`bobArrows`的总和应当等于`numArrows`分数按下述规则计算： 箭靶上每个区域都对应一个得分`k`，范围是`0`到`11`，A和B分别在得分`k`区域射中`ak`和`bk`支箭。如果`ak >= bk`，那么A得`k`分，如果`ak < bk`，则B得`k`分 ，如果`ak == bk == 0`，那么无人得分。

## 621. 字典序的第K小数字
* 给定整数`n`和`k`，返回`[1, n]`中字典序第`k`小的数字。

## 622. 图片平滑器
* 对图像的每个单元格平滑处理，平滑处理后单元格的值为该单元格的平均灰度。 每个单元格的 **平均灰度** 定义为：该单元格自身及其周围的`8`个单元格(如果存在)的平均值，结果需向下取整

## 623. Excel 表列序号
* 给你一个字符串`columnTitle`，表示`Excel`表格中的列名称。返回该列名称对应的列序号 。

## 624. 找出数组的最大公约数
* 给你一个整数数组`nums`，返回数组中最大数和最小数的 最大公约数

## 625. 找出不同的二进制字符串
* 给你一个字符串数组`nums`，该数组由`n`个互不相同的二进制字符串组成，且每个字符串长度都是`n`。请你找出并返回一个长度为`n`且没有出现 在`nums`中的二进制字符串

## 626. 最小化目标值与所选元素的差
* 给你一个整数矩阵`mat`和一个整数`target`。 从矩阵的每一行中选择一个整数，你的目标是最小化所有选中元素之和与目标值`target`的绝对差。 返回最小的绝对差

## 627. 找出数组中的第 K 大整数
* 给你一个字符串数组`nums`和一个整数`k`。`nums`中的每个字符串都表示一个不含前导零的整数。 返回`nums`中表示第`k`大整数的字符串

## 628. 棒球比赛
* 得到一个记录操作的字符串列表`ops`，其中`ops[i]`是你需要记录的第`i`项操作，`ops`遵循下述规则： 整数`x`表示本回合新获得分数`x`；`"+"`表示本回合新获得的得分是前两次得分的总和；`"D"`表示本回合新获得的得分是前一次得分的两倍；`"C"`表示前一次得分无效，将其从记录中移除。 请你返回记录中所有得分的总和。

## 629. 完成任务的最少工作时间段
* 你被安排了`n`个任务。任务需要花费的时间用数组`tasks`表示，第`i`个任务需要花费`tasks[i]`小时完成。至多连续工作`sessionTime`个小时，为一个时间段。 如果你在某一个时间段开始一个任务，你需要在同一个时间段完成它。 给你`tasks`和`sessionTime`，请你按照上述要求，返回完成所有任务所需要的最少数目的时间段。

## 630. 我能赢吗
* 两个玩家可以轮流不放回地从公共整数池中抽取从`1`到`maxChoosableInteger`的整数，直到累计整数和大于等于`desiredTotal`。判断先出手的玩家是否能稳赢

## 631. 找出两数组的不同
* 给你两个整数数组`nums1`和`nums2`，请你返回一个长度为`2`的列表`answer`，其中：`answer[0]`是`nums1`中所有不存在于`nums2`中的不同整数组成的列表；`answer[1]`是`nums2`中所有不存在于`nums1`中的不同整数组成的列表。

## 632. 美化数组的最少删除数
* 给你一个整数数组`nums`，如果满足下述条件，则认为数组`nums`是一个美丽数组 ：`nums.length`为偶数； 对所有满足`i % 2 == 0`的下标`i`，`nums[i] != nums[i + 1]`均成立。 当你删除一个元素时，被删除元素右侧的所有元素将会向左移动一个单位以填补空缺。 返回使`nums`变为美丽数组所需删除的最少元素数目

## 633. 找到指定长度的回文数
* 给你一个整数数组`queries`和一个正整数`intLength`，请你返回一个数组`answer`，其中`answer[i]`是长度为`intLength`的正回文数中第`queries[i]`小的数字，如果不存在这样的回文数，则为`-1`

## 634. 从栈中取出 K 个硬币的最大面值和
* 一张桌子上总共有`n`个硬币栈。每个栈有正整数个带面值的硬币。 每一次操作中，你可以从任意一个栈的顶部取出`1`个硬币，从栈中移除它，并放入你的钱包里。 给你一个列表`piles`，其中`piles[i]`是一个整数数组，分别表示第`i`个栈里从顶到底的硬币面值。同时给你一个正整数`k`，请你返回在恰好进行`k`次操作的前提下，你钱包里硬币面值之和最大为多少

## 635. 交替位二进制数
* 给定一个正整数，检查它的二进制表示是否总是`0`、`1`交替出现

## 636. 输出二叉树
* 在一个`m*n`的二维字符串数组中输出二叉树，并遵守以下规则： 行数`m`应当等于给定二叉树的高度； 列数`n`应当总是奇数； 根节点的值应当放在可放置的第一行正中间。根节点所在的行与列会将剩余空间划分为两部分。你应该将左子树输出在左下部分，右子树输出在右下部分。左下和右下部分应当有相同的大小，如果两个子树都为空则不需要为它们留出任何空间； 每个未使用的空间应包含一个空的字符串`""`； 使用相同的规则输出子树。

## 637. 求解方程
* 求解一个给定的方程，将`x`以字符串`"x=#value"`的形式返回。该方程仅包含`'+'`，`'-'`操作，变量`x`和其对应系数。

## 638. 设计循环双端队列
* 实现`MyCircularDeque`类:`MyCircularDeque(int k)`：构造函数,双端队列最大为`k`；`boolean insertFront()`：将一个元素添加到双端队列头部。 如果操作成功返回`true`，否则返回`false`；`boolean insertLast()`：将一个元素添加到双端队列尾部。如果操作成功返回`true`，否则返回`false`；`boolean deleteFront()`：从双端队列头部删除一个元素。 如果操作成功返回`true`，否则返回`false`；`boolean deleteLast()`：从双端队列尾部删除一个元素。如果操作成功返回`true`，否则返回`false`；`int getFront()`：从双端队列头部获得一个元素。如果双端队列为空，返回`-1`；`int getRear()`：获得双端队列的最后一个元素。如果双端队列为空，返回`-1`；`boolean isEmpty()`：若双端队列为空，则返回`true`，否则返回`false`；`boolean isFull()`：若双端队列满了，则返回`true`，否则返回`false`。

## 639. 寻找重复的子树
* 给定一棵二叉树`root`，返回所有重复的子树。

## 640. 找到处理最多请求的服务器
* 你有`k`个服务器，编号为`0`到`k-1`，一个服务器同时处理最多一个请求。 第`i`个请求到达时，如果所有服务器都已被占据，那么该请求被舍弃。 如果第`(i % k)`个服务器空闲，那么对应服务器会处理该请求， 否则依次校验下一个服务器，直到找到空闲服务器。 给你一个严格递增的正整数数组`arrival`，表示任务的到达时间，和另一个数组`load`表示第`i`个请求的工作量。你的任务是找到任务最多的服务器。

## 641. 自除数
* 自除数 是指可以被它包含的每一位数整除的数，且其不含有`0`。给定两个整数`left`和`right`，返回一个列表，列表的元素是范围`[left, right]`内所有的自除数 。

## 642. 二倍数对数组
* 给定一个长度为偶数的整数数组`arr`，只有对`arr`进行重组后可以满足 “对于每个`0 <=`i < len(arr) / 2`，都有`arr[2 * i + 1] = 2 * arr[2 * i]”`时，返回`true`；否则返回`false`

## 643. 转换数字的最少位翻转次数
* 一次位翻转定义为将数字`x`二进制中的一个位进行翻转操作，即将`0`变成`1`，或者将`1`变成`0`。给你两个整数`start`和`goal`，请你返回将`start`转变成`goal`的最少位翻转次数。

## 644. 数组的三角和
* 给你一个整数数组`nums`，其中`nums[i]`是`0`到`9`之间的一个数字。`nums`的三角和是执行以下操作以后最后剩下元素的值：`nums`初始包含`n`个元素。创建一个新的长度为`n - 1`的整数数组`newNums`； 对于满足`0 <= i < n - 1`的下标`i`，`newNums[i]`赋值为`(nums[i] + nums[i+1]) % 10`； 将`newNums`替换数组`nums`； 重复整个过程直到`n == 1`。 请你返回`nums`的三角和。

## 645. 选择建筑的方案数
* 给你一个二进制字符串`s`，它表示一条街沿途的建筑类型。选择`3`栋建筑，靠近的两栋不能是同一类型。请你返回可以选择的有效方案数 。

## 646. 强密码检验器
* 如果一个密码满足下述所有条件，则认为这个密码是强密码： 由至少`6`个，至多`20`个字符组成； 包含小写字母，大写字母，数字； 同一字符不能连续出现三次。 给你一个字符串`password`，返回将`password`修改到满足强密码条件需要的最少修改步数。 在一步修改操作中可以： 插入一个字符到`password`； 从`password`中删除一个字符； 用另一个字符来替换`password`中的某个字符。

## 647. 转化时间需要的最少操作数
* 给你两个字符串`current`和`correct`，表示两个时间，按`"HH:MM"`进行格式化。在一步操作中，你可以将 current 这个时间增加`1`、`5`、`15`或`60`分钟。你可以执行这一操作任意次数。 返回将`current`转化为`correct`需要的最少操作数 。

## 648. 找出输掉零场或一场比赛的玩家
* 给你一个整数数组`matches`其中`matches[i] = [winneri, loseri]`表示在一场比赛中`winneri`击败了`loseri`。 不考虑未参加比赛的人。返回一个长度为`2`的列表`answer`：`answer[0]`是所有没有输掉任何比赛的玩家列表，`answer[1]`是所有恰好输掉 一场 比赛的玩家列表。

## 649. 每个小孩最多能分到多少糖果
* 给你一个整数数组`candies`。数组中的每个元素表示大小为`candies[i]`的一堆糖果。你可以将每堆糖果分成任意数量的子堆。给你一个整数`k`。你需要将这些糖果分配给`k`个小孩，使每个小孩分到相同数量的糖果。每个小孩拿走一堆糖果，有些糖果可能会不被分配。 返回每个小孩可以拿走的最大糖果数目。 

## 650. 加密解密字符串
* 实现`Encrypter`类：`Encrypter(char[] keys, String[] values, String[] dictionary)`用`keys`、`values`和`dictionary`初始化`Encrypter`类；`String encrypt(String word1)`按上述加密过程完成对`word1`的加密，并返回加密后的字符串；`int decrypt(String word2)`统计并返回可以由`word2`解密得到且出现在`dictionary`中的字符串数目。 加密：对字符串中的每个字符`c`，先从`keys`中找出满足`keys[i] == c`的下标`i`，用`values[i]`替换字符`c`。 解密：将字符串每相邻`2`个字符划分为一个子字符串，对于每个子字符串`s`，找出满足`values[i] == s`的下标`i`，从中选择任意一个，用`keys[i]`替换`s`。

## 651. 寻找比目标字母大的最小字母
* 给你一个排序后的字符列表`letters`，列表中只包含小写英文字母。另给出一个目标字母`target`，请你寻找在这一有序列表里比目标字母大的最小字母。

## 652. 二进制表示中质数个计算置位
* 给你两个整数`left`和`right`，在闭区间`[left, right]`范围内，统计并返回计算置位位数为质数的整数个数

## 653. 区域和检索 - 数组可修改
* 实现`NumArray`类：`NumArray(int[] nums)`用整数数组`nums`初始化对象；`void update(int index, int val)`将`nums[index]`的值更新为`val`；`int sumRange(int left, int right)`返回数组`nums`中索引`left`和索引`right`之间的`nums`元素的和

## 654. 构造字符串的总得分和
* 你需要从空字符串从后端开始构造一个长度为`n`的字符串`s`，构造的过程为每次给当前字符串前面添加一个字符。构造过程中得到的所有字符串中长度为`i`的字符串编号为`si`。`si`的得分为`si`和`s`的最长公共前缀的长度。 给你字符串`s`，请你返回每一个`si`的得分之和。

## 655. 最小高度树
* 给你一棵包含`n`个节点的树，标记为`0`到`n - 1`。给定数字`n`和表示无向边的`edges`列表，其中`edges[i] = [ai, bi]`表示树中节点`ai`和`bi`之间存在一条无向边。当选择任一节点作为根节点时，都可求出树的高度。请你找到所有的最小高度树的根节点标签列表。

## 656. 旋转字符串
* 给定两个字符串,`s`和`goal`。如果在若干次旋转操作之后，`s`能变成`goal`，那么返回`true`。`s`的旋转操作 就是将`s`最左边的字符移动到最右边。

## 657. 唯一摩尔斯密码词
* 给出各个字母的摩斯密码，对`words`中所有单词进行单词翻译，返回不同 单词翻译 的数量

## 658. 到达终点
* 从点`(x, y)`可以转换到`(x, x+y) `或者`(x+y, y)`。如果通过一系列的转换可以从起点`(sx, sy)`到达终点`(tx, ty)`，则返回`true`，否则返回`false`。

## 659. 设计推特
* 实现`Twitter`类：`Twitter()`初始化简易版推特对象：`void postTweet(int userId, int tweetId)`：根据给定的`tweetId`和`userId`创建一条新推文。每次调用此函数都会使用一个不同的`tweetId`；`List<Integer> getNewsFeed(int userId)`：检索当前用户新闻推送中最近`10`条推文的`ID`。新闻推送中的每一项都必须是由用户关注的人或者是用户自己发布的推文，推文按照时间顺序由最近到最远排序；`void follow(int followerId, int followeeId)`：`ID`为`followerId`的用户开始关注`ID`为`followeeId`的用户；`void unfollow(int followerId, int followeeId)`：`ID`为`followerId`的用户不再关注`ID`为`followeeId`的用户。

## 660. 前 K 个高频元素
* 给你一个整数数组`nums`和一个整数`k`，请你返回其中出现频率前`k`高的元素

## 661. 写字符串需要的行数
* 把给定的字符串`S`从左到右写到每一行上，每一行的最大宽度为`100`，如果我们在写某个字母的时候会使这行超过了`100`，那么我们应该把这个字母写到下一行。我们给定了一个长为`26`的数组`widths`表示字母宽度。至少多少行能放下`S`，以及最后一行使用的宽度是多少个单位？

## 662. O(1) 时间插入、删除和获取随机元素
* 实现`RandomizedSet`类：`RandomizedSet()`初始化`RandomizedSet`对象；`bool insert(int val)`当元素`val`不存在时，向集合中插入该项，并返回`true`，否则，返回`false`；`bool remove(int val)`当元素`val`存在时，从集合中移除该项，并返回`true`，否则，返回`false`；`int getRandom()`随机返回现有集合中的一项，每个元素应该有相同的概率被返回

## 663. 最常见的单词
* 给定一个段落和一个禁用单词列表。返回出现次数最多，同时不在禁用列表中的单词。

## 664. 迷你语法分析器
* 给定一个字符串`S`表示一个整数嵌套列表，实现一个解析它的语法分析器并返回解析的结果`NestedInteger`。

## 665. 最富有客户的资产总量
* 给你一个`m x n`的整数网格`accounts`，其中`accounts[i][j]`是第`i`位客户在第`j`家银行托管的资产数量。返回最富有客户所拥有的资产总量。

## 666. 最大回文数乘积
* 给定一个整数`n`，返回可表示为两个`n`位整数乘积的最大回文整数。因为答案可能非常大，所以返回它对`1337`取余 。

## 667. 文件的最长绝对路径
* 文件系统中的每个文件和文件夹都有一个绝对路径，所有路径用`'/'`连接。给定一个表示文件系统的字符串`input`，返回文件系统中指向**文件**的最长绝对路径的长度 。

## 668. 字符的最短距离
* 给你一个字符串`s`和一个字符`c`。 返回一个整数数组`answer`，`answer[i]`是`s`中从下标`i`到离它最近的字符`c`的距离 。

## 669. 多个数组求交集
* 给你一个二维整数数组`nums`，其中`nums[i]`是由不同正整数组成的一个非空数组，按升序排列返回一个数组，数组中的每个元素在`nums`所有数组中都出现过。

## 670. 统计圆内格点数目
* 给你一个二维整数数组`circles`，其中`circles[i] = [xi, yi, ri]`表示网格上圆心为`(xi, yi)`且半径为`ri`的第`i`个圆，返回出现在 至少一个圆内或圆上的格点数目 。

## 671. 统计包含每个点的矩形数目
* 给你一个二维整数数组`rectangles`，其中`rectangles[i] = [li, hi]`表示第`i`个矩形长为`li`高为 hi 。给你一个二维整数数组`points`，其中`points[j] = [xj, yj]`是坐标为`(xj, yj)`的一个点。 第`i`个矩形的左下角在`(0, 0)`处，右上角在`(li, hi)`。 请你返回一个整数数组`count`，长度为`points.length`，其中`count[j]`是包含第`j`个点的矩形数目。

## 672. 花期内花的数目
* 给你一个二维整数数组`flowers`，其中`flowers[i] = [starti, endi]`表示第`i`朵花的花期从`starti`到`endi`**（都包含）**。同时给你一个整数数组`persons`，`persons[i]`是第`i`个人来看花的时间。 请你返回一个整数数组`answer`，其中`answer[i]`是第`i`个人到达时在花期内花的 数目 。

## 673. 二进制间距
* 给定一个正整数`n`，找到并返回`n`的二进制表示中两个相邻`1`之间的最长距离。如果不存在两个相邻的`1`，返回`0`。

## 674. 安装栅栏
* 在一个二维的花园中，有一些用`(x, y)`坐标表示的树。由于安装费用十分昂贵，你的任务是先用最短的绳子围起所有的树。只有当所有的树都被绳子包围时，花园才能围好栅栏。你需要找到正好位于栅栏边界上的树的坐标。

## 675. 随机数索引
* 实现`Solution`类：`Solution(int[] nums)`用数组`nums`初始化对象；`int pick(int target)`从`nums`中选出一个满足`nums[i] == target`的随机索引`i`。如果存在多个有效的索引，则每个索引的返回概率应当相等。

## 676. 按奇偶排序数组
* 给你一个整数数组`nums`，将`nums`中的的所有偶数元素移动到数组的前面，后跟所有奇数元素。

## 677. 计算字符串的数字和
* 给你一个由若干数字`0 - 9`组成的字符串`s`，和一个整数。 如果`s`的长度大于`k`，则可以执行一轮操作。在一轮操作中，需要完成以下工作： 将`s`拆分成长度为`k`的若干连续数字组 ，使得每`k`个字符都分在一组，用表示每个数字组中所有数字之和的字符串来替换对应的数字组，合并所有组以形成一个新字符串，如果新字符串的长度大于`k`则重复第一步。 返回在完成所有轮操作后的`s`。

## 678. 完成所有任务需要的最少轮数
* 给你一个整数数组`tasks`，其中`tasks[i]`表示任务的难度级别。在每一轮中，你可以完成`2`个或者`3`个相同难度级别 的任务。 返回完成所有任务需要的最少轮数，如果无法完成所有任务，返回`-1`。

## 679. 转角路径的乘积中最多能有几个尾随零
* 给你一个二维整数数组`grid`。转角路径定义为：包含至多一个弯的一组相邻单元。请你从`grid`中找出一条乘积中尾随零数目最多的转角路径，并返回该路径中尾随零的数目。

## 680. 建立四叉树
* 给你一个矩阵`grid`，矩阵由若干`0`和`1`组成。请你用四叉树表示该矩阵`grid`。我们可以按以下步骤为二维区域构建四叉树： 如果当前网格的值相同，将`isLeaf`设为`True`，将`val`设为网格相应的值，并将四个子节点都设为`Null`； 如果当前网格的值不同，将`isLeaf`设为`False`，将`val`设为任意值，然后将当前网格划分为四个子网格，进行递归。你需要返回能表示矩阵的四叉树的根结点。

## 681. 找到最接近 0 的数字
* 给你一个整数数组`nums`，请你返回`nums`中最接近`0`的数字。如果有多个答案，请你返回它们中的最大值。

## 682. 买钢笔和铅笔的方案数
* 给你一个整数`total`，表示你拥有的总钱数。同时给你两个整数`cost1`和`cost2`，分别表示一支钢笔和一支铅笔的价格。你可以花费你部分或者全部的钱，去买任意数目的两种笔。 请你返回购买钢笔和铅笔的不同方案数目。

## 683. 设计一个 ATM 机器
* 请你实现`ATM`类：`ATM()`初始化`ATM`对象；`void deposit(int[] banknotesCount)`分别存入`$20`，`$50`，`$100`，`$200`，`$500`钞票的数目；`int[] withdraw(int amount)`返回一个长度为`5`的数组，分别表示`$20`，`$50`，`$100`，`$200`，`$500`钞票的数目，并且更新`ATM`机里取款后钞票的剩余数量。如果无法取出指定数额的钱，请返回`[-1]`，这种情况下不取出任何钞票。

## 684. 统计是给定字符串前缀的字符串数目
* 给你一个字符串数组`words`和一个字符串`s`，其中`words[i]`和`s`只包含小写英文字母。请你返回`words`中是字符串`s`前缀的字符串数目。

## 685. 最小平均差
* 给你一个长度为`n`的整数数组`nums`。 下标`i`处的平均差指的是`nums`中前`i + 1`个元素平均值和后`n - i - 1`个元素平均值的绝对差。两个平均值都需要向下取整到最近的整数。 请你返回产生最小平均差的下标。如果有多个下标最小平均差相等，请你返回最小的一个下标。

## 686. 统计网格图中没有被保卫的格子数
* 给你两个整数`m`和`n`表示一个`m x n`网格图。同时给你两个二维整数数组`guards`和`walls`，其中`guards[i] = [rowi, coli]`且`walls[j] = [rowj, colj]`，分别表示第`i`个警卫和第`j`座墙所在的位置。 一个警卫能看到`4`个坐标轴方向的所有格子，除非他们被一座墙或者另外一个警卫挡住。如果一个格子能被警卫看到，那么我们说这个格子被保卫了。 请你返回空格子中，有多少个格子是没被保卫的。

## 687. 最小差值 I
* 给你一个整数数组`nums`，和一个整数`k`。 在一个操作中，您可以选择`0 <= i < nums.length`的任何索引`i`。将`nums[i]`改为`nums[i] + x`，其中`x`是一个范围为`[-k, k]`的整数。对于每个索引`i`，应用一次此操作。`nums`的分数是`nums`中最大和最小元素的差值。 在对`nums`中的每个索引最多应用一次上述操作后，返回`nums`的最低分数 。

## 688. 两棵二叉搜索树中的所有元素
* 给你`root1`和`root2`这两棵二叉搜索树。请你返回一个列表，其中包含两棵树中的所有整数并按升序排序。

## 689. 移除指定数字得到的最大结果
* 从`number`中恰好移除一个等于`digit`的字符后，找出并返回按十进制表示最大的结果字符串。

## 690. 必须拿起的最小连续卡牌数
* 给你一个整数数组`cards`，其中`cards[i]`表示第`i`张卡牌的值 。如果两张卡牌的值相同，则认为这一对卡牌匹配。返回你必须拿起的最小连续卡牌数，以使在拿起的卡牌中有一对匹配的卡牌。如果无法得到一对匹配的卡牌，返回`-1`

## 691. 含最多 K 个可整除元素的子数组
* 给你一个整数数组`nums`和两个整数`k`和`p`，找出并返回满足要求的**不同的连续非空子数组**数量，要求子数组中最多`k`个可被`p`整除的元素。

## 692. 字符串的总引力
* 字符串的引力定义为：字符串中不同字符的数量。给你一个字符串`s`，返回其所有子字符串的总引力 。

## 693. 山羊拉丁文
* 山羊拉丁文的规则如下： 如果单词以元音开头，在单词后添加`"ma"`； 如果单词以辅音字母开头，移除第一个字符并将它放到末尾，之后再添加`"ma"`； 根据单词在句子中的索引(从`1`开始)，在单词最后添加与索引相同数量的字母`'a'`。 返回将`sentence`转换为山羊拉丁文后的句子。

## 694. 重新排列日志文件
* 给你一个日志数组`logs`。每条日志都是以空格分隔的字串，其第一个字为字母与数字混合的标识符。 有两种不同类型的日志： 字母日志：除标识符之外，所有字均由小写字母组成； 数字日志：除标识符之外，所有字均由数字组成。 请按下述规则将日志重新排序： 所有字母日志都排在数字日志之前； 字母日志在内容不同时，忽略标识符后，按内容字母顺序排序；在内容相同时，按标识符排序； 数字日志应该保留原来的相对顺序； 返回日志的最终顺序。

## 695. 标签验证器
* 给定一个表示代码片段的字符串，你需要实现一个验证器来解析这段代码，并返回它是否合法。合法的代码片段需要遵守以下的所有规则： 1.代码必须被合法的闭合标签包围，否则代码是无效的； 2.闭合标签（不一定合法）要严格符合格式：`<TAG_NAME>TAG_CONTENT</TAG_NAME>`。其中，`<TAG_NAME>`是起始标签，`</TAG_NAME>`是结束标签。起始和结束标签中的`TAG_NAME`应当相同。当且仅当`TAG_NAME`和`TAG_CONTENT`都是合法的，闭合标签才是合法的； 3.合法的`TAG_NAME`仅含有大写字母，长度在范围`[1,9]`之间。否则，该`TAG_NAME`是不合法的； 4.合法的`TAG_CONTENT`可以包含其他合法的闭合标签，`cdata`（请参考规则7）和任意字符（注意参考规则1）除了不匹配的`<`、不匹配的起始和结束标签、不匹配的或带有不合法`TAG_NAME`的闭合标签。否则，`TAG_CONTENT`是不合法的； 5.一个起始标签，如果没有具有相同`TAG_NAME`的结束标签与之匹配，是不合法的。反之亦然。不过，你也需要考虑标签嵌套的问题； 6.一个`<`，如果你找不到一个后续的`>`与之匹配，是不合法的。并且当你找到一个`<`或`</`时，所有直到下一个`>`的前的字符，都应当被解析为`TAG_NAME`（不一定合法）； 7.`cdata` 有如下格式：`<![CDATA[CDATA_CONTENT]]>`。`CDATA_CONTENT`的范围被定义成`<![CDATA[` 、 `]]>`之间的字符； 8.`CDATA_CONTENT`可以包含任意字符。`cdata`的功能是阻止验证器解析`CDATA_CONTENT`，所以即使其中有一些字符可以被解析为标签（无论合法与否），也应该将它们视为常规字符；

## 696. 找出游戏的获胜者
* 游戏遵循如下规则： 从第`1`个人所在位置开始， 沿着顺时针方向数`k`人，计数时需要包含起始时的那个人。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次，数到的最后一人淘汰。 如果圈子中仍然有不止一人，从顺时针下一人开始，继续执行以上步骤。 直到圈子中最后一名小伙伴赢得游戏。 给你参与游戏的小伙伴总数`n`，和一个整数`k`，返回游戏的获胜者

## 697. 乘积小于 K 的子数组
* 给你一个整数数组`nums`和一个整数`k`，请你返回子数组内所有元素的乘积严格小于`k`的连续子数组的数目。

## 698. 最近的请求次数
* 请你实现`RecentCounter`类：`RecentCounter()`初始化计数器；`int ping(int t)`在时间`t`添加一个新请求，其中`t`表示以毫秒为单位的某个时间，返回在`[t-3000, t]`内发生的请求数。 保证每次对`ping`的调用都使用比之前更大的`t`值。

## 699. 数组中重复的数据
* 给你一个长度为`n`的整数数组`nums`，其中`nums`的所有整数都在范围`[1, n]`内，且每个整数出现一次或两次。请你找出所有出现两次的整数

## 700. 字符串中最大的 3 位相同数字
* 给你一个数字构成的字符串`num`，在其中寻找**连续**、**相同**的三个字符构成的最大的数字

## 701. 统计值等于子树平均值的节点数
* 给你一棵二叉树的根节点`root`，找出并返回满足要求的节点数，要求节点的值等于其子树中值的平均值

## 702. 统计打字方案数
* 为了打出一个字母，需要按九键键盘中字母对应数字`i`次，`i`是该字母在这个按键上所处的位置。给你一个字符串`pressedKeys`表示输入数字，返回可能字符串的个数

## 703. 增减字符串匹配
* 由范围`[0,n]`内所有整数组成的`n + 1`个整数的排列序列可以表示为长度为`n`的字符串`s`，其中:如果`perm[i] < perm[i + 1]`，那么`s[i] == 'I'``； 如果`perm[i] > perm[i + 1]`，那么`s[i] == 'D'``。 给定一个字符串`s`，重构排列`perm`并返回它

## 704. 数组中的第K个最大元素
* 给定数组`nums`与整数`k`，求数组中的第`k`个最大元素

## 705. 序列化和反序列化二叉搜索树
* 设计一个算法来序列化和反序列化 二叉搜索树

## 706. 猫和老鼠 II
* pass

## 707. 删列造序
* 给你由`n`个小写字母字符串组成的数组`strs`，其中每个字符串长度相等。 这些字符串可以每个一行，排成一个网格。你需要找出不是按字典序升序排列的列的数量。

## 708. 最少移动次数使数组元素相等 II
* 给你一个整数数组`nums`，返回使所有数组元素相等需要的最少移动数。 在一步操作中，你可以使数组中的一个元素加减`1`。

## 709. 乘法表中第k小的数
* 给定高度`m` 、宽度`n`的一张`m * n`的矩形乘法表，以及正整数`k`，你需要返回表中第`k`小的数字。

## 710. 验证外星语词典
* 给定一组用外星语书写的单词`words`，以及其字母表的顺序`order`，判断给定的单词是否按这种外星语中按字典序排列

## 711. 后继者
* 设计一个算法，找出二叉搜索树中指定节点的中序后继

## 712. 最大三角形面积
* 给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。

## 713. 贴纸拼词
* 我们有`n`种不同的贴纸。每个贴纸上都有一个小写的英文单词。 您想要拼写出给定的字符串`target`，方法是从收集的贴纸中切割单个字母并重新排列它们。每个贴纸的数量是无限的。 返回你需要拼出`target`的最小贴纸数量。如果任务不可能，则返回`-1`。

## 714. 一次编辑
* 字符串有三种编辑操作:插入一个英文字符、删除一个英文字符或者替换一个英文字符。 给定两个字符串，编写一个函数判定它们是否只需要`1/0`次编辑。

## 715. 在长度 2N 的数组中找出重复 N 次的元素
* 给你一个整数数组`nums`长为`2n`，有一个数字重复了`n+1`次，其他数字互不相同，寻找那个重复了`n+1`次的数字

## 716. 字母在字符串中的百分比
* 给你一个字符串`s`和一个字符`letter`，返回在`s`中等于`letter`字符所占的百分比，向下取整到最接近的百分比。

## 717. 装满石头的背包的最大数量
* 现有`n`个背包。给你两个整数数组`capacity`和`rocks`。第`i`个背包最大可以装`capacity[i]`块石头，当前已经装了`rocks[i]`块石头。另给你一个整数 additionalRocks ，表示你可以放置的额外石头数量。 请你将额外的石头放入一些背包中，并返回放置后装满石头的背包的最大数量。

## 718. 表示一个折线图的最少线段数
* 给你一个二维整数数组`stockPrices`，其中`stockPrices[i] = [dayi, pricei]`表示股票在`dayi`的价格为`pricei`。折线图是一个二维平面上的若干个点组成的图，横坐标表示日期，纵坐标表示价格，折线图由相邻的点连接而成。 请你返回要表示一个折线图所需要的最少线段数

## 719. 移除字母异位词后的结果数组
* 给你一个字符串`words`，其中`words[i]`由小写英文字符组成。 在一步操作中，需要选出任一下标`i`，从`words`中删除`words[i]`。其中下标`i`需要同时满足下述两个条件：`0 < i < words.length`时，`words[i - 1]`和`words[i]`是字母异位词 。 只要可以选出满足条件的下标，就一直执行这个操作。 在执行所有操作后，返回`words`。

## 720. 不含特殊楼层的最大连续楼层数
* 给你两个整数`bottom`和`top`，表示租用了从`bottom`到`top`含`bottom`和`top`在内的所有楼层。另给你一个整数数组`special`指定特殊楼层。 返回不含特殊楼层的最大连续楼层数。

## 721. 按位与结果大于零的最长组合
* 给你一个正整数数组`candidates`。计算`candidates`中的数字每种组合下按位与的结果。`candidates`中的每个数字在每种组合中只能使用一次。 返回按位与结果大于`0`的最长组合的长度。

## 722. 为高尔夫比赛砍树
* 你被请来给一个要举办高尔夫比赛的树林砍树。树林由一个整数矩阵表示，在这个矩阵中，`0`表示障碍，无法触碰；`1`表示地面，可以行走； 比`1`大的数表示树，可以行走，数值表示树的高度。 每一步，可以向上、下、左、右移动一个单位，如果你站的地方有一棵树，那么你可以决定是否要砍倒它。 你需要按照树的高度从低向高砍掉所有的树，每砍过一颗树，该单元格的值变为`1`。 你将从`(0, 0)`点开始工作，返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回`-1`。 可以保证的是，没有两棵树的高度是相同的

## 723. 单值二叉树
* 判断二叉树是否是单值的

## 724. 环绕字符串中唯一的子字符串
* 把字符串`s`是`“abcdefghijklmnopqrstuvwxyz”`的无限环绕字符串。现在给定另一个字符串`p`。返回`s`中唯一的`p`的非空子串的数量

## 725. 找到一个数字的 K 美丽值 
* 一个整数`num`的`k`美丽值定义为`num`中符合以下条件的子字符串数目： 子字符串长度为`k`； 子字符串能整除`num`。 给你整数`num`和`k`，请你返回`num`的`k`美丽值。

## 726. 分割数组的方案数
* 给你一个整数数组`nums`。 如果前`i + 1`个元素的和大于等于剩下的`n - i - 1`(大于0个)个元素的和，那么`nums`在下标`i`处有一个合法的分割。 请你返回`nums`中的合法分割方案数。

## 727. 毯子覆盖的最多白色砖块数 
* 给你一个二维整数数组`tiles`，其中`tiles[i] = [li, ri]`，表示所有在`li <= j <= ri`之间的每个位置`j`都被贴上了瓷砖。 同时给你一个整数`carpetLen`，表示可以放在任何位置的一块毯子。 请你返回使用这块毯子，最多`可以盖住多少块瓷砖。

## 728. 单词距离
* 有个内含单词的超大文本文件，给定任意两个不同的单词，找出在这个文件中这两个单词的最短距离

## 729. 删除最外层的括号
* 对`s`进行原语化分解，删除分解中每个原语字符串的最外层括号，返回`s`

## 730. 恢复空格
* 有一本厚厚的词典`dictionary`，不过，有些词没在词典里。假设文章用`sentence`表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。

## 731. 判断一个数的数字计数是否等于数位的值
* 给你一个字符串`num`，它只包含数字。 如果对于每个下标`i`，都满足数位`i`在`num`中出现了`num[i]`次，那么请你返回`true`，否则返回`false`。

## 732. 最多单词数的发件人
* 给你两个字符串数组`messages`和`senders`，其中`messages[i]`是`senders[i]`发出的一条信息。 一条信息是若干用单个单词用空格连接的。请你返回发出单词数最多的发件人名字。如果有多个发件人发出最多单词数，请你返回字典序最大的名字。

## 733. 道路的最大总重要性
* 给你一个整数`n`，表示一个国家里的城市数目。城市编号为`0`到`n - 1`。 给你一个二维整数数组`roads`，其中`roads[i] = [ai, bi]`表示城市`ai`和`bi`之间有一条双向道路。 你需要给每个城市安排一个从`1`到`n`之间的整数值，且每个值只能被使用一次 。道路的重要性定义为这条道路连接的两座城市数值之和 。 请你返回在最优安排下，所有道路重要性之和最大为多少。

## 734. 重排字符形成目标字符串
* 给你两个字符串`s`和`target`。你可以从`s`取出一些字符并将其重排，得到若干新的字符串。 从`s`中取出字符并重新排列，返回可以形成`target`的最大副本数。

## 735. 价格减免
* 句子是由若干个单词组成的字符串，单词之间用单个空格分隔，其中每个单词可以包含数字、小写字母、和美元符号 '$' 。如果单词的形式为美元符号后跟着一个非负实数，那么这个单词就表示一个价格。 给你一个字符串`sentence`和一个整数`discount`。对于每个表示价格的单词，都在价格的基础上减免`discount%`，并更新该单词到句子中。所有更新后的价格应该表示为一个保留小数点后两位的数字。 返回表示修改后句子的字符串。

## 736. 到达角落需要移除障碍物的最小数目
* 你一个二维整数数组`grid`，数组大小为`m x n`。每个单元格，`0`表示一个空单元格，`1`表示一个可以移除的障碍物。 你可以向上、下、左、右移动，从一个空单元格移动到另一个空单元格。 现在从左上角`(0, 0)`移动到右下角`(m - 1, n - 1)`，返回需要移除的障碍物的最小数目。

## 737. 验证IP地址
* 给定一个字符串`queryIP`。如果是有效的`IPv4`地址，返回`"IPv4"`；如果是有效的`IPv6`地址，返回`"IPv6"`；如果不是上述类型，返回`"Neither"`。

## 738. 太平洋大西洋水流问题
* 有一个矩形岛屿，与太平洋和大西洋相邻。太平洋处于大陆的左边界和上边界，而大西洋处于大陆的右边界和下边界。 给定一个`m x n`的整数矩阵`heights`，`heights[r][c]`表示坐标`(r, c)`上单元格 高于海平面的高度。 岛上雨水较多，如果相邻单元格的高度小于或等于当前单元格的高度，雨水可以直接向上下左右流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。 返回网格坐标`result`的列表 ，其中`result[i] = [ri, ci]`表示雨水从单元格 (ri, ci) 流动 既可流向太平洋也可流向大西洋 。

## 739. 从根到叶的二进制数之和
* 给出一棵二叉树，其上每个结点的值都是`0`或`1`。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。返回这些数字之和

## 740. 掉落的方块
* 在二维平面上的`x`轴上，放置着一些方块。 给你一个二维整数数组`positions`，其中`positions[i] = [lefti, sideLengthi]`表示：第 i 个方块边长为 sideLengthi ，其左侧边与`x`轴上坐标点`lefti`对齐。 每个方块都从一个比目前所有的落地方块更高的高度掉落而下。方块沿`y`轴负方向下落，直到着陆到 另一个正方形的顶边 或者是 x 轴上 。一个方块仅仅是擦过另一个方块的左侧边或右侧边不算着陆。一旦着陆，它就会固定在原地，无法移动。 在每个方块掉落后，你必须记录目前所有已经落稳的方块堆叠的最高高度 。 返回一个整数数组`ans`，其中`ans[i]`表示在第`i`块方块掉落后堆叠的最高高度。

## 741. 单词替换
* 给定一个由许多词根组成的词典`dictionary`和一个用空格分隔单词形成的句子`sentence`。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。 你需要输出替换之后的句子。

## 742. 按奇偶性交换后的最大数字
* 给你一个正整数`num`。你可以交换`num`中奇偶相同的任意两位数字， 返回交换任意次之后`num`的最大可能值。

## 743. 向表达式添加括号后的最小结果
* 给你一个字符串`expression`，格式为`"<num1>+<num2>"`，其中`<num1>`和`<num2>`表示正整数。 请你向`expression`中添加一对括号，使得在添加之后，`expression`仍然是一个有效的数学表达式，并且计算后可以得到最小可能值。左括号必须添加在`'+'`的左侧，而右括号必须添加在`'+'`的右侧。 返回添加一对括号后形成的表达式`expression` 

## 744. K 次增加后的最大乘积
* 给你一个非负整数数组`nums`和一个整数`k`。每次操作，你可以选择`nums`中任一元素并将它增加`1`。 请返回`k`次操作后，能得到的`nums的`最大乘积

## 745. 外星文字典
* 给定一个字符串列表`words`，作为这门语言的词典，`words`中的字符串已经 按这门新语言的字母顺序进行了排序 。 请你根据该词典还原出此语言中已知的字母顺序，并按字母递增顺序排列。若不存在合法字母顺序，返回`""`。

## 746. 检查是否每一行每一列都包含全部整数
* 对一个大小为`n x n`的矩阵而言，如果其每一行和每一列都包含从`1`到`n`的全部整数，则认为该矩阵是一个有效矩阵。给定矩阵，判断是否有效

## 747. 最少交换次数来组合所有的 1 II
* 给你一个二进制环形数组`nums`，返回在任意位置将数组中的所有`1`聚集在一起需要的最少交换次数。

## 748. 统计追加字母可以获得的单词数
* 转换操作： 追加一个不存在于当前字符串的字母到当前字符串的末尾；可以按任意顺序重新排布字母。 找出`targetWords`中有多少字符串能够由`startWords`中的任一字符串执行上述转换操作获得。返回`targetWords`中这类字符串的数目 。任一字符串中，每个字母至多出现一次

## 749. 独特的电子邮件地址
* 每个有效电子邮件地址都由一个本地名和一个域名组成，以`'@'`符号分隔。除小写字母之外，电子邮件地址还可以含有一个或多个`'.'`或`'+'`。如果在电子邮件地址的本地名部分中的某些字符之间添加句点`'.'`，则发往那里的邮件将会转发到本地名中没有点的同一地址。如果在本地名中添加加号`'+'`，则会忽略第一个加号后面的所有内容。给你一个字符串数组`emails`，返回实际收到邮件的不同地址数目。

## 750. 在圆内随机生成点
* 实现实现`Solution`类:`Solution(double radius, double x_center, double y_center)`用圆的半径`radius`和圆心的位置`(x_center, y_center)`初始化对象；`randPoint()`返回圆内的一个随机点，圆周上的一点被认为在圆内。答案作为数组返回`[x, y]`。

## 751. 连续整数求和
* 给定一个正整数`n`，返回连续正整数满足所有数字之和为`n`的组数 。 

## 752. 我的日程安排表 I
* 实现一个`MyCalendarThree`类：`MyCalendarThree()`初始化对象；`int book(int start, int end)`如果某时刻同时有多个会议则返回`False`，添加失败，否则成功添加，返回`True`。

## 753. 我的日程安排表 II
* 当`k`个日程安排一些时刻上的交叉时，就会产生`k`次预订。实现一个`MyCalendarThree`类：`MyCalendarThree()`初始化对象；`int book(int start, int end)`如果预定数为`3`则返回`False`，添加失败，否则成功添加，返回`True`。

## 754. 我的日程安排表 III
* 当`k`个日程安排一些时刻上的交叉时，就会产生`k`次预订。实现一个`MyCalendarThree`类：`MyCalendarThree()`初始化对象；`int book(int start, int end)`返回一个整数`k`，表示日历中存在的`k`次预订的最大值。

## 755. 爱吃香蕉的珂珂
* 这里有`n`堆香蕉，第`i`堆中有`piles[i]`根香蕉。 吃香蕉的速度`k`根/小时。每个小时，她将会选择一堆香蕉，从中吃掉`k`根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。 返回她可以在`h`小时内吃掉所有香蕉的最小速度`k`

## 756. 有效的回旋镖
* 判断三个点能否构成一个回旋镖型——即不在一条直线

## 757. 非重叠矩形中的随机点
* 实现`Solution`类:`Solution(int[][] rects)`用给定的矩形数组`rects`初始化对象，其中`rects[i] = [ai, bi, xi, yi]`表示`(ai, bi)`是第`i`个矩形的左下角点，`(xi, yi)`是第`i`个矩形的右上角点；`int[] pick()`返回一个随机的整数点`[u, v]`在给定的矩形所覆盖的空间内。

## 758. 极大极小游戏
* 算法： 设`n`等于数组`nums`的长度，如果`n == 1`，终止 算法过程。否则，创建 一个新的整数数组`newNums`，新数组长度为`n / 2`，下标从`0`开始。 对于满足`0 <= i < n / 2`的每个偶数下标`i`，将`newNums[i]`赋值为`min(nums[2 * i], nums[2 * i + 1])`； 对于满足`0 <= i < n / 2`的每个奇数下标`i`，将`newNums[i]`赋值为`max(nums[2 * i], nums[2 * i + 1])`。 用`newNums`替换`nums`。 重复整个过程。 给定数组`nums`，执行算法后，返回`nums`中剩下的那个数字。

## 759. 划分数组使最大差为 K
* 给你一个整数数组`nums`和一个整数`k`。你可以将`nums`划分成一个或多个 子序列 ，使`nums`中的每个元素都恰好出现在一个子序列中。 在满足每个子序列中最大值和最小值之间的差值最多为`k`的前提下，返回需要划分的最少子序列数目。

## 760. 替换数组中的元素
* 给你一个数组`nums`，它包含`n`个**互不相同**的正整数。请你对这个数组执行`m`个操作，在第`i`个操作中，你需要将数字`operations[i][0]`替换成`operations[i][1]`。 题目保证在第`i`个操作中，`operations[i][0]`在`nums`中存在，`operations[i][1]`在`nums`中不存在。 请你返回执行完所有操作后的数组。

## 761. 文本编辑器
* 请你实现`TextEditor`类：`TextEditor()`用空文本初始化对象；`void addText(string text)`将`text`添加到光标所在位置，添加完后光标在`text`的右边；`int deleteText(int k)`删除光标左边`k`个字符，返回实际删除的字符数目；`string cursorLeft(int k)`将光标向左移动`k`次，返回移动后光标左边`min(10, len)`个字符，其中`len`是光标左边的字符数目；`string cursorRight(int k)`将光标向右移动`k`次，返回移动后光标左边`min(10, len)`个字符，其中`len`是光标左边的字符数目。

## 762. 统计不同回文子序列
* 给定一个字符串`s`，返回`s`中不同的非空回文子序列个数 。 通过从`s`中删除`0`个或多个字符来获得子序列。

## 763. 查找和替换模式
* 如果存在字母的双射`p`，使得将模式中的每个字母`x`替换为`p(x)`之后，我们就能得到所需的单词，那么单词与模式是匹配的。 返回`words`中与给定模式匹配的单词列表。

## 764. 计算应缴税款总额 
* 给你一个二维整数数组`brackets`，其中`brackets[i] = [upperi, percenti]`，表示第`i`个税级的上限是`upperi`，征收的税率为`percenti%`。给你一个整数`income`表示你的总收入。返回你需要缴纳的税款总额。

## 765. 网格中的最小路径代价
* 给你一个整数矩阵`grid`，矩阵大小为`m x n`，由从`0`到`m * n - 1`的不同整数组成。每次可能的移动都需要付出对应的代价，代价用一个二维数组`moveCost`表示，该数组大小为`(m * n) x n`，其中`moveCost[i][j]`是从值为`i`的单元格移动到下一行第`j`列单元格的代价。从`grid`最后一行的单元格移动的代价可以忽略。`grid`一条路径的代价是：所有路径经过的单元格的值之和加上所有移动的 代价之和 。从第一行任意单元格出发，返回到达最后一行任意单元格的最小路径代价。

## 766. 公平分发饼干
* 给你一个整数数组`cookies`，其中`cookies[i]`表示在第`i`个零食包中的饼干数量。另给你一个整数`k`表示等待分发零食包的孩子数量，所有零食包都需要分发。在同一个零食包中的所有饼干都必须分发给同一个孩子。 分发的不公平程度定义为单个孩子在分发过程中能够获得饼干的最大总数。 返回所有分发的最小不公平程度。

## 767. 可互换矩形的组数
* 用一个二维整数数组`rectangles`来表示`n`个矩形，其中`rectangles[i] = [widthi, heighti]`表示第`i`个矩形的宽度和高度。 如果两个矩形`i`和`j`的宽高比相同，则认为这两个矩形可互换。 计算并返回`rectangles`中有多少对可互换矩形。

## 768. 将字符串翻转到单调递增
* 如果一个二进制字符串，是以一些或没有`0`后面跟着一些或没有`1`的形式组成的，那么该字符串是单调递增的。 给你一个二进制字符串`s`，你可以将任何`0`翻转为`1`或者将`1`翻转为`0`。 返回使`s`单调递增的最小翻转次数。

## 769. 高度检查器
* 给你一个整数数组`heights`，表示当前学生站位的高度情况。`heights[i]`是这一行中第`i`位学生的高度。将学生们按照非递增排列，得到数组`expected`。 返回满足`heights[i] != expected[i]`的下标数量 。

## 770. 找出第 K 小的数对距离
* 给你一个整数数组`nums`和一个整数`k`，数对由`nums[i]`和`nums[j]`组成且满足`0 <= i < j < nums.length`。返回所有数对距离中第`k`小的数对距离。

## 771. 数组中的 k-diff 数对
* 给你一个整数数组`nums`和一个整数`k`，请你在数组中找出不同的`k-diff`数对，并返回不同的`k-diff`数对的数目。`k-diff`数对定义为一个整数对`(nums[i], nums[j])`，并满足下述全部条件：`0 <= i, j < nums.length`；`i != j`；`nums[i] - nums[j] == k`。

## 772. 复写零
* 给你一个长度固定的整数数组`arr`，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。 请不要在超过该数组长度的位置写入元素。

## 773. 排序的循环链表
* 给定循环单调非递减列表中的一个点，写一个函数向这个列表中插入一个新元素`insertVal`，使这个列表仍然是循环升序的。

## 774. 出现次数最多的子树元素和
* 给你一个二叉树的根结点`root`，请返回**全部**出现次数最多的子树元素和。

## 775. 兼具大小写的最好英文字母
* 给你一个由英文字母组成的字符串`s`，请你找出并返回`s`中的最好英文字母。返回的字母必须为大写形式。如果不存在满足条件的字母，则返回一个空字符串。 最好英文字母的大写和小写形式必须都在`s`中出现。 英文字母`b`比另一个英文字母`a`更好的前提是：英文字母表中，`b`在`a`之后出现。

## 776. 个位数字为 K 的整数之和
* 给你两个整数`num`和`k`，考虑具有以下属性的正整数多重集： 每个整数个位数字都是`k`； 所有整数之和是`num`。 返回该多重集的最小大小，如果不存在这样的多重集，返回`-1`。

## 777. 小于等于 K 的最长二进制子序列
* 给你一个二进制字符串`s`和一个正整数`k`。 请你返回`s`的最长子序列，且该子序列对应的二进制数字小于等于`k`。

## 778. 卖木头块
* 给你两个整数`m`和`n`，分别表示一块矩形木块的高和宽。同时给你一个二维整数数组`prices`，其中`prices[i] = [hi, wi, pricei]`表示你可以以`pricei`元的价格卖一块高为`hi`宽为`wi`的矩形木块。 每一次操作中，沿垂直方向按高度完全切割木块，或沿水平方向按宽度完全切割木块，以得到两块更小的矩形木块。 在将一块木块切成若干小木块后，你可以根据`prices`卖木块。你可以卖多块同样尺寸的木块。你不需要将所有小木块都卖出去。不能旋转切好后木块的高和宽。 请你返回切割一块大小为`m x n`的木块后，能得到的最多钱数。

## 779. Range 模块
* 实现`RangeModule`类:`RangeModule()`初始化数据结构的对象；`void addRange(int left, int right)`添加半开区间`[left, right)`，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间`[left, right)`中尚未跟踪的任何数字到该区间中；`boolean queryRange(int left, int right)`只有在当前正在跟踪区间`[left, right)`中的每一个实数时，才返回`true`，否则返回`false`；`void removeRange(int left, int right)`停止跟踪 半开区间`[left, right)`中当前正在跟踪的每个实数。

## 780. 找树左下角的值
* 给定一个二叉树的根节点`root`，请找出该二叉树的最底层最左边节点的值。

## 781. IP 地址无效化
* 无效化IP地址，其实就是用`"[.]"`代替了每个`"."`。

## 782. 在每个树行中找最大值
* 给定一棵二叉树的根节点`root`，请找出该二叉树中每一层的最大值

## 783. 粉刷房子
* 一排房子，共`n`个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。每个房子粉刷成不同颜色的花费是以一个`n x 3`的正整数矩阵`costs`来表示的，`cost[i][j]`表示i房子刷j颜色的花费。请计算出粉刷完所有房子最少的花费成本。

## 784. 统计星号
* 给你一个字符串`s`，每 两个 连续竖线`'|'`为 一对 。 请你返回不在竖线对之间，`s`中`'*'`的数目。

## 785. 统计无向图中无法互相到达点对数
* 给你一个整数`n`，表示一张无向图中有`n`个节点，编号为`0`到`n - 1`。同时给你一个二维整数数组`edges`，其中`edges[i] = [ai, bi]`表示节点`ai`和`bi`之间有一条无向边。 请你返回 无法互相到达的不同点对数目`。

## 786. 操作后的最大异或和
* 给你一个整数数组`nums`。一次操作中，选择任意非负整数`x`和一个下标`i`，更新`nums[i]`为`nums[i] AND (nums[i] XOR x)`。 请你执行任意次更新操作，并返回`nums`中所有元素最大逐位异或和。

## 787. 不同骰子序列的数目
* 给你一个整数`n`。你需要掷一个`6`面的骰子`n`次。请你在满足以下要求的前提下，求出不同骰子序列的数目。序列要求： 序列中相邻数字的最大公约数为`1`；如果第`i`次掷骰子的值等于第`j`次的值，那么`abs(i - j) > 2`。

## 788. 黑名单中的随机数
* 实现`Solution`类:`Solution(int n, int[] blacklist)`初始化整数`n`和被加入黑名单`blacklist`的整数；`int pick()`返回一个范围为`[0, n - 1]`且不在黑名单`blacklist`中的随机整数。

## 789. 判断矩阵是否是一个 X 矩阵
* 如果一个正方形矩阵满足矩阵对角线上的所有元素都不是`0`，矩阵中所有其他元素都是`0`，则称之为一个X矩阵 给你一个二维整数数组`grid`，表示一个正方形矩阵。如果`grid`是一个X矩阵，返回`true`；否则，返回`false`。

## 790. 统计放置房子的方式数
* 一条街道上共有`n * 2`个地块 ，街道的两侧各有`n`个地块。每一边的地块都按从`1`到`n`编号。每个地块上都可以放置一所房子。 现要求街道同一侧不能存在两所房子相邻的情况，请你计算并返回放置房屋的方式数目

## 791. 拼接数组的最大分数
* 给你两个整数数组`nums1`和`nums2`，长度都是`n`。你可以选择两个整数 left 和 right ，其中 0 <= left <= right < n ，接着 交换 两个子数组`nums1[left...right]`和`nums2[left...right]`。 你可以选择执行上述操作一次或不执行任何操作。 数组的分数取`sum(nums1)`和`sum(nums2)`中的最大值，其中`sum(arr)`是数组`arr`中所有元素之和。 返回可能的最大分数 。

## 792. 最长特殊序列 II
* 给定字符串列表`strs`，返回其中最长的特殊序列。如果最长特殊序列不存在，返回`-1`。 特殊序列定义如下：该序列为某字符串独有的子序列。`s`的子序列可以通过删去字符串`s`中的某些字符实现。

## 793. 摆动排序 II
* 给你一个整数数组`nums`，将它重新排列成`nums[0] < nums[1] > nums[2] < nums[3]...`的顺序。

## 794. 排序数组
* 排序数组

## 795. 字符串中的最大奇数
* 给你一个字符串`num`，表示一个大整数。请你在字符串`num`的所有非空子字符串中找出值最大的奇数 ，并以字符串形式返回。如果不存在奇数，则返回一个空字符串`""`。子字符串是字符串中的一个连续的字符序列。

## 796. 你完成的完整对局数
* 在`HH:00`、`HH:15`、`HH:30`和`HH:45`，将会开始一个新的对局。给你两个字符串`startTime`和`finishTime`，均符合`"HH:MM"`格式，分别表示你进入和退出游戏的确切时间。如果`finishTime`早于`startTime`，这表示你玩了个通宵。返回你完成的完整对局的对局数 。

## 797. 统计子岛屿
* 给你两个`m x n`的二进制矩阵`grid1`和`grid2`，它们只包含`0`表示水域和`1`表示陆地。一个岛屿是由四个方向上相邻的`1`组成的区域。 如果`grid2`中该岛屿的每一个格子都被`grid1`中同一个岛屿完全包含，那么我们称`grid2`中的这个岛屿为子岛屿。 请你返回`grid2`中子岛屿的数目。 

## 798. 检查是否区域内所有整数都被覆盖
* 给你一个二维整数数组`ranges`和两个整数`left`和`right`。每个`ranges[i] = [starti, endi]`表示一个从`starti`到`endi`的闭区间。 如果闭区间`[left, right]`内每个整数都被`ranges`中`至少一个`区间覆盖，那么请你返回`true`，否则返回`false`。

## 799. 最大的幻方
* 一个`k x k`的幻方指的是一个`k x k`填满整数的方格阵，且每一行、每一列以及两条对角线的和全部相等 。给你一个`m x n`的整数矩阵`grid`，请你返回矩阵中最大幻方的尺寸

## 800. 最大升序子数组和
* 给你一个正整数组成的数组`nums`，返回`nums`中一个升序子数组的最大可能元素和。 子数组是数组中的一个连续数字序列。

## 801. TinyURL 的加密与解密
* 实现`Codec`类：`Codec()`初始化`Codec`系统对象； `String encode(String longUrl)`返回`longUrl`对应的`TinyURL`；`String decode(String shortUrl)`返回`shortUrl`原本的`URL`。题目数据保证给定的`shortUrl`是由同一个系统对象加密的。

## 802. 质数排列
* 请你帮忙给从`1`到`n`的数设计排列方案，使得所有的质数都应该被放在质数索引，索引从`1`开始；你需要返回可能的方案总数。

## 803. 最低加油次数
* 汽车驶向目的地，目的地位于出发位置东面`target`英里处。 沿途有加油站，每个`station[i]`代表一个加油站，它位于出发位置东面`station[i][0]`英里处，并且有`station[i][1]`升汽油。 假设汽车油箱的容量是无限的，其中最初有`startFuel`升燃料。它每行驶`1`英里就会用掉`1`升汽油。 当汽车到达加油站时，它可能停下来将所有汽油从加油站转移到汽车中。 返回汽车所必要的最低加油次数。如果无法到达目的地，则返回`-1`。

## 804. 解密消息
* 给你字符串`key`和`message`，分别表示一个加密密钥和一段加密消息。解密`message`时使用`key`中`26`个英文小写字母第一次出现的顺序作为替换表中的字母顺序，将替换表与普通英文字母表对齐，形成对照表，按照对照表替换`message`中的每个字母，空格`' '`保持不变。返回解密后的消息。

## 805. 螺旋矩阵 IV
* 给你两个整数：`m`和`n`，表示矩阵的维数。 另给你一个整数链表的头节点`head`。 请你生成一个大小为`m x n`的螺旋矩阵，矩阵包含链表中的所有整数。链表中的整数从矩阵左上角开始、顺时针按螺旋顺序填充。如果还存在剩余的空格，则用`-1`填充。

## 806. 知道秘密的人数
* 在第`1`天，有一个人发现了一个秘密。 给你一个整数`delay`，表示每个人会在发现秘密后的`delay`天之后，每天 给一个新的人 分享 秘密。同时给你一个整数 forget ，表示每个人在发现秘密 forget 天之后会 忘记 这个秘密。一个人 不能 在忘记秘密那一天及之后的日子里分享秘密。 给你一个整数`n`，请你返回在第`n`天结束时，知道秘密的人数。

## 807. 网格图中递增路径的数目
* 给你一个`m x n`的整数网格图`grid`，你可以从一个格子移动到相邻的任意一个格子。请你返回在网格图中从任意格子出发，达到任意格子，且路径中的数字是严格递增的路径数目。

## 808. 下一个更大元素 III
* 给你一个正整数`n`，请你找出符合条件的最小整数，其由重新排列`n`中存在的每位数字组成，并且其值大于`n`。如果不存在这样的正整数或这样的正整数不是`32`位整数，则返回`-1`。

## 809. 最小绝对差
* 给你个整数数组`arr`，其中每个元素都不相同。 请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。

## 810. 仅执行一次字符串交换能否使两个字符串相等
* 给你长度相等的两个字符串`s1`和`s2`。一次字符串交换操作的步骤如下：选出某个字符串中的两个下标，并交换这两个下标所对应的字符。 如果对其中一个字符串执行最多一次字符串交换 就可以使两个字符串相等，返回`true`；否则，返回`false`。

## 811. 找出星型图的中心节点
* 有一个无向的星型图，由`n`个编号从`1`到`n`的节点组成。星型图有一个中心节点，并且恰有`n - 1`条边将中心节点与其他每个节点连接起来。 给你一个二维整数数组`edges`，其中`edges[i] = [ui, vi]`表示在节点 ui 和 vi 之间存在一条边。请你找出并返回`edges`所表示星型图的中心节点。

## 812. 最大平均通过率
* 一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 classes`，其中`classes[i] = [passi, totali]`，表示你提前知道了第`i`个班级总共有`totali`个学生，其中只有`passi`个学生可以通过考试。给你一个整数`extraStudents`，表示额外有`extraStudents`个聪明的学生，他们 一定`能通过任何班级的期末考。你需要给这`extraStudents`个学生每人都安排一个班级，使得所有班级的平均通过率最大。 请你返回在安排这`extraStudents`个学生去对应班级后的最大平均通过率。与标准答案误差范围在`10**-5`以内的结果都会视为正确结果。

## 813. 行星碰撞
* 给定一个整数数组`asteroids`，表示在同一行的行星。 对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。 找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。

## 814. 矩阵中的最长递增路径
* 给定一个`m x n`整数矩阵`matrix`，找出其中最长递增路径的长度。

## 815. 实现一个魔法字典
* 实现`MagicDictionary`类：`MagicDictionary()`初始化对象；`void buildDict(String[] dictionary)`使用字符串数组`dictionary`设定该数据结构，`dictionary`中的字符串互不相同；`bool search(String searchWord)`给定一个字符串`searchWord`，判定能否只将字符串中一个字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。

## 816. 最长的斐波那契子序列的长度
* 给定一个严格递增的正整数数组形成序列`arr`，找到`arr`中最长的斐波那契式的子序列的长度。如果一个不存在，返回`0`。

## 817. Lisp 语法解析
* pass

## 818. 奇数值单元格的数目
* 给你一个`m x n`的矩阵，最开始的时候，每个单元格中的值都是`0`。 另有一个二维索引数组`indices`，`indices[i] = [ri, ci]`指向矩阵中的某个位置，其中`ri`和`ci`分别表示指定的行和列。 对`indices[i]`所指向的每个位置，`ri`行上的所有单元格，加`1`，`ci`列上的所有单元格，加`1`。 给你`m、n`和`indices`。请你在执行完所有`indices`指定的增量操作后，返回矩阵中奇数值单元格的数目。

## 819. 玩筹码
* 有`n`个筹码。第`i`个筹码的位置是`position[i]`。 我们需要把所有筹码移到同一个位置。在一步中，我们可以将第`i`个筹码的位置从`position[i]`改变为:`position[i] + 2`或`position[i] - 2`，此时`cost = 0`；`position[i] + 1`或`position[i] - 1`，此时`cost = 1`。 返回将所有筹码移动到同一位置上所需要的最小代价。

## 820. 摘樱桃
* 一个`N x N`的网格`grid`代表了一块樱桃地，每个格子由以下三种数字的一种来表示：`0`表示这个格子是空的，所以你可以穿过它；`1`表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它；`-1`表示这个格子里有荆棘，挡着你的路。 你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃： 从位置`(0, 0)`出发，最后到达`(N-1, N-1)`，只能向下或向右走； 当到达 `(N-1, N-1)`后，你要继续走，直到返回到`(0, 0)`，只能向上或向左走； 当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的； 如果在`(0, 0)`和`(N-1, N-1)`之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。

## 821. 装满杯子需要的最短总时长
* 现有一台饮水机，可以制备冷水、温水和热水。每秒钟可以装满`2`杯不同类型的水或者`1`杯任意类型的水。 给你一个长度为`3`的整数数组`amount`，其中`amount[0]`、`amount[1]`、`amount[2]`分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的最少秒数。

## 822. 无限集中的最小数字
* 实现`SmallestInfiniteSet`类：`SmallestInfiniteSet()`初始化`SmallestInfiniteSet`对象以包含所有正整数；`int popSmallest()`移除并返回该无限集中的最小整数；`void addBack(int num)`如果正整数`num`不存在于无限集中，则将一个`num`添加到该无限集中。

## 823. 移动片段得到字符串
* 给你两个字符串`start`和`target`，长度均为`n`。每个字符串由字符`'L'`、`'R'`、`'_'`组成，其中： `'L'`只有在其左侧直接存在一个空位时才能向左移动，`'R'`只有在其右侧直接存在一个空位时才能向右移动， 字符`'_'`表示可以被`'L'`或`'R'`片段占据的空位。 如果在移动字符串`start`中的片段任意次之后可以得到字符串`target`，返回`true`；否则，返回`false`。

## 824. 在LR字符串中交换相邻字符
* 在一个由`'L'`，`'R'`和`'X'`三个字符组成的字符串中进行移动操作。一次移动操作指用一个`LX`替换一个`XL`，或者用一个`XR`替换一个`RX`。现给定起始字符串`start`和结束字符串`end`，请编写代码，判断是否存在一系列移动操作使得`start`可以转换成`end`

## 825. 四叉树交集
* 给你两个四叉树，`quadTree1`和`quadTree2`。其中`quadTree1`表示一个`n * n`二进制矩阵，而`quadTree2`表示另一个`n * n`二进制矩阵。 请你返回一个表示`n * n`二进制矩阵的四叉树，它是`quadTree1`和`quadTree2`所表示的两个二进制矩阵进行 按位逻辑或运算 的结果。

## 826. 前缀和后缀搜索
* 实现`WordFilter`类：`WordFilter(string[] words)`使用词典中的单词`words`初始化对象；`f(string pref, string suff)`返回词典中具有前缀`prefix`和后缀`suff`的单词的下标。如果存在不止一个满足要求的下标，返回其中最大的下标，如果不存在这样的单词，返回`-1` 

## 827. 滑动窗口的平均值
* 实现`MovingAverage`类：`MovingAverage(int size)`用窗口大小`size`初始化对象；`double next(int val)`成员函数`next`每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后`size`个值的移动平均值，即滑动窗口里所有数字的平均值。

## 828. 计算布尔二叉树的值
* 给你一棵完全二叉树的根，这棵树有以下特征： 叶子节点值`0`表示`False`，`1`表示`True`； 非叶子节点值`2`表示逻辑或`OR`，`3`表示逻辑与`AND`。 计算一个节点的值方式如下： 如果节点是个叶子节点，那么节点的值为它本身； 否则，计算两个孩子的节点值，然后将该节点的运算符对两个孩子值进行运算。 返回根节点`root`的布尔运算值。

## 829. 坐上公交的最晚时间
* 给你一个长度为`n`的整数数组`buses`，其中`buses[i]`表示第`i`辆公交车的出发时间。同时给你一个长度为`m`的整数数组`passengers`，其中`passengers[j]`表示第`j`位乘客的到达时间。所有公交车出发的时间互不相同，所有乘客到达的时间也互不相同。 给你一个整数`capacity`，表示每辆公交车最多能容纳的乘客数目。 每位乘客都会搭乘下一辆有座位的公交车。如果你在`y`时刻到达，公交在`x`时刻出发，满足`y <= x`且公交没有满，那么你可以搭乘这一辆公交。最早到达的乘客优先上车。 返回你可以搭乘公交车的最晚到达公交站时间。你不能跟别的乘客同时刻到达。

## 830. 最小差值平方和
* 给你两个整数数组`nums1`和`nums2`，长度为`n`。 每次修改数组，可以将任意元素`+1`或者`-1`。 请你返回修改数组`nums1`至多`k1`次且修改数组`nums2`至多`k2`次后的最小差值平方和。

## 831. 数组能形成多少数对
* 给你一个整数数组`nums`。在一步操作中，从`nums`选出两个相等的整数，移除这两个整数。 在`nums`上多次执行此操作直到无法继续执行。 返回一个长度为`2`的整数数组`answer`作为答案，其中`answer[0]`是操作次数，`answer[1]`是对`nums`剩下的整数数目。

## 832. 数位和相等数对的最大和
* 给你一个数组`nums`，数组中的元素都是正整数。请你选出两个下标`i`和`j`，且`nums[i]`的数位和与`nums[j]`的数位和相等。 请你找出所有满足条件的下标`i`和`j`，找出并返回`nums[i] + nums[j]`可以得到的最大值。

## 833. 裁剪数字后查询第 K 小的数字
* 给你一个字符串数组`nums`，其中每个字符串长度相等且只包含数字。 再给你一个二维整数数组`queries`，其中`queries[i] = [ki, trimi]`。对于每个`queries[i]`， 将`nums`中每个数字裁剪到剩下最右边`trimi`个数位，在裁剪过后的数字中，找到`nums`中第`ki`小数字对应的下标。(如果两个裁剪后数字一样大，那么下标更小的数字视为更小的数字)。请你返回一个长度与`queries`相等的数组`answer`，其中`answer[i]`是第`i`次查询的结果。

## 834. 使数组可以被整除的最少删除次数
* 给你两个正整数数组`nums`和`numsDivide`。你可以从`nums`中删除任意数目的元素。 请你返回使`nums`中最小元素可以整除`numsDivide`中所有元素的最少删除次数。如果无法得到这样的元素，返回`-1`。

## 835. 数组嵌套
* 长度为`N`的数组`A`，包含`0`到`N - 1`的所有整数。找到最大的集合`S`并返回其大小，对于`S`，假设选择索引为`i`的元素`A[i]`为`S`的第一个元素，`S`的下一个元素应该是`A[A[i]]`，之后是`A[A[A[i]]]`... 以此类推，不断添加直到出现重复的元素。

## 836. 二叉树剪枝
* 给你二叉树的根结点`root`，此外树的每个结点的值要么是`0`，要么是`1`。 返回移除了所有不包含`1`的子树的原二叉树。

## 837. 隔离病毒
* 假设世界由`m x n`的二维矩阵`isInfected`组成，`isInfected[i][j] == 0`表示该区域未感染病毒，而`isInfected[i][j] == 1`表示该区域已感染病毒。可以在任意相邻单元之间的共享边界上安装一个防火墙。 每天晚上，病毒会从被感染区域向相邻未感染区域扩散，除非被防火墙隔离。每天你只能安装一系列防火墙来隔离其中一个被病毒感染的区，且该感染区域对未感染区域的威胁最大且保证唯一。 你需要努力使得最后有部分区域不被病毒感染，如果可以成功，那么返回需要使用的防火墙个数; 如果无法实现，则返回在世界被病毒全部感染时已安装的防火墙个数。

## 838. 最好的扑克手牌
* 给你一个整数数组`ranks`和一个字符数组`suit`。你有`5`张扑克牌，第`i`张牌大小为`ranks[i]`，花色为`suits[i]`。 下述是从好到坏你可能持有的手牌类型：`"Flush"`：同花，五张相同花色的扑克牌；`"Three of a Kind"`：三条，有 3 张大小相同的扑克牌；`"Pair"`：对子，两张大小一样的扑克牌；`"High Card"`：高牌，五张大小互不相同的扑克牌。 请你返回一个字符串，表示给定的`5`张牌中，你能组成的最好手牌类型 。

## 839. 全0子数组的数目
* 给你一个整数数组`nums`，返回全部为`0`的子数组数目。 子数组是一个数组中一段连续非空元素组成的序列。

## 840. 设计数字容器系统
* 请你实现一个`NumberContainers`类：`NumberContainers()`初始化数字容器系统；`void change(int index, int number)`在下标`index`处填入`number`，如果该下标`index`处已经有数字了，那么用`number`替换该数字；`int find(int number)`返回给定数字`number`在系统中的最小下标，如果系统中没有`number`，那么返回`-1`。

## 841. 不可能得到的最短骰子序列
* 给你一个长度为`n`的整数数组`rolls`和一个整数`k`。你扔一个`k`面的骰子 n 次，骰子的每个面分别是`1`到`k`，其中第`i`次扔得到的数字是`rolls[i]`。请你返回无法从`rolls`中得到的最短骰子子序列的长度。

## 842. 重建序列
* 给定一个长度为`n`的整数数组`nums`，其中`nums`是范围为`[1，n]`的整数的排列。还提供了一个二维整数数组`sequences`，其中`sequences[i]`是`nums`的子序列。 检查`nums`是否是唯一的最短超序列。**最短超序列**是长度最短的序列，并且所有序列`sequences[i]`都是它的子序列。子序列 是一个可以通过从另一个序列中删除一些元素或不删除任何元素，而不改变其余元素的顺序的序列。

## 843. 公交站间的距离
* 环形公交路线上有`n`个站，按次序从`0`到`n - 1`进行编号。我们已知每一对相邻公交站之间的距离，`distance[i]`表示编号为`i`的车站和编号为`(i + 1) % n`的车站之间的距离。 环线上的公交车都可以按顺时针和逆时针的方向行驶。 返回乘客从出发点`start`到目的地`destination`之间的最短距离。

## 844. 第一个出现两次的字母
* 给你一个由小写英文字母组成的字符串`s`，请你找出并返回第一个出现两次的字母。

## 845. 相等行列对
* 给你一个大小为`n x n`的整数矩阵`grid`，返回满足`Ri`行和`Cj`列相等的行列对`(Ri, Cj)`的数目。 如果行和列以相同的顺序包含相同的元素，则认为二者是相等的

## 846. 设计食物评分系统
* 实现`FoodRatings`类：`FoodRatings(String[] foods, String[] cuisines, int[] ratings)`初始化系统。食物由`foods`、`cuisines`和`ratings`描述，长度均为`n`；`foods[i]`是第`i`种食物的名字；`cuisines[i]`是第`i`种食物的烹饪方式；`ratings[i]`是第`i`种食物的最初评分；`void changeRating(String food, int newRating)`修改名字为`food`的食物的评分；`String highestRated(String cuisine)`返回指定烹饪方式`cuisine`下评分最高的食物的名字，如果存在并列，返回字典序较小的名字。

## 847. 优质数对的数目
* 给你一个正整数数组`nums`和一个正整数`k`。 在数组`nums`中的`num1`和`num2`如果满足`num1 OR num2`和`num1 AND num2`的二进制表示中值为 1 的位数之和大于等于 k ，则数对`(num1, num2)`是优质数对。 返回不同优质数对的数目。

## 848. 完全二叉树插入器
* 实现`CBTInserter`类:`CBTInserter(TreeNode root)`使用头节点为`root`的给定树初始化该数据结构；`CBTInserter.insert(int v)` 向树中插入一个值为`Node.val == val`的新节点`TreeNode`，使树保持完全二叉树的状态，并返回插入节点`TreeNode`的父节点的值；`CBTInserter.get_root()`将返回树的头节点。

## 849. 数组序号转换
* 给你一个整数数组`arr`，请你将数组中的每个元素替换为它们排序后的序号。 序号编号的规则如下： 序号从`1`开始编号； 一个元素越大，那么序号越大；如果两个元素相等，那么它们的序号相同。

## 850. 分数加减运算
* 给定一个表示分数加减运算的字符串`expression`，你需要返回一个字符串形式的计算结果。这个结果应该是不可约分的分数，即最简分数。如果最终结果是一个整数，需要将它转换成分数形式，其分母为`1`。

## 851. 设计跳表
* pass

## 852. 有效的正方形
* 给定空间中四个点的坐标`p1`,`p2`,`p3`和`p4`，如果这四个点构成一个正方形，则返回`true`。

## 853. 使数组中所有元素都等于零
* 给你一个非负整数数组`nums`。在一步操作中，你必须： 选出一个正整数`x`，`x`需要小于或等于`nums`中最小的非零元素。`nums`中的每个正整数都减去`x`。 返回使`nums`中所有元素都等于`0`需要的最少操作数。

## 854. 分组的最大数量
* 给你一个正整数数组`grades`，表示大学中一些学生的成绩。你打算将 所有 学生分为一些 有序 的非空分组，其中分组间的顺序满足以下全部条件： 第`i`个分组中的学生总成绩小于第`(i + 1)`个分组中的学生总成绩，对所有组均成立； 第`i`个分组中的学生总数小于第`(i + 1)`个分组中的学生总数，对所有组均成立。 返回可以形成的最大组数。

## 855. 找到离给定两个节点最近的节点
* 给你一个`n`个节点的有向图，节点编号为`0`到`n - 1`，每个节点至多有一条出边。 有向图用大小为`n`下标从`0`开始的数组`edges`表示，表示节点`i`有一条有向边指向`edges[i]`。如果节点`i`没有出边，那么`edges[i] == -1`。 同时给你两个节点`node1`和`node2`。 请你返回一个从`node1`和`node2`都能到达节点的编号，使节点`node1`和节点`node2`到这个节点的距离 较大值最小化。如果有多个答案，请返回最小的节点编号。如果答案不存在，返回`-1`。

## 856. 图中的最长环
* 给你一个`n`个节点的有向图，节点编号为`0`到`n - 1`，其中每个节点至多有一条出边。 图用一个大小为`n`下标从`0`开始的数组`edges`表示，节点`i`到节点`edges[i]`之间有一条有向边。如果节点`i`没有出边，那么`edges[i] == -1`。 请你返回图中的最长环，如果没有任何环，请返回`-1`。

## 857. 设计循环队列
* 实现`MyCircularQueue`类：`MyCircularQueue(k)`: 构造器，设置队列长度为`k`；`Front`: 从队首获取元素。如果队列为空，返回`-1`；`Rear`: 获取队尾元素。如果队列为空，返回`-1`；`enQueue(value)`: 向循环队列插入一个元素，如果成功插入则返回真；`deQueue()`: 从循环队列中删除一个元素，如果成功删除则返回真；`isEmpty()`: 检查循环队列是否为空；`isFull()`: 检查循环队列是否已满。

## 858. 生成每种字符都是奇数个的字符串
* 给你一个整数`n`，请你返回一个含`n`个字符的字符串，其中每种字符在该字符串中都恰好出现奇数次

## 859. 按公因数计算最大组件大小
* 给定一个由不同正整数的组成的非空数组`nums`，考虑下面的图： 有`nums.length`个节点，按从`nums[0]`到`nums[nums.length - 1]`标记； 只有当`nums[i]`和`nums[j]`共用一个大于`1`的公因数时，`nums[i]`和`nums[j]`之间才有一条边。 返回图中最大连通组件的大小 。

## 860. 设置交集大小至少为2
* 一个整数区间`[a, b]`代表着从`a`到`b`的所有连续整数，包括`a`和`b`。 给你一组整数区间`intervals`，请找到一个最小的集合`S`，使得`S`里的元素与区间`intervals`中的每一个整数区间都至少有`2`个元素相交。 输出这个最小集合`S`的大小。

## 861. 有序队列
* 给定一个字符串`s`和一个整数`k`。你可以从`s`的前`k`个字母中选择一个，并把它加到字符串的末尾。返回在应用上述步骤的任意数量的移动后，字典上最小的字符串。

## 862. 非递增顺序的最小子序列
* 给你一个数组`nums`，请你从中抽取一个子序列，满足该子序列的元素之和严格大于未包含在该子序列中的各元素之和。 如果存在多个解决方案，只需返回长度最小的子序列。如果仍然有多个解决方案，则返回元素之和最大的子序列。

## 863. 在二叉树中增加一行
* 给定一个二叉树的根`root`和两个整数`val`和`depth`，在给定的深度`depth`处添加一个值为`val`的节点行。 加法规则如下:根节点`root`位于深度`1`。 给定整数`depth`，对于深度为`depth - 1`的每个非空树节点`cur`，创建两个值为`val`的树节点作为`cur`的左子树根和右子树根；`cur`原来的左子树应该是新的左子树根的左子树，原来的右子树应该是新的右子树根的右子树； 如果`depth == 1`，那么创建一个树节点，值`val`作为整个原始树的新根，而原始树就是新根的左子树；

## 864. 合并相似的物品
* 给你两个二维整数数组`items1`和`items2`，表示两个物品集合。每个数组`items`中`items[i] = [valuei, weighti]`其中`valuei`表示第`i`件物品的价值，`weighti`表示第`i`件物品的重量。 请你返回一个二维数组`ret`，其中`ret[i] = [valuei, weighti]`，`weighti`是所有价值为`valuei`物品的重量之和。`ret`应该按价值升序排序后返回。

## 865. 统计坏数对的数目
* 给你一个整数数组`nums`。如果`i < j`且`j - i != nums[j] - nums[i]`，那么我们称`(i, j)`是一个坏数对。 请你返回`nums`中坏数对的总数目。

## 866. 任务调度器 II
* 给你一个正整数数组`tasks`，表示需要按顺序完成的任务，其中`tasks[i]`表示第`i`件任务的类型。 同时给你一个正整数`space`，表示一个任务完成后，另一个相同类型任务完成前需要间隔的最少天数。 请你返回完成所有任务所需的 最少 天数。

## 867. 将数组排序的最少替换次数
* 给你一个整数数组`nums`。每次操作中，你可以将数组中任何一个元素替换为任意两个和为该元素的数字。请你执行上述操作，将数组变成元素按非递减顺序排列的数组，并返回所需的最少操作次数。

## 868. 数组中的字符串匹配
* 给你一个字符串数组`words`，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回`words`中是其他单词的子字符串的所有单词。 如果你可以删除`words[j]`最左侧和/或最右侧的若干字符得到`words[i]`，那么字符串`words[i]`就是`words[j]`的一个子字符串。

## 869. 算术三元组的数目
* 给你一个严格递增的整数数组`nums`和一个正整数`diff`。如果满足下述全部条件，则三元组`(i, j, k)`就是一个算术三元组 ：`i < j < k`，`nums[j] - nums[i] == diff`，`nums[k] - nums[j] == diff`。 返回不同算术三元组的数目。

## 870. 受限条件下可到达节点的数目
* 现有一棵由`n`个节点组成的无向树，节点编号从`0`到`n - 1`。 给你一个二维整数数组`edges`，其中`edges[i] = [ai, bi]`表示树中节点`ai`和`bi`之间存在一条边。另给你一个整数数组`restricted`表示受限节点。 在不访问受限节点的前提下，返回你可以从节点`0`到达的最多节点数目。

## 871. 检查数组是否存在有效划分
* 给你一个整数数组`nums`，你必须将数组划分为一个或多个连续子数组。 如果获得的这些子数组中每个都能满足下述条件之一，则可以称其为数组的一种有效划分： 子数组由`2`个相等元素组成，例如，子数组`[2,2]`； 子数组由`3`个相等元素组成，例如，子数组`[4,4,4]`； 子数组由`3`个连续递增元素组成，并且相邻元素之间的差值为`1`。如果数组至少存在一种有效划分，返回`true`，否则，返回`false`。

## 872. 最长理想子序列
* 给你一个由小写字母组成的字符串`s`，和一个整数`k`。如果满足下述条件，则可以将字符串`t`视作是理想字符串 ：`t`是字符串`s`的一个子序列；`t`中每两个相邻字母在字母表中位次的绝对差值小于或等于`k`。 返回最长理想字符串的长度。 字符串的子序列同样是一个字符串，并且子序列还满足：可以经由其他字符串删除某些字符（也可以不删除）但不改变剩余字符的顺序得到。

## 873. 函数的独占时间
* 给你一个由日志组成的列表`logs`，其中`logs[i]`表示第`i`条日志消息，该消息是一个按`"{function_id}:{"start" | "end"}:{timestamp}"`进行格式化的字符串。`start`代表`function_id`从`timestamp`起始开始执行，`end`代表`function_id`从`timestamp`结束停止执行 以数组形式返回每个函数的独占时间 ，其中第`i`个下标对应的值表示标识符`i`的函数的独占时间。

## 874. 逐步求和得到正数的最小值
* 给你一个整数数组`nums`。你可以选定任意的正数`startValue`作为初始值。 你需要从左到右遍历`nums`数组，并将`startValue`依次累加上`nums`数组中的值。 请你在确保累加和始终大于等于`1`的前提下，选出一个最小的正数作为`startValue`。

## 875. 重新格式化字符串
* 给你一个混合了数字和字母的字符串`s`，其中的字母均为小写英文字母。请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个空字符串。

## 876. 特殊的二进制序列
* 特殊的二进制序列是具有`0`的数量与`1`的数量相等、 二进制序列的每一个前缀码中`1`的数量要大于等于`0`的数量两个性质。 两个子串为连续的定义为：当且仅当第一个子串的最后一个字符恰好为第二个子串的第一个字符的前一个字符。 给定一个特殊的二进制序列`S`，以字符串形式表示。定义一个操作为首先选择`S`的两个连续且非空的特殊的子串，然后将它们交换。 在任意次数的操作之后，返回交换后的字符串按照字典序排列的最大的结果

## 877. 用户分组
* 有`n`个人被分成数量未知的组。每个人都被标记为一个从`0`到`n - 1`的唯一`ID`。 给定一个整数数组`groupSizes`，其中`groupSizes[i]`是第`i`个人所在的组的大小。 返回一个组列表，使每个人`i`都在一个大小为`groupSizes[i]`的组中。

## 878. 买卖股票的最佳时机 III
* 给定一个数组，它的第`i`个元素是一支给定的股票在第`i`天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成两笔交易。 注意：你必须在再次购买前出售掉之前的股票。

## 879. 买卖股票的最佳时机 IV
* 给定一个整数数组`prices`，它的第`i`个元素`prices[i]`是一支给定的股票在第`i`天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成`k`笔交易。注意：你必须在再次购买前出售掉之前的股票。

## 880. 分割字符串的最大得分
* 给你一个由若干`0`和`1`组成的字符串`s`，请你计算并返回将该字符串分割成两个非空子字符串所能获得的最大得分。**分割字符串的得分**为左子字符串中`0`的数量加上 右 子字符串中`1`的数量。

## 881. 所有可能的真二叉树
* 给你一个整数 n ，请你找出所有可能含`n`个节点的真二叉树(满二叉树)，并以列表形式返回。

## 882. 最多能完成排序的块 II
* `arr`是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。 我们最多能将数组分成多少块？

## 883. 矩阵中的局部最大值
* 给你一个大小为`n x n`的整数矩阵`grid`。 生成一个大小为`(n - 2) x (n - 2)`的整数矩阵`maxLocal`，并满足：`maxLocal[i][j]`等于`grid`中以`i + 1`行和`j + 1`列为中心的`3 x 3`矩阵中的最大值。

## 884. 边积分最高的节点
* 给你一个有向图，图中有`n`个节点，节点编号从`0`到`n - 1`，其中每个节点都恰有一条出边。 图由一个长度为`n`的整数数组`edges`表示，其中`edges[i]`表示存在一条从节点`i`到节点`edges[i]`的有向边。 节点`i`的边积分为所有指向节点`i`的边的出发节点的编号总和。 返回边积分最高的节点。如果多个节点的 边积分相同，返回编号最小的那个。

## 885. 根据模式串构造最小数字
* 给你下标长度为`n`的字符串`pattern`，它包含只两种字符`'I'``'D'`。 你需要构造一个长度为`n + 1`的字符串，且它要满足以下条件：`num`包含数字`'1'`到`'9'`，其中每个数字至多使用一次； 如果`pattern[i] == 'I'`，那么`num[i] < num[i + 1]`； 如果`pattern[i] == 'D'`，那么`num[i] > num[i + 1]`。 请你返回满足上述条件字典序最小的字符串`num`。

## 886. 统计特殊整数
* 如果一个正整数每一个数位都是互不相同的，我们称它是特殊整数。 给你一个正整数`n`，请你返回区间`[1, n]`之间特殊整数的数目。

## 887. 设计有序流
* 实现`OrderedStream`类：`OrderedStream(int n)`构造一个能接收`n`个值的流，并将当前指针`ptr`设为`1`；`String[] insert(int id, String value)`向流中存储新的`(id, value)`对，存储后如果流存储有`id = ptr`的`(id, value)`对，则找出从`id = ptr`开始的最长`id`连续递增序列 ，并按顺序返回与这些`id`关联的值的列表，然后将`ptr`更新为最后那个`id + 1`， 如果流存储没有`id = ptr`的`(id, value)`对，返回一个空列表。

## 888. 最大二叉树
* 给定一个不重复的整数数组`nums`。最大二叉树可以用下面的算法从`nums`递归地构建:创建一个根节点，其值为`nums`中的最大值，递归地在最大值左边的子数组前缀上构建左子树，递归地在最大值右边的子数组后缀上构建右子树。 返回`nums`构建的最大二叉树。

## 889. 在既定时间做作业的学生人数
* 给你两个整数数组`startTime`和`endTime`，并指定一个整数`queryTime`作为查询时间。 已知，第`i`名学生在`startTime[i]`时开始写作业并于`endTime[i]`时完成作业。 请返回在查询时间`queryTime`时正在做作业的学生人数。形式上，返回能够使`queryTime`处于区间`[startTime[i], endTime[i]]`的学生人数。

## 890. 最大相等频率
* 给你一个正整数数组`nums`，请你帮忙从该数组中找出能满足下面要求的最长前缀的长度。要求为从前缀中删除一个元素后，剩下每个数字的出现次数都相同。

## 891. 得到 K 个黑块的最少涂色次数
* 给你一个长度为`n`的字符串`blocks`，`blocks[i]`要么是`'W'`要么是`'B'`，表示第`i`块的颜色。 给你一个整数`k`，表示想要连续`'B'`的数目。 每一次操作中，你可以将一个`'W'`改为`'B'`。 请你返回至少出现一次连续`k`个`'B'`的最少操作次数。

## 892. 二进制字符串重新安排顺序需要的时间
* 给你一个二进制字符串`s`。在一秒之中，所有子字符串`"01"`同时 被替换成`"10"`。这个过程持续进行到没有`"01"`存在。 请你返回完成这个过程所需要的秒数。

## 893. 字母移位 II
* 给你一个小写英文字母组成的字符串`s`和一个二维整数数组`shifts`，其中`shifts[i] = [starti, endi, directioni]`。对于每个`i`，将`s`中下标`[starti,endi]`的所有字符都进行移位运算，如果`directioni = 1`将字符向后移位，如果`directioni = 0`将字符向前移位。 将一个字符向后移位的意思是将这个字符用字母表中下一个字母替换，将一个字符 向前 移位的意思是将这个字符用字母表中前一个字母替换，字母表视为环绕的。 请你返回对`s`进行所有移位操作以后得到的最终字符串。

## 894. 删除操作后的最大子段和
* 给你两个整数数组`nums`和`removeQueries`，两者长度都为`n`。对于第`i`个查询，`nums`中位于下标`removeQueries[i]`处的元素被删除，将`nums`分割成更小的子段。 一个子段是`nums`中连续正整数形成的序列。子段和是子段中所有元素的和。 请你返回一个长度为`n`的整数数组`answer`，其中`answer[i]`是第`i`次删除操作以后的最大子段和。 注意：一个下标至多只会被删除一次。

## 895. 检查单词是否为句中其他单词的前缀
* 给你一个字符串`sentence`作为句子并指定检索词为`searchWord`，其中句子由若干用单个空格分隔的单词组成。请你检查检索词 searchWord 是否为句子`sentence`中任意单词的前缀。 如果`searchWord`是某一个单词的前缀，则返回句子`sentence`中该单词是句子中第几个词。如果`searchWord`是多个单词的前缀，则返回匹配的第一个单词是句子中第几个词。如果`searchWord`不是任何单词的前缀，则返回`-1`。

## 896. 赢得比赛需要的最少训练时长
* 你正在参加一场比赛，给你两个正整数`initialEnergy`和`initialExperience`分别表示你的初始精力和初始经验。 另给你两个整数数组`energy`和`experience`，长度均为`n`。 你将会依次对上`n`个对手。第`i`个对手的精力和经验分别用`energy[i]`和`experience[i]`表示。当你对上对手时，需要在经验和精力上都严格超过对手才能击败他们。 击败第`i`个对手会使你的经验增加`experience[i]`，但会将你的精力减少`energy[i]`。 在开始比赛前，你可以训练几个小时。每训练一个小时，你可以选择将增加经验增加`1`或者将精力增加`1`。 返回击败全部`n`个对手需要训练的最少小时数目。

## 897. 最大回文数字
* 给你一个仅由数字组成的字符`num`。 请你找出能够使用`num`中数字形成的最大回文整数，并以字符串形式返回。该整数不含前导零。你无需使用`num`中的所有数字，但你必须使用至少一个数字。 数字可以重新排序。

## 898. 感染二叉树需要的总时间
* 给你一棵二叉树的根节点`root`，二叉树中节点的值互不相同。另给你一个整数`start`。在第`0`分钟，感染 将会从值为`start`的节点开始爆发。 每分钟，感染节点都会使得相邻节点感染。返回感染整棵树需要的分钟数。

## 899. 通过翻转子数组使两个数组相等
* 给你两个长度相同的整数数组`target`和`arr`。每一步中，你可以选择`arr`的任意 非空子数组并将它翻转。你可以执行此过程任意次。 如果你能让`arr`变得与`target`相同，返回`True`；否则，返回`False`。

## 900. 变为棋盘
* 一个`n x n`的二维网络`board`仅由`0`和`1`组成。每次移动，你能任意交换两列或是两行的位置。 返回将这个矩阵变为“棋盘”所需的最小移动次数。如果不存在可行的变换，输出`-1`。 “棋盘” 是指任意一格的上下左右四个方向的值均与本身不同的矩阵。

## 901. 和有限的最长子序列
* 给你一个长度为`n`的整数数组`nums`，和一个长度为`m`的整数数组`queries`。 返回一个长度为`m`的数组`answer`，其中`answer[i]`是`nums`中元素之和小于等于`queries[i]`的子序列的最大长度。 子序列是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。 

## 902. 从字符串中移除星号
* 给你一个包含若干星号`"*"`的字符串`s`。 在一步操作中，你可以选中`s`中的一个星号， 移除星号左侧最近的那个非星号字符，并移除该星号自身，返回移除所有星号之后的字符串。

## 903. 收集垃圾的最少总时间
* 给你一个字符串数组`garbage`，其中`garbage[i]`表示第`i`个房子的垃圾集合。`garbage[i]`只包含字符`'M'`，`'P'`和`'G'`，但可能包含多个相同字符，每个字符分别表示一单位的金属、纸和玻璃。垃圾车收拾`1`单位的任何一种垃圾都需要花费`1`分钟。 同时给你一个整数数组`travel`，其中`travel[i]`是垃圾车从房子`i`行驶到房子`i + 1`需要的分钟数。 城市里总共有三辆垃圾车，分别收拾三种垃圾。每辆垃圾车都从房子`0`出发，按顺序到达每一栋房子。但它们不是必须到达所有的房子。 任何时刻只有一辆垃圾车处在使用状态。当一辆垃圾车在行驶或者收拾垃圾的时候，另外两辆车不能做任何事情。 请你返回收拾完所有垃圾需要花费的最少总分钟数。

## 904. 给定条件下构造矩阵
* 给你一个正整数`k`，同时给你一个大小为`n`的二维整数数组`rowConditions`，其中`rowConditions[i] = [abovei, belowi]`和一个大小为`m`的二维整数数组`colConditions`，其中`colConditions[i] = [lefti, righti]`。 两个数组里的整数都是`1`到`k`之间的数字。 你需要构造一个`k x k`的矩阵，`1`到`k`每个数字需要恰好出现一次。剩余的数字都是`0`。 矩阵还需要满足以下条件： 对于所有`0`到`n - 1`之间的下标`i`，数字`abovei`所在的行必须在数字`belowi`所在行的上面； 对于所有`0`到`m - 1`之间的下标`i`，数字`lefti`所在的列必须在数字`righti`所在列的左边。 返回满足上述要求的任意矩阵。如果不存在答案，返回一个空的矩阵。

## 905. 阶乘函数后 K 个零
* `f(x)`是`x!`末尾是`0`的数量。给定`k`，找出返回能满足`f(x) = k`的非负整数`x`的数量。

## 906. 重新排列数组
* 给你一个数组`nums`，数组中有`2n`个元素，按`[x1,x2,...,xn,y1,y2,...,yn]`的格式排列。 请你将数组按`[x1,y1,x2,y2,...,xn,yn]`格式重新排列，返回重排后的数组。

## 907. 最大二叉树 II
* 最大树定义：一棵树，其中每个节点的值都大于其子树中的任何其他值。 给你最大树的根节点`root`和一个整数`val`。 给定的树是利用`Construct(a)`例程从列表`a`递归地构建的： 如果`a`为空，返回`null`； 否则，令`a[i]`作为`a`的最大元素。创建一个值为`a[i]`的根节点`root`；`root`的左子树将被构建为`Construct([a[0], a[1], ..., a[i - 1]])`；`root`的右子树将被构建为`Construct([a[i + 1], a[i + 2], ..., a[a.length - 1]])`；返回`root`。 假设`b`是`a`的副本，并在末尾附加值`val`。题目数据保证`b`中的值互不相同。 返回`Construct(b)`。

## 908. 验证栈序列
* 给定`pushed`和`popped`两个序列，每个序列中的值都不重复，只有当它们可能是在最初空栈上进行的推入`push`和弹出`pop`操作序列的结果时，返回`true`；否则，返回`false`。

## 909. 最长同值路径
* 给定一个二叉树的`root`，返回最长的路径的长度 ，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。 两个节点之间的路径长度由它们之间的边数表示。

## 910. 商品折扣后的最终价格
* 给你一个数组`prices`，其中`prices[i]`是商店里第`i`件商品的价格。 商店里正在进行促销活动，如果你要买第`i`件商品，那么你可以得到与`prices[j]`相等的折扣，其中`j`是满足`j > i`且`prices[j] <= prices[i]`的最小下标，如果没有满足条件的`j`，你将没有任何折扣。 请你返回一个数组，数组中第`i`个元素是折扣后你购买商品`i`最终需要支付的价格。

## 911. 最长数对链
* 给出`n`个数对。在每一个数对中，第一个数字总是比第二个数字小。 现在，我们定义一种跟随关系，当且仅当`b < c`时，数对`(c, d)`才可以跟在`(a, b)`后面。我们用这种形式来构造一个数对链。 给定一个数对集合，找出能够形成的最长数对链的长度。

## 912. 二进制矩阵中的特殊位置
* 给你一个大小为`rows x cols`的矩阵`mat`，其中`mat[i][j]`是`0`或`1`，请返回 矩阵`mat`中特殊位置的数目。特殊位置定义：如果`mat[i][j] == 1`并且第`i`行和第`j`列中的所有其他元素均为`0`，则位置`(i, j)`被称为特殊位置。

## 913. 寻找重复的子树
* 给定一棵二叉树`root`，返回所有重复的子树。 对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。 如果两棵树具有相同的结构和相同的结点值，则它们是重复的。

## 914. 滑动窗口最大值
* 给你一个整数数组`nums`，有一个大小为`k`的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的`k`个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。

## 915. 和相等的子数组
* 给你一个整数数组`nums`，判断是否存在两个长度为`2`的子数组且它们的和相等。注意，这两个子数组起始位置的下标必须不相同。 如果这样的子数组存在，请返回`true`，否则返回`false`。

## 916. 严格回文的数字
* 如果一个整数`n`在`b`进制下（`b`为`2`到`n - 2`之间的所有整数）对应的字符串全部都是回文的，那么我们称这个数`n`是严格回文的。 给你一个整数`n`，如果`n`是严格回文的，请返回`true`，否则返回`false`。

## 917. 被列覆盖的最多行数
* 给你一个`m x n`二进制矩阵`mat`和一个整数`cols`，表示你需要选出的列数。 如果一行中，所有的`1`都被你选中的列所覆盖，那么我们称这一行被覆盖了。 请你返回在选择`cols`列的情况下，被覆盖的行数最大为多少。

## 918. 预算内的最多机器人数目
* 你有`n`个机器人，给你两个整数数组`chargeTimes`和`runningCosts`，两者长度都为`n`。第`i`个机器人充电时间为`chargeTimes[i]`单位时间，花费`runningCosts[i]`单位时间运行。再给你一个整数`budget`。 运行`k`个机器人总开销是`max(chargeTimes) + k * sum(runningCosts)`，其中`max(chargeTimes)`是这`k`个机器人中最大充电时间，`sum(runningCosts)`是这`k`个机器人的运行时间之和。 请你返回在不超过`budget`的前提下，你最多可以连续运行的机器人数目为多少。

## 919. 检查相同字母间的距离
* 给你一个字符串`s`，该字符串仅由小写英文字母组成，`s`中的每个字母都恰好出现两次。另给你一个长度为`26`的的整数数组`distance`。字母表中的每个字母按从`0`到`25`依次编号。在一个匀整字符串中，第`i`个字母的两次出现之间的字母数量是`distance[i]`。如果第`i`个字母没有在`s`中出现，那么`distance[i]`可以忽略。如果`s`是一个匀整字符串，返回`true`；否则，返回`false`。

## 920. 恰好移动 k 步到达某一位置的方法数目
* 给你两个正整数`startPos`和`endPos`。最初，你站在无限数轴上位置`startPos`处。在一步移动中，你可以向左或者向右移动一个位置。 给你一个正整数`k`，返回从`startPos`出发、恰好移动`k`步并到达`endPos`的不同方法数目。

## 921. 最长优雅子数组 
* 给你一个由正整数组成的数组`nums`。 如果`nums`的子数组中位于不同位置的每对元素按位与运算的结果等于`0`，则称该子数组为优雅子数组。 返回最长的优雅子数组的长度。 子数组是数组中的一个连续部分。 注意：长度为`1`的子数组始终视作优雅子数组。

## 922. 把二叉搜索树转换为累加树
* 给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树，使每个节点`node`的新值等于原树中大于或等于`node.val`的值之和。

## 923. 前 n 个数字二进制中 1 的个数
* 给定一个非负整数`n`，请计算`0`到`n`之间的每个数字的二进制表示中`1`的个数，并输出一个数组。

## 924. 二进制中1的个数
* 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为`'1'`的个数

## 925. 二叉树最大宽度
* 给你一棵二叉树的根节点`root`，返回树的最大宽度。每一层的宽度被定义为该层最左和最右的非空节点之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的`null`节点，这些`null`节点也计入长度。

## 926. 数组中两元素的最大乘积
* 给你一个整数数组`nums`，请你选择数组的两个不同下标`i`和`j`，使`(nums[i]-1)*(nums[j]-1)`取得最大值。 请你计算并返回该式的最大值。

## 927. 从二叉搜索树到更大和树
* 给定一个二叉搜索树`root`，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。

## 928. 统计子串中的唯一字符
* 我们定义了一个函数`countUniqueChars(s)`来统计字符串`s`中的唯一字符，并返回唯一字符的个数。 本题将会给你一个字符串`s`，我们需要返回`countUniqueChars(t)`的总和，其中`t`是`s`的子字符串。 注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串

## 929. 具有所有最深节点的最小子树
* 给定一个根为`root`的二叉树，每个节点的深度是 该节点到根的最短距离。 返回包含原始树中所有最深节点的最小子树 。 如果一个节点在整个树的任意节点之间具有最大的深度，则该节点是最深的。

## 930. 最深叶节点的最近公共祖先
* 给你一个有根节点`root`的二叉树，返回它全部的最深的叶节点的最近公共祖先 。

## 931. 在二叉树中分配硬币
* 给定一个有`N`个结点的二叉树的根结点`root`，树中的每个结点上都对应有`node.val`枚硬币，并且总共有`N`枚硬币。 在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。返回使每个结点上只有一枚硬币所需的移动次数。

## 932. 修剪二叉搜索树
* 给你二叉搜索树的根节点`root`，同时给定最小边界`low`和最大边界`high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。

## 933. 重新排列单词间的空格
* 给你一个字符串`text`，该字符串由若干被空格包围的单词组成。每个单词由一个或者多个小写英文字母组成，并且两个单词之间至少存在一个空格。题目测试用例保证`text`至少包含一个单词。 请你重新排列空格，使每对相邻单词之间的空格数目都相等，并尽可能最大化该数目。如果不能重新平均分配所有空格，请将多余的空格放置在字符串末尾，这也意味着返回的字符串应当与原`text`字符串的长度相等。 返回重新排列空格后的字符串 。

## 934. 优美的排列 II
* 给你两个整数`n`和`k`，请你构造一个答案列表`answer`，该列表应当包含从`1`到`n`的`n`个不同正整数，并同时满足下述条件：假设该列表是`answer = [a1, a2, a3, ... , an]`，那么列表`[|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|]`中应该有且仅有`k`个不同整数。 返回列表`answer`。如果存在多种答案，只需返回其中任意一种。

## 935. 文件夹操作日志搜集器
* 每当用户执行变更文件夹操作时，文件系统都会保存一条日志记录。 下面给出对变更操作的说明：`"../"`移动到当前文件夹的父文件夹，如果已经在主文件夹下，则继续停留在当前文件夹；`"./"`继续停留在当前文件夹；`"x/"`移动到名为`x`的子文件夹中。题目数据 保证总是存在文件夹`x`。 给你一个字符串列表`logs`，其中`logs[i]`是用户在第`i`步执行的操作。 文件系统启动时位于主文件夹，然后执行`logs`中的操作。 执行完所有变更文件夹操作后，请你找出返回主文件夹所需的最小步数 。

## 936. 
* 

## 937. 按照频率将数组升序排序
* 给你一个整数数组`nums`，请你将数组按照每个值的频率升序排序。如果有多个值的频率相同，请你按照数值本身将它们降序排序。请你返回排序后的数组。

## 938. 最大人工岛
* 给你一个大小为`n x n`二进制矩阵`grid`。最多 只能将一格`0`变成`1`。 返回执行此操作后，`grid`中最大的岛屿面积是多少？ 岛屿由一组上、下、左、右四个方向相连的`1`形成。

## 939.
* 

## 940. 两个相同字符之间的最长子字符串
* 给你一个字符串`s`，请你返回 两个相同字符之间的最长子字符串的长度 ，计算长度时不含这两个字符。如果不存在这样的子字符串，返回`-1`。 子字符串是字符串中的一个连续字符序列。

## 941. 最大交换
* 给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。

## 942. 雇佣 K 名工人的最低成本
* 有`n`名工人。给定两个数组`quality`和`wage`，其中，`quality[i]`表示第`i`名工人的工作质量，其最低期望工资为`wage[i]`。 现在我们想雇佣`k`名工人组成一个工资组。在雇佣一组`k`名工人时，每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资，且工资组中的每名工人至少应当得到他们的最低期望工资。 给定整数`k`，返回组成满足上述条件的付费群体所需的最小金额。在实际答案的`10**-5`以内的答案将被接受。

## 943. 灯泡开关 Ⅱ
* 房间中有`n`只已经打开的灯泡，编号从`1`到`n`。墙上挂着`4`个开关 。这`4`个开关各自都具有不同的功能，其中： 开关`1`：反转当前所有灯的状态； 开关`2`：反转编号为偶数的灯的状态； 开关`3`：反转编号为奇数的灯的状态； 开关`4`：反转编号为`j = 3k + 1`的灯的状态。 你必须恰好按压开关`presses`次。每次按压，你都需要从`4`个开关中选出一个来执行按压操作。 给你两个整数`n`和`presses`，执行完所有按压之后，返回不同可能状态的数量。

## 944. 删除某些元素后的数组均值
* 给你一个整数数组`arr`，请你删除最小`5%`的数字和最大`5%`的数字后，剩余数字的平均值。 与标准答案误差在`10**-5`的结果都被视为正确结果。

## 945. 特殊数组的特征值
* 给你一个非负整数数组`nums`。如果存在一个数`x`，使得`nums`中恰好有`x`个元素大于或者等于`x`，那么就称`nums`是一个特殊数组，而`x`是该数组的特征值。 注意：`x`不必是`nums`的中的元素。 如果数组`nums`是一个特殊数组，请返回它的特征值`x`。否则，返回`-1`。可以证明的是，如果`nums`是特殊数组，那么其特征值`x`是唯一的。

## 946. 能否连接形成数组
* 给你一个整数数组`arr`，数组中的每个整数 互不相同 。另有一个由整数数组构成的数组`pieces`，其中的整数也互不相同。请你以 任意顺序 连接`pieces`中的数组以形成`arr`。但是，不允许对每个数组`pieces[i]`中的整数重新排序。 如果可以连接`pieces`中的数组形成`arr`，返回`true`；否则，返回`false`。

## 947. 相似度为 K 的字符串
* 对于某些非负整数`k`，如果交换`s1`中两个字母的位置恰好`k`次，能够使结果字符串等于`s2`，则认为字符串`s1`和`s2`的相似度为`k`。 给你两个字母异位词`s1`和`s2`，返回`s1`和`s2`的相似度`k`的最小值。

## 948. 旋转数字
* 我们称一个数`X`为好数, 如果它的每位数字逐个地被旋转`180`度后，我们仍可以得到一个有效的，且和`X`不同的数。`0`,`1`,和`8`被旋转后仍然是它们自己；`2`和`5`可以互相旋转成对方；`6`和`9`同理，除了这些以外其他的数字旋转以后都不再是有效的数字。 现在我们有一个正整数`N`, 计算从`1`到`N`中有多少个数`X`是好数？

## 949. 消失的两个数字
* 给定一个数组，包含从`1`到`N`所有的整数，但其中缺了两个数字。你能在`O(N)`时间内只用`O(1)`的空间找到它们吗？ 以任意顺序返回这两个数字

## 950. 拆炸弹
* 你的情报员会给你一个长度为`n`的循环数组`code`以及一个密钥`k`。 为了获得正确的密码，你需要替换掉每一个数字。所有数字会同时被替换。 如果`k > 0`，将第`i`个数字用 接下来`k`个数字之和替换； 如果`k < 0`，将第`i`个数字用 之前`k`个数字之和替换； 如果`k == 0`，将第`i`个数字用`0`替换。 由于`code`是循环的，`code[n-1]`下一个元素是`code[0]`，且`code[0]`前一个元素是`code[n-1]`。 给你循环数组`code`和整数密钥`k`，请你返回解密后的结果来拆除炸弹！

## 951. 判定是否互为字符重排
* 给定两个字符串`s1`和`s2`，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。

## 952. 第 k 个数
* 有些数的素因子只有`3`，`5`，`7`，请设计一个算法找出第`k`个数。

## 953. 翻转等价二叉树
* 我们可以为二叉树`T`定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。 只要经过一定次数的翻转操作后，能使`X`等于`Y`，我们就称二叉树`X`翻转等价于二叉树`Y`。 这些树由根节点`root1`和`root2`给出。如果两个二叉树是否是翻转等价的函数，则返回`true`，否则返回`false`。

## 954. 二叉树的完全性检验
* 给定一个二叉树的`root`，确定它是否是一个完全二叉树。 在一个完全二叉树中，除了最后一个关卡外，所有关卡都是完全被填满的，并且最后一个关卡中的所有节点都是尽可能靠左的。它可以包含`1`到`2h`节点之间的最后一级`h`。

## 955. 二叉树中的列表
* 给你一棵以`root`为根的二叉树和一个`head`为第一个节点的链表。 如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以`head`为首的链表中每个节点的值，那么请你返回`True`，否则返回`False`。

## 956. 删点成林
* 给出二叉树的根节点`root`，树上每个节点都有一个不同的值。 如果节点值在`to_delete`中出现，我们就把该节点从树上删去，最后得到一个森林。 返回森林中的每棵树。你可以按任意顺序组织答案。

## 957. 零矩阵
* 编写一种算法，若`M × N`矩阵中某个元素为`0`，则将其所在的行与列清零。

## 958. 检查二进制字符串字段
* 给你一个二进制字符串`s`，该字符串 不含前导零。 如果`s`中由连续若干个`'1'`组成的字段数量不超过`1`，返回`true` 。否则，返回`false`。

## 959. K件物品的最大和
* 袋子中装有一些物品，每个物品上都标记着数字`1` 、`0`或`-1`。 给你四个非负整数`numOnes`、`numZeros`、`numNegOnes`和`k`。 袋子最初包含：`numOnes`件标记为`1`的物品。`numZeroes`件标记为`0`的物品。`numNegOnes`件标记为`-1`的物品。 现计划从这些物品中恰好选出`k`件物品。返回所有可行方案中，物品上所标记数字之和的最大值。

## 960. 质数减法运算
* 给你一个整数数组`nums`，数组长度为`n`。 你可以执行无限次下述运算： 选择一个之前未选过的下标`i`，并选择一个严格小于`nums[i]`的质数`p`，从`nums[i]`中减去`p`。 如果你能通过上述运算使得`nums`成为严格递增数组，则返回`true`；否则返回`false`。

## 961. 使数组元素全部相等的最少操作次数
* 给你一个正整数数组`nums`。 同时给你一个长度为`m`的整数数组`queries`。第`i`个查询中，你需要将`nums`中所有元素变成`queries[i]`。你可以执行以下操作任意次： 将数组里一个元素增大或者减小`1`。 请你返回一个长度为`m`的数组`answer`，其中`answer[i]`是将`nums`中所有元素变成`queries[i]`的最少操作次数。 注意，每次查询后，数组变回最开始的值。

## 962. 收集树中金币
* 给你一个`n`个节点的无向无根树，节点编号从`0`到`n - 1`。给你整数`n`和一个长度为`n - 1`的二维整数数组`edges`，其中`edges[i] = [ai, bi]`表示树中节点`ai`和`bi`之间有一条边。再给你一个长度为`n`的数组`coins`，其中`coins[i]`可能为`0`也可能为`1`，`1`表示节点`i`处有一个金币。 你需要选择树中任意一个节点出发。你可以执行下述操作任意次： 收集距离当前节点距离为`2`以内的所有金币； 移动到树中一个相邻节点。 你需要收集树中所有的金币，并且回到出发节点，请你返回最少经过的边数。 如果你多次经过一条边，每一次经过都会给答案加`1`

## 963. 两点之间不包含任何点的最宽垂直区域
* 给你`n`个二维平面上的点`points`，其中`points[i] = [xi, yi]`，请你返回两点之间内部不包含任何点的*最宽垂直区域*的宽度。*垂直区域*的定义是固定宽度，而`y`轴上无限延伸的一块区域。 请注意，垂直区域边上的点不在区域内。

## 964. 俄罗斯套娃信封问题
* 给你一个二维整数数组`envelopes`，其中`envelopes[i] = [wi, hi]`，表示第`i`个信封的宽度和高度。 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。 请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封。注意：不允许旋转信封。

## 965. 找出叠涂元素
* 给你一个整数数组`arr`和一个`m x n`的整数矩阵`mat`。`arr`和`mat`都包含范围`[1，m * n]`内的所有整数。 遍历`arr`中的每个下标`i`，并将包含整数`arr[i]`的`mat`单元格涂色。 请你找出`arr`中在`mat`的某一行或某一列上都被涂色、且下标最小的元素，并返回其下标`i`。

## 966. 保龄球游戏的获胜者
* 给你两个整数数组`player1`和`player2`，分别表示玩家`1`和玩家`2`击中的瓶数。 保龄球比赛由`n`轮组成，玩家在第`i`轮中击中`xi`个瓶子。玩家第`i`轮的价值为： 如果玩家在前两轮中有过一次性击中`10`个瓶子，则第`i`轮的价值为`2xi`； 否则，第`i`轮的价值为`xi`。 玩家的得分是其`n`轮价值的总和。 如果玩家`1`的得分高于玩家`2`的得分，返回`1`； 如果玩家`2`的得分高于玩家`1`的得分，返回`2`； 如果平局，返回`0`。

## 967.
* 

## 968.
* 

## 969.
* 

## 970.
* 

## 971.
* 

## 972.
* 

## 973.
* 

## 974.
* 

## 975.
* 

## 976.
* 

## 977.
* 

## 978.
* 

## 979.
* 

## 980.
* 

## 981.
* 

## 982.
* 

## 983.
* 

## 984.
* 

## 985.
* 

## 986.
* 

## 987.
* 

## 988.
* 

## 989.
* 

## 990.
* 

## 991.
* 

## 992.
* 

## 993.
* 

## 994.
* 

## 995.
* 

## 996.
* 

## 997.
* 

## 998.
* 

## 999.
* 

## 1000.
* 

