## 1. 第一个错误的版本
* 所以错误的版本之后的所有版本都是错的. 假设你有`n`个版本 `[1, 2, ..., n]`,你想找出导致之后所有版本出错的第一个错误的版本

## 2. 二分查找
* 给定一个`n`个元素有序的（升序）整型数组`nums`和一个目标值`target` ,写一个函数搜索`nums`中的`target`,如果目标值存在返回下标,否则返回`-1

## 3. 搜索插入位置
* 给定一个排序数组和一个目标值,在数组中找到目标值,并返回其索引.如果目标值不存在于数组中,返回它将会被按顺序插入的位置.

## 4. 旋转数组
* 给定一个数组,将数组中的元素向右移动`k`个位置,其中`k`是非负数

## 5. 有序数组的平方
* 给你一个按 **非递减顺序** 排序的整数数组`nums`,返回 **每个数字的平方** 组成的新数组,要求也按 **非递减顺序** 排序

## 6. 移动零
* 给定一个数组`nums`,编写一个函数将所有`0`移动到数组的末尾,同时保持非零元素的相对顺序.

## 7. 两数之和 II - 输入有序数组
* 给定一个已按照 **升序排列** 的整数数组`numbers`,请你从数组中找出两个数满足相加之和等于目标数`target`

## 8. 反转字符串
* 编写一个函数,其作用是将输入的字符串反转过来.输入字符串以字符数组`char[]`的形式给出. 不要给另外的数组分配额外的空间,你必须原地修改输入数组、使用`O(1)`的额外空间解决这一问题.

## 9. 反转字符串中的单词 III
* 给定一个字符串,你需要反转字符串中每个单词的字符顺序,同时仍保留空格和单词的初始顺序

## 10. 链表的中间结点
* 给定一个头结点为`head`的非空单链表,返回链表的中间结点

## 11. 删除链表的倒数第 N 个结点
* 给你一个链表,删除链表的倒数第`n`个结点,并且返回链表的头结点

## 12. 无重复字符的最长子串
* 给定一个字符串`s`,请你找出其中不含有重复字符的 **最长子串** 的长度

## 13. 字符串的排列
* 给你两个字符串`s1`和`s2`,写一个函数来判断`s2`是否包含`s1`的排列

## 14. 图像渲染
* 图像中所有颜色相同且上下左右相邻的像素点可以看作一个区域,将初始点所在区域内的所有像素点的颜色值换成新的颜色

## 15. 岛屿的最大面积
* 一个 **岛屿** 是由一些相邻的`1`(代表土地)构成的组合,这里的「相邻」要求两个`1`必须在水平或者竖直方向上相邻.你可以假设`grid`的四个边缘都被`0`（代表水）包围着. 找到给定的二维数组中最大的岛屿面积.

## 16.合并二叉树
* 将两个合并为一个新的二叉树.合并的规则是如果两个节点重叠,那么将他们的值相加作为节点合并后的新值,否则不为`NULL`的节点将直接作为新二叉树的节点

## 17. 填充每个节点的下一个右侧节点指针
* 给定一个 **完美二叉树** ,其所有叶子节点都在同一层,每个父节点都有两个子节点填充它的每个`next`指针,让这个指针指向其下一个右侧节点.

## 18. 01 矩阵
* 给定一个由`0`和`1`组成的矩阵`mat`,请输出一个大小相同的矩阵,其中每一个格子是`mat`中对应位置元素到最近的`0`的距离

## 19.腐烂的橘子
* 每分钟,任何与腐烂的橘子（在`4`个正方向上）相邻的新鲜橘子都会腐烂. 返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数

## 20. 合并两个有序链表
* 将两个升序链表合并为一个新的 **升序** 链表并返回.新链表是通过拼接给定的两个链表的所有节点组成的

## 21. 反转链表
* 给你单链表的头节点`head`,请你反转链表,并返回反转后的链表

## 22. 组合
* 给定两个整数`n`和`k,返回范围`[1, n]`中所有可能的`k`个数的组合

## 23. 全排列
* 给定一个不含重复数字的数组`nums`,返回其所有可能的全排列

## 24. 字母大小写全排列
* 给定一个字符串S,通过将字符串S中的每个字母转变大小写,我们可以获得一个新的字符串.返回所有可能得到的字符串集合

## 25. 爬楼梯
* 每次你可以爬`1`或`2`个台阶.你有多少种不同的方法可以爬到楼顶呢

## 26. 打家劫舍
* 每间房内都藏有一定的现金,影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统,如果两间相邻的房屋在同一晚上被小偷闯入,系统会自动报警.计算你 **不触动警报装置的情况下** ,一夜之内能够偷窃到的最高金额

## 27. 三角形最小路径和
* 给定一个三角形`triangle`,找出自顶向下的最小路径和

## 28. 2 的幂
* 给你一个整数`n`,请你判断该整数是否是`2`的幂次方

## 29. 位1的个数
* 编写一个函数,输入是一个无符号整数（以二进制串的形式）,返回其二进制表达式中数字位数为`'1'`的个数

## 30. 颠倒二进制位
* 颠倒给定的`32`位无符号整数的二进制位

## 31. 只出现一次的数字
* 给定一个非空整数数组,除了某个元素只出现一次以外,其余每个元素均出现两次.找出那个只出现了一次的元素

## 32. 存在重复元素
* 给定一个整数数组,判断是否存在重复元素

## 33. 最大子序和
* 给定一个整数数组`nums`,找到一个具有最大和的连续子数组（子数组最少包含一个元素）,返回其最大和

## 34. 两数之和
* 给定一个整数数组`nums`和一个整数目标值`target`,请你在该数组中找出和为目标值 **target**  的那 两个 整数,并返回它们的数组下标

## 35. 合并两个有序数组
* 给你两个有序整数数组`nums1`和`nums2`,请你将`nums2`合并到`nums1`中,使`nums1`成为一个有序数组

## 36. 斐波那契数 
* 斐波那契数,通常用`F(n)`表示,形成的序列称为 **斐波那契数列** .该数列由`0`和`1`开始,后面的每一项数字都是前面两项数字的和

## 37. 第 N 个泰波那契数
* 请返回第`n`个泰波那契数`Tn`的值

## 38. 使用最小花费爬楼梯
* 每当你爬上一个阶梯你都要花费对应的体力值,一旦支付了相应的体力值,你就可以选择向上爬一个阶梯或者爬两个阶梯. 请你找出达到楼层顶部的最低花费

## 39. 打家劫舍 II
* 每间房内都藏有一定的现金.这个地方所有的房屋都 **围成一圈** ,这意味着第一个房屋和最后一个房屋是紧挨着的.同时,相邻的房屋装有相互连通的防盗系统,如果两间 **相邻** 的房屋在同一晚上被小偷闯入,系统会自动报警 .计算你 **在不触动警报装置的情况下** ,今晚能够偷窃到的最高金额

## 40. 删除并获得点数
* 给你一个整数数组nums, 每次操作中,选择任意一个`nums[i]`,删除它并获得`nums[i]`的点数.之后,你必须删除 **所有** 等于`nums[i] - 1`和 nums[i] + 1的元素. 返回你能通过这些操作获得的最大点数

## 41. 两个数组的交集 II
* 给定两个数组,编写一个函数来计算它们的交集

## 42. 买卖股票的最佳时机
* 给定一个数组`prices`,它的第`i`个元素`prices[i]`表示一支给定股票第`i`天的价格. 你只能选择 **某一天** 买入这只股票,并选择在 **未来的某一个不同的日子** 卖出该股票.计算你所能获取的最大利润

## 43. 重塑矩阵
* 将一个`m x n`矩阵重塑为另一个大小不同`r x c`的新矩阵,但保留其原始数据

## 44. 杨辉三角
* 给定一个非负整数`numRows`,生成「杨辉三角」的前`numRows`行

## 45. 有效的数独
* 请你判断一个`9x9`的数独是否有效.数字`1-9`在每一行只能出现一次. 数字`1-9`在每一列只能出现一次. 数字`1-9`在每一个以粗实线分隔的`3x3`宫内只能出现一次.

## 46. 矩阵置零
* 给定一个`m x n`的矩阵,如果一个元素为`0`,则将其所在行和列的所有元素都设为`0`.请使用 **原地** 算法

## 47. 字符串中的第一个唯一字符
* 给定一个字符串,找到它的第一个不重复的字符,并返回它的索引

## 48. 赎金信
* 给定一个赎金信字符串和一个杂志字符串,判断第一个字符串`ransom`能不能由第二个字符串`magazines`里面的字符构成

## 49. 有效的字母异位词
* 给定两个字符串`s`和`t`,编写一个函数来判断`t`是否是`s`的字母异位词

## 50. 环形链表
* 给定一个链表,判断链表中是否有环

## 51. 移除链表元素
* 给你一个链表的头节点`head`和一个整数`val`,请你删除链表中所有满足`Node.val == val`的节点,并返回 新的头节点

## 52. 删除排序链表中的重复元素
* 存在一个按升序排列的链表,给你这个链表的头节点`head`,请你删除所有重复的元素,使每个元素 **只出现一次** 

## 53. 跳跃游戏
* 给定一个非负整数数组`nums`,你最初位于数组的 **第一个下标** . 数组中的每个元素代表你在该位置可以跳跃的最大长度. 判断你是否能够到达最后一个下标

## 54. 跳跃游戏 II
* 给你一个非负整数数组`nums`,你最初位于数组的第一个位置. 数组中的每个元素代表你在该位置可以跳跃的最大长度. 你的目标是使用最少的跳跃次数到达数组的最后一个位置.

## 55. 环形子数组的最大和
* 给定一个由整数数组`A`表示的环形数组`C`,求`C`的非空子数组的最大可能和

## 56. 乘积最大子数组
* 给你一个整数数组`nums`,请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）,并返回该子数组所对应的乘积

## 57. 乘积为正数的最长子数组长度
* 给你一个整数数组`nums`,请你求出乘积为正数的最长子数组的长度. 一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组. 请你返回乘积为正数的最长子数组长度

## 58. 最佳观光组合
* 给你一个正整数数组`values`,其中`values[i]`表示第`i`个观光景点的评分,并且两个景点`i`和`j`之间的 **距离** 为`j - i`. 一对景点组成的观光组合的得分为`values[i] + values[j] + i - j`,也就是景点的评分之和 **减去** 它们两者之间的距离. 返回一对观光景点能取得的最高分

## 59. 买卖股票的最佳时机 II
* 给定一个数组`prices`,其中`prices[i]`是一支给定股票第`i`天的价格. 设计一个算法来计算你所能获取的最大利润.你可以尽可能地完成更多的交易

## 60. 最佳买卖股票时机含冷冻期
* 给定一个整数数组,其中第`i`个元素代表了第`i`天的股票价格 .设计一个算法计算出最大利润.在满足以下约束条件下,你可以尽可能地完成更多的交易.你不能同时参与多笔交易.卖出股票后,你无法在第二天买入股票 (即冷冻期为`1`天)

## 61. 买卖股票的最佳时机含手续费
* 给定一个整数数组`prices`,其中第`i`个元素代表了第`i`天的股票价格 ；整数`fee`代表了交易股票的手续费用. 你可以无限次地完成交易,但是你每笔交易都需要付手续费.如果你已经购买了一个股票,在卖出它之前你就不能再继续购买股票了. 返回获得利润的最大值

## 62. 单词拆分
* 给定一个非空字符串`s`和一个包含非空单词的列表`wordDict`,判定`s`是否可以被空格拆分为一个或多个在字典中出现的单词

## 63. 接雨水
* 给定`n`个非负整数表示每个宽度为`1`的柱子的高度图,计算按此排列的柱子,下雨之后能接多少雨水

## 64. 有效的括号
* 给定一个只包括`'(',')','{','}','[',']'`的字符串`s`,判断字符串是否有效

## 65. 用栈实现队列
* 请你仅使用两个栈实现先入先出队列.队列应当支持一般队列支持的所有操作（push、pop、peek、empty）

## 66. 二叉树的中序遍历
* 二叉树的中序遍历

## 67. 二叉树的前序遍历
* 二叉树的前序遍历

## 68. 二叉树的后序遍历
* 二叉树的后序遍历

## 69. 等差数列划分
* 给你一个整数数组`nums`,返回数组`nums`中所有为等差数组的 **子数组** 个数

## 70. 解码方法
*`'A' -> 1 , 'B' -> 2 , ...  'Z' -> 26 `.给你一个只含数字的 **非空** 字符串`s`,请计算并返回 **解码** 方法的 **总数**

## 71. 对称二叉树
* 给定一个二叉树,检查它是否是镜像对称的

## 72. 二叉树的层序遍历
* 给你一个二叉树,请你返回其按 **层序遍历** 得到的节点值.

## 73. 二叉树的最大深度
* 给定一个二叉树,找出其最大深度

## 74. 丑数 II
* 给你一个整数`n`,请你找出并返回第`n`个 丑数 . 丑数 **就是只包含质因数**` 2`、`3`和/或`5`的正整数.

## 75. 不同的二叉搜索树
* 给你一个整数`n`,求恰由`n`个节点组成且节点值从`1`到`n`互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数

## 76. 杨辉三角 II
* 给定一个非负索引`rowIndex`,返回「杨辉三角」的第`rowIndex`行

## 77. 下降路径最小和
* 给你一个`n x n`的 **方形** 整数数组`matrix`,请你找出并返回通过`matrix`的下降路径的 **最小和** 

## 78. 矩阵区域和
* 给你一个`m x n`的矩阵`mat`和一个整数 k ,请你返回一个矩阵`answer`,其中每个`answer[i][j]`是所有满足下述条件的元素`mat[r][c] 的和,i - k <= r <= i + k, j - k <= c <= j + k ,(r, c)`在矩阵内

## 79. 二维区域和检索 - 矩阵不可变
* 计算其子矩形范围内元素的总和,该子矩阵的左上角为`(row1, col1)`,右下角为`(row2, col2)`

## 80. 不同路径
* 一个机器人位于一个`m x n`网格的左上角. 机器人每次只能向下或者向右移动一步.机器人试图达到网格的右下角. 问总共有多少条不同的路径？

## 81. 不同路径 II
* 一个机器人位于一个`m x n`网格的左上角. 机器人每次只能向下或者向右移动一步.机器人试图达到网格的右下角. 现在考虑网格中有障碍物.那么从左上角到右下角将会有多少条不同的路径？

## 82. 翻转二叉树
* 翻转一棵二叉树

## 83. 路径总和
* 给你二叉树的根节点`root`和一个表示目标和的整数`targetSum`,判断该树中是否存在 **根节点到叶子节点** 的路径,这条路径上所有节点值相加等于目标和·targetSum·

## 84. 验证二叉搜索树
* 给定一个二叉树,判断其是否是一个有效的二叉搜索树

## 85. 两数之和 IV - 输入 BST
* 给定一个二叉搜索树`root`和一个目标结果`k`,如果`BST`中存在两个元素且它们的和等于给定的目标结果,则返回`true`.

## 86. 二叉搜索树的最近公共祖先
* 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先

## 87. 最小路径和
* 给定一个包含非负整数的`m x n`网格`grid`,请找出一条从左上角到右下角的路径,使得路径上的数字总和为最小

## 88. 最大正方形
* 在一个由`0`和`1`组成的二维矩阵内,找到只包含`1`的最大正方形,并返回其面积

## 89. 最长回文子串
* 给你一个字符串`s`,找到`s`中最长的回文子串

## 90. 最长回文子序列
* 给你一个字符串`s`,找出其中最长的回文子序列,并返回该序列的长度。子序列定义为：不改变剩余字符顺序的情况下,删除某些字符或者不删除任何字符形成的一个序列

## 91. 最长递增子序列
* 给你一个整数数组`nums`,找到其中最长严格递增子序列的长度。子序列是由数组派生而来的序列,删除（或不删除）数组中的元素而不改变其余元素的顺序。例如,`[3,6,2,7]`是数组`[0,3,1,6,2,2,7]`的子序列

## 92. 摆动序列
* 如果连续数字之间的差严格地在正数和负数之间交替,则数字序列称为 摆动序列 。给你一个整数数组`nums`,返回`nums`中作为 **摆动序列** 的 **最长子序列的长度**

## 93. 判断子序列
* 给定字符串`s`和`t`,判断`s`是否为`t`的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串

## 94. 最长公共子序列
* 给定两个字符串`text1`和`text2`,返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ,返回`0`。 一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串

## 95. 编辑距离
* 给你两个单词`word1`和`word2`,请你计算出将`word1`转换成`word2`所使用的最少操作数

## 96. 零钱兑8换
* 给你一个整数数组`coins`,表示不同面额的硬币；以及一个整数`amount`,表示总金额。 计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额,返回`-1`

## 97. 零钱兑换 II
* 给你一个整数数组`coins`表示不同面额的硬币,另给一个整数`amount`表示总金额。 请你计算并返回可以凑成总金额的硬币组合数

## 98. 组合总和 Ⅳ
* 给你一个由 **不同** 整数组成的数组`nums`,和一个目标整数`target`。请你从`nums`中找出并返回总和为`target`的元素组合的个数

## 99. 整数拆分
* 给定一个正整数`n`,将其拆分为至少两个正整数的和,并使这些整数的乘积最大化。 返回你可以获得的最大乘积

## 100. 完全平方数
* 给定正整数`n`,找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于`n`。你需要让组成和的完全平方数的个数最少。 给你一个整数`n`,返回和为`n`的完全平方数的 **最少数量**

## 101. 二叉搜索树中的搜索
* 给定二叉搜索树（`BST`）的根节点和一个值。 你需要在 `BST` 中找到节点值等于给定值的节点。

## 102. 二叉搜索树中的插入操作
* 给定二叉搜索树（`BST`）的根节点和要插入树中的值，将值插入 `BST` 。 返回插入后 `BST` 的根节点

## 103.  统计不开心的朋友
* 给你一份`n`位朋友的亲近程度列表，其中`n`总是 **偶数** 。对每位朋友`i`，`preferences[i]`包含一份 **按亲近程度从高到低排列** 的朋友列表。换句话说，排在列表前面的朋友与`i`的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以`0`到`n-1`之间的整数表示。 所有的朋友被分成几对，配对情况以列表`pairs`给出，其中`pairs[i] = [xi, yi]`表示`xi`与`yi`配对，且`yi`与`xi`配对。 但是，这样的配对情况可能会是其中部分朋友感到不开心：在 x 与 y 配对且 u 与 `v` 配对的情况下，如果同时满足下述两个条件，`x`就会不开心：`x`与`u`的亲近程度胜过`x`与`y`，且`u`与`x`的亲近程度胜过`u`与`v`。返回 **不开心的朋友的数目** 。

## 104.  出界的路径数
* 给你一个大小为`m x n`的网格和一个球。球的起始坐标为`[startRow, startColumn]`。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 **最多** 可以移动`maxMove`次球。 找出并返回可以将球移出边界的路径数量。

## 105.  两数相加
* 给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表

## 106. 寻找两个正序数组的中位数
* 给定两个大小分别为`m`和`n`的正序（从小到大）数组`nums1`和`nums2`。请你找出并返回这两个正序数组的 **中位数**

## 107. 优美的排列
* 假设有从`1`到`N`的`N`个整数，如果从这`N`个数字中成功构造出一个数组，使得数组的第`i`位 (`1 <= i <= N`) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列： 1:第`i`位的数字能被`i`整除。 2:`i`能被第 i 位上的数字整除。现在给定一个整数 N，请问可以构造多少个优美的排列

## 108. Z 字形变换
* 将一个给定字符串`s`根据给定的行数`numRows`，以从上往下、从左到右进行 **N** 字形排列

## 109. 学生出勤记录 I
* 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：'A'：Absent，缺勤；'L'：Late，迟到；'P'：Present，到场。 如果学生能够 **同时** 满足下面两个条件，则可以获得出勤奖励： 按 **总出勤** 计，学生缺勤（'A'）严格 **少于两天** 。 学生 不会 存在 连续 3 天或 3 天以上的迟到（'L'）记录。 如果学生可以获得出勤奖励，返回`true`；否则，返回`false`

## 110. 学生出勤记录 II
* 可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：'A'：Absent，缺勤；  'L'：Late，迟到；  'P'：Present，到场。  如果学生能够 **同时** 满足下面两个条件，则可以获得出勤奖励： 按 **总出勤** 计，学生缺勤（'A'）严格 **少于两天** 。 学生 **不会** 存在 连续`3`天或连续`3`天以上的迟到（'L'）记录。 给你一个整数`n`，表示出勤记录的长度（次数）。请你返回记录长度为`n`时，可能获得出勤奖励的记录情况 **数量**

## 111. 整数反转
* 给你一个 32 位的有符号整数`x`，返回将`x`中的数字部分反转后的结果

## 112. 字符串转换整数 (atoi)
* 请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数。除开头符号外，如某字符为非数字，之后的字符忽略

## 113. 回文数
*给你一个整数`x`,不转换成字符串,判断是否回文

## 114. 反转字符串中的元音字母
* 编写一个函数，以字符串作为输入，反转该字符串中的元音字母

## 115. 正则表达式匹配
* 给你一个字符串`s`和一个字符规律`p`，请你来实现一个支持`'.'`和`'*'`的正则表达式匹配。`'.'`配任意单个字符; `'*'`匹配零个或多个前面的那一个元素

## 116. 反转字符串 II
* 给定一个字符串`s`和一个整数`k`，从字符串开头算起，每`2k`个字符反转前`k`个字符。 如果剩余字符少于`k`个，则将剩余字符全部反转。 如果剩余字符小于`2k`但大于或等于`k`个，则反转前`k`个字符，其余字符保持原样。

## 117. 盛最多水的容器
* 给你`n`个非负整数`a1，a2，...，an`，每个数代表坐标中的一个点在`i`处高为`ai`的边。找出其中的两条边，使得它们与`x`轴共同构成的容器可以容纳最多的水

## 118. 整数转罗马数字
* 罗马数字中小的数字在大的数字的右边。但也存在特例。例如数字`4`写做`IV`，数字`9`表示为`IX`。给你一个整数，将其转为罗马数字。

## 119. 压缩字符串
* 给你一个字符数组 chars ，请使用下述算法压缩： 从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ： 如果这一组长度为`1`，则将字符追加到`s`中。 否则，需要向`s`追加字符，后跟这一组的长度。 压缩后得到的字符串`s`不应该直接返回 ，需要转储到字符数组`chars`中。需要注意的是，组长度本身也要被拆分成多个字符。 请在 **修改完输入数组后** ，返回该数组的新长度。

## 120. 罗马数字转整数
* 罗马数字中小的数字在大的数字的右边。但也存在特例。例如数字`4`写做`IV`，数字`9`表示为`IX`。给你一个罗马数字，将其转为整数。

## 121. 最长公共前缀
* 编写一个函数来查找字符串数组中的最长公共前缀

## 122. 逃脱阻碍者
* 你在进行一个简化版的吃豆人游戏。你从`[0, 0]`点开始出发，你的目的地是`target = [xtarget, ytarget]`。地图上有一些阻碍者，以数组`ghosts`给出，第`i`个阻碍者从`ghosts[i] = [xi, yi]`出发。所有输入均为 **整数坐标** 。 每一回合，你和阻碍者们可以同时向上下左右移动，每次可以移动到距离原位置`1`个单位的新位置。当然，也可以选择 **不动** 。所有动作 **同时** 发生。 返回你是否可以在任何阻碍者抓住你 **之前** 到达目的地

## 123. 三数之和
* 给你一个包含`n`个整数的数组`nums`，判断`nums`中是否存在三个元素`a，b，c`，使得`a + b + c = 0`？请你找出所有和为`0`且不重复的三元组

## 124. 获取生成数组中的最大值
* 给你一个整数`n`。按下述规则生成一个长度为`n + 1`的数组`nums`：`nums[0] = 0`；`nums[1] = 1`； 当`2 <= 2 * i <= n`时，`nums[2 * i] = nums[i]`； 当`2 <= 2 * i + 1 <= n`时，`nums[2 * i + 1] = nums[i] + nums[i + 1]`。返回生成数组`nums`中的 **最大** 值

## 125. 最接近的三数之和
* 给定一个包括`n`个整数的数组`nums`和一个目标值`target`。找出`nums`中的三个整数，使得它们的和与`target`最接近。返回这三个数的和。假定每组输入只存在唯一答案

## 126. 电话号码的字母组合
* 给定一个仅包含数字`2-9`的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回

## 127. K 站中转内最便宜的航班
* 有`n`个城市通过一些航班连接。给你一个数组`flights`，其中`flights[i] = [fromi, toi, pricei]`，表示该航班都从城市`fromi`开始，以价格`pricei`抵达`toi`。 现在给定所有的城市和航班，以及出发城市`src`和目的地`dst`，你的任务是找到出一条最多经过`k`站中转的路线，使得从`src`到`dst`的 **价格最便宜** 。 如果不存在这样的路线，则输出`-1`

## 128. 四数之和
* 给你一个由`n`个整数组成的数组`nums`，和一个目标值`target`。请你找出并返回满足下述全部条件且不重复的四元组`[nums[a], nums[b], nums[c], nums[d]]`：`0 <= a, b, c, d < n`；`a`、`b`、`c`和`d`互不相同；`nums[a] + nums[b] + nums[c] + nums[d] == target`

## 129. 所有可能的路径
* 给你一个有`n`个节点的 **有向无环图（DAG）** ，请你找出所有从节点`0`到节点`n-1`的路径

## 130. 救生艇
* 第`i`个人的体重为`people[i]`，每艘船可以承载的最大重量为`limit`。 每艘船最多可同时载两人，但条件是这些人的重量之和最多为`limit`。 返回最小船数。

## 131. 括号生成
* 数字`n`代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合

## 132. 数据流的中位数
* 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中; double findMedian() - 返回目前所有元素的中位数

## 133. 合并K个升序链表
* 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表

## 134. 一维数组的动态和
* 给你一个数组`nums`。数组「动态和」的计算公式为：`runningSum[i] = sum(nums[0]…nums[i])`

## 135. 两两交换链表中的节点
* 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换

## 136. 所有奇数长度子数组的和
* 给你一个正整数数组`arr`，请你计算所有可能的奇数长度子数组的和

## 137. K 个一组翻转链表
* 给你一个链表，每`k`个节点一组进行翻转，请你返回翻转后的链表

## 138. 按权重随机选择
* 给定一个正整数数组`w`，其中`w[i]`代表下标`i`的权重（下标从`0`开始），请写一个函数`pickIndex`，它可以随机地获取下标`i`，选取下标`i`的概率与`w[i]`成正比

## 139. 删除有序数组中的重复项
* 给你一个有序数组`nums`，请你 原地 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度

## 140. 反转字符串中的元音字母
* 给你一个字符串`s`，仅反转字符串中的所有元音字母，并返回结果字符串

## 141. 移除元素
* 给你一个数组`nums`和一个值`val`，你需要 **原地** 移除所有数值等于`val`的元素，并返回移除后数组的新长度

## 142. 实现 strStr()
* 给你两个字符串`haystack`和`needle`，请你在`haystack`字符串中找出`needle`字符串出现的第一个位置（下标从`0`开始）。如果不存在，则返回`-1`

## 143. 航班预订统计
* 这里有`n`个航班，它们分别从`1`到`n`进行编号。 有一份航班预订表`bookings`，表中第`i`条预订记录`bookings[i] = [firsti, lasti, seatsi]`意味着在从`firsti`到`lasti`（包含`firsti`和`lasti`）的 **每个航班** 上预订了`seatsi`个座位。 请你返回一个长度为`n`的数组`answer`，其中`answer[i]`是航班`i`上预订的座位总数

## 144. 比较版本号
* 给你两个版本号`version1`和`version2`，请你比较它们。从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 **忽略任何前导零后的整数值** 

## 145. 两数相除
* 给定两个整数，被除数`dividend`和除数`divisor`。将两数相除，要求不使用乘法、除法和`mod`运算符

## 146. 串联所有单词的子串
* 给定一个字符串`s`和一些 **长度相同** 的单词`words`。找出`s`中恰好可以由`words`中所有单词串联形成的子串的起始位置

## 147. 链表中倒数第k个节点
* 输入一个链表，输出该链表中倒数第`k`个节点

## 148. 下一个排列
* 实现获取 **下一个排列** 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即组合出下一个更大的整数）

## 149. 最小K个数
* 设计一个算法，找出数组中最小的`k`个数。

## 150. 最长有效括号
* 给你一个只包含`'('`和`')'`的字符串，找出最长有效（格式正确且连续）括号子串的长度

## 151. 斐波那契数列
* 写一个函数，输入`n`，求斐波那契（Fibonacci）数列的第`n`项（即`F(N)`）

## 152. 搜索旋转排序数组
* 整数数组`nums`按升序排列，数组中的值 **互不相同** 。 在传递给函数之前，`nums`在预先未知的某个下标`k`上进行了 **旋转** ，使数组变为`[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标从`0`开始计数）。例如，`[0,1,2,4,5,6,7]`在下标`3`处经旋转后可能变为`[4,5,6,7,0,1,2]`。 给你 **旋转后** 的数组`nums`和一个整数`target`，如果`nums`中存在这个目标值`target`，则返回它的下标，否则返回`-1`

## 153. 在排序数组中查找元素的第一个和最后一个位置
* 给定一个按照升序排列的整数数组`nums`，和一个目标值`target`。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值`target`，返回`[-1, -1]`

## 154. 组合总和
* 给定一个无重复元素的正整数数组`candidates`和一个正整数`target`，找出`candidates`中所有可以使数字和为目标数`target`的唯一组合。`candidates`中的数字可以无限制重复被选取

## 155. 组合总和 II
* 给定一个数组`candidates`和一个目标数`target`，找出`candidates`中所有可以使数字和为`target`的组合。`candidates`中的每个数字在每个组合中只能使用一次

## 156. 用 Rand7() 实现 Rand10()
* 已有方法`rand7`可生成`1`到`7`范围内的均匀随机整数，试写一个方法`rand10`生成`1`到`10`范围内的均匀随机整数

## 157. 字符串相加
* 给定两个字符串形式的非负整数`num1`和`num2`，计算它们的和

## 158. 字符串相乘
* 给定两个以字符串形式表示的非负整数`num1`和`num2`，返回`num1`和`num2`的乘积，它们的乘积也表示为字符串形式

## 159. 解数独
* 编写一个程序，通过填充空格来解决数独问题。 数独的解法需 遵循如下规则： 数字`1-9`在每一行只能出现一次； 数字`1-9`在每一列只能出现一次； 数字`1-9`在每一个以粗实线分隔的`3x3`宫内只能出现一次

## 160. 全排列 II
* 给定一个可包含重复数字的序列`nums`，按任意顺序 返回所有不重复的全排列

## 161. Pow(x, n)
* 实现`pow(x, n)`，即计算`x`的`n`次幂函数

## 162. 缺失的第一个正数
* 给你一个未排序的整数数组`nums`，请你找出其中没有出现的最小的正整数

## 163. 分割平衡字符串
* 在一个 **平衡字符串** 中，`'L'`和`'R'`字符的数量是相同的。 给你一个平衡字符串`s`，请你将它分割成尽可能多的平衡字符串

## 164. IPO
* 给你`n`个项目。对于每个项目`i`，它都有一个 **纯利润** `profits[i]`，和启动该项目 **需要的最小资本** `capital[i]`。你的资本为`w`。当你完成一个项目时，利润将被添加到你的总资本中。 在IPO之前完成最多`k`个不同的项目。设计完成最多`k`个不同项目后得到最大总资本的方式。

## 165. 外观数列
* 给定一个正整数`n`，输出外观数列的第`n`项。 1.`"1"`；2.`"11"`；3.`"21"`； 第二项，这个数是`"1"`即 “ 一 个 1 ”，记作`"11"`；第三项，这个数是`"11"`即 “ 二 个 1 ” ，记作 "21"
  
## 166. 旋转图像
* 给定一个`n × n`的二维矩阵`matrix`表示一个图像。请你将图像顺时针旋转`90`度

## 167. 文本左右对齐
* 给定一个单词数组和一个长度`maxWidth`，重新排版单词，使其成为每行恰好有`maxWidth`个字符，左右两端对齐。 要求尽可能均匀分配单词间的空格数量，单词之间至少有一个空格。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。 文本的最后一行应为左对齐，且单词之间不插入额外的空格。

## 168. 字母异位词分组
* 给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。 **字母异位词** 是由重新排列源单词的字母得到的一个新单词。所有源单词中的字母都恰好只用一次

## 169. 数字 1 的个数
* 给定一个整数`n`，计算所有小于等于`n`的非负整数中数字`1`出现的个数

## 170. 找到需要补充粉笔的学生编号
*有`n`人，编号为`0`到`n - 1`，从`0`到`n-1`号依次回答问题，然后重复这个过程。 给你一个长度为`n`的整数数组`chalk`和一个整数`k`。一开始总共有`k`支粉笔。编号为`i`的学生回答问题时，消耗`chalk[i]`支粉笔。如果剩余粉笔数量 **严格小于** `chalk[i]`，此人需要补充粉笔。 请你返回需要补充粉笔的人的编号

## 171. N 皇后
* **n皇后问题** 研究的是如何将`n`个皇后放置在`n×n`的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数`n`，返回所有`n`皇后问题的解决方案

## 172. N皇后 II
* **n皇后问题** 研究的是如何将`n`个皇后放置在`n×n`的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数`n`，返回`n`皇后问题解决方案的数量。

## 173. 通配符匹配
* 给定一个字符串`s`和一个字符模式`p`，实现一个支持`'?'`和`'*'`的通配符匹配。`'?'`可以匹配任何单个字符；`'*'`可以匹配任意字符串（包括空字符串）

## 174. 不含连续1的非负整数
* 给定一个正整数`n`，找出小于或等于`n`的非负整数中，其二进制表示不包含 **连续的1** 的个数

## 175. 无人机方阵
* 给定两个大小均为`N*M`的二维数组`source`和`target`表示无人机方阵表演的两种颜色图案，请返回从`source`到`target`最少需要多少架无人机切换灯光颜色

## 176. 心算挑战
* 从`N`张卡牌中选出`cnt`张卡牌，若这`cnt`张卡牌数字总和为偶数，则选手成绩 **「有效」** 且得分为`cnt`张卡牌数字总和。`cards[i]`表示第`i`张卡牌上的数字。 计算最大的有效得分。若不存在获取有效得分的卡牌方案，则返回`0`

## 177. 有效的括号字符串
* 一个只包含三种字符的字符串：`"("`,`")"`,`"*"`，检验字符串是否有效：1.`"*"`可以被视为`")"`，或`"("`，或一个空字符串；2.左右括号必须互相匹配

## 178. 判断能否形成等差数列
* 给你一个数字数组`arr`。判断能否重新排列数组形成等差数列

## 179. 所有蚂蚁掉下来前的最后一刻
* 一些蚂蚁在木板上移动，每只蚂蚁都以 **每秒一个单位** 的速度移动。其中，一部分蚂蚁向 **左** 移动，其他蚂蚁向 **右** 移动。当两只 **不同** 方向移动的蚂蚁相遇时，它们会同时改变移动方向并继续移动。当蚂蚁到达木板的一端时，它立即从木板上掉下来。 给你一个整数`n`和两个整数数组`left`以及`right`。木板长度为`n`个单位。两个数组分别标识向左向右移动的蚂蚁在`t = 0`时的位置。请你返回最后一只蚂蚁掉下来的时刻

## 180. 反转单词前缀
* 给你一个字符串`word`和一个字符`ch`。找出`ch`第一次出现的下标`i`，反转`word`中从下标`0`开始、直到下标`i`结束（含下标`i`）的那段字符。如果`word`中不存在字符`ch`，则无需进行任何操作

## 181. 相同的树
* 给你两棵二叉树的根节点`p`和`q`，编写一个函数来检验这两棵树是否相同

## 182. 删除二叉搜索树中的节点
* 给定一个二叉搜索树的根节点`root`和一个值`key`，若存在则删除二叉搜索树中的`key`对应的节点，并保证二叉搜索树的性质不变

## 183. 回旋镖的数量
* 给定平面上`n`对 **互不相同** 的点`points`，其中`points[i] = [xi, yi]`。回旋镖 是由点`(i, j, k)`表示的元组 ，其中`i`和`j`之间的距离和`i`和`k`之间的距离相等（需要考虑元组的顺序）

## 184. 螺旋矩阵
* 给你一个`m`行`n`列的矩阵`matrix`，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素

## 185. 合并区间
* 以数组`intervals`表示若干个区间的集合，其中单个区间为`intervals[i] = [starti, endi]`。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间

## 186. 插入区间
* 给你一个 **无重叠的** ，按照区间起始端点排序的区间列表。 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠。如果有必要，可以合并区间

## 187. 通过删除字母匹配到字典里最长单词
* 给你一个字符串`s`和一个字符串数组`dictionary`作为字典，找出并返回字典中最长的字符串，该字符串可以通过删除`s`中的某些字符得到。 如果答案不止一个，返回长度最长且字典序最小的字符串。如果答案不存在，则返回空字符串

## 188. 最后一个单词的长度
* 给你一个字符串`s`，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度

## 189. 螺旋矩阵 II
* 给你一个正整数`n`，生成一个包含`1`到`n2`所有元素，且元素按顺时针顺序螺旋排列的`n x n`正方形矩阵`matrix`

## 190. 排列序列
* 给出集合`[1,2,3,...,n]`，其所有元素共有`n!`种排列。 按大小顺序列出所有排列情况，并一一标记，给定`n`和`k`，返回第`k`个排列

## 191. 旋转链表
* 给你一个链表的头节点`head`，旋转链表，将链表每个节点向右移动`k`个位置

## 192. 恢复二叉搜索树
* 给你二叉搜索树的根节点`root`，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树

## 193. 加一
* 给定一个数组所表示的非负整数，在该数的基础上加一，用数组表示新数字

## 194. 二进制求和
* 给你两个二进制字符串，返回它们的和（用二进制表示）

## 195. x 的平方根
* 给你一个非负整数`x`，计算并返回`x`的 **平方根** ，只保留整数部分

## 196. 寻找峰值
* 峰值元素是指其值严格大于左右相邻值的元素。 给你一个整数数组`nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可

## 197. 有效数字
* 判断是否为有效数字。有效数字可以分成以下几个部分： 一个 **小数** 或者 **整数** ；（可选）一个`'e'`或`'E'`，后面跟着一个 **整数** 。  小数可以分成以下几个部分： （可选）一个符号字符（`'+'`或`'-'`）； 下述格式之一：`"x.x"`,`"x."`,`".x"` 。 整数（按顺序）可以分成以下几个部分：一个符号字符（'+' 或 '-'） ；至少一位数字

## 198. 单词搜索 II
* 给定一个`m x n`二维字符网格`board`和一个单词（字符串）列表`words`，找出所有同时在二维网格和字典中出现的单词。 单词必须按照字母顺序，通过 **相邻的单元格** 内的字母构成。同一个单元格内的字母在一个单词中不允许被重复使用

## 199. 搜索二维矩阵
* 编写一个高效的算法来判断`m x n`矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列； 每行的第一个整数大于前一行的最后一个整数。

## 200. 子集
* 给你一个整数数组`nums`，数组中的元素 **互不相同** 。返回该数组所有可能的子集

## 201. 单词搜索 II
* 给定一个`m x n`二维字符网格`board`和一个单词（字符串）列表`words`，找出所有同时在二维网格和字典中出现的单词。 单词必须按照字母顺序，通过 **相邻的单元格** 内的字母构成，其中 **相邻** 单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用

## 202. 验证回文串
* 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，其他字符忽略，可以忽略字母的大小写

## 203. 相交链表
* 给你两个单链表的头节点，`headA`和`headB`，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回`null`

## 204. 反转链表 II
* 给你单链表的头指针`head`和两个整数`left`和`right`，其中`left <= right`。请你反转从位置`left`到位置`right`的链表节点，返回 **反转后的链表**

## 205. 同构字符串
* 给定两个字符串`s`和`t`，判断它们是否是同构的。 如果`s`中的字符可以按某种映射关系替换得到`t`，那么这两个字符串是同构的。 每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上

## 206. Nim 游戏
* 每一回合，轮到的人拿掉`1 - 3`块石头。 拿掉最后一块石头的人就是获胜者。给定石头总数，判断能否获胜。

## 207. 二叉树的最小深度
* 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量

## 208. 快乐数
* 「快乐数」定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和； 然后重复这个过程直到这个数变为`1`，也可能是 **无限循环** 但始终变不到`1` ；如果可以变为`1`，那么这个数就是快乐数。 判断一个数`n`是不是快乐数

## 209. 差的绝对值为 K 的数对数目
* 给你一个整数数组`nums`和一个整数`k`，请你返回数对`(i, j)`的数目，满足`i < j`且`|nums[i] - nums[j]| == k`

## 210. 从双倍数组中还原原数组
* 一个整数数组`original`可以转变成一个 **双倍数组** `changed`，转变方式为将`original`中每个元素值乘以`2`加入数组中，然后将所有元素 **随机打乱**。 给你一个数组`changed`，如果`change`是 **双倍** 数组，那么请你返回`original`数组，否则请返回空数组。`original`的元素可以以 **任意** 顺序返回

## 211. 执行操作后的变量值
* `"++X"`和`"X++"`使变量`X`的值加`1`；`"--X"`和`"X--"`使变量`X`的值减`1`。`X`的初值是`0`，给你一个由操作组成的字符串数组`operations`，返回执行所有操作后`X`的值

## 212. 数组美丽值求和
* 给你一个下标从`0`开始的整数数组`nums`。对于每个下标`i`，`nums[i]`的 **美丽值** 等于：`2`：对于所有`0 <= j < i`且`i < k <= nums.length - 1`，满足`nums[j] < nums[i] < nums[k]`；`1`：如果满足`nums[i - 1] < nums[i] < nums[i + 1]`，且不满足前面的条件。`0`：如果上述条件全部不满足。返回符合`1 <= i <= nums.length - 2`的所有`nums[i]`的 **美丽值** 的总和

## 213. 检测正方形
* 给你一个平面上的点构成的数据流。设计一个满足下述要求的算法： 1.添加 **一个在数据流中的新点** 到某个数据结构中。可以添加 **重复** 的点，并会视作不同的点进行处理； 2.给你一个查询点，请你从数据结构中选出三个点，使这三个点和查询点一同构成一个 **面积为正*8 的 **轴对齐正方形** ，统计 **满足该要求的方案数目**。实现一个满足要求的类

## 214. 只有两个键的键盘
* 最初只有一个字符`'A'`。你每次可以进行两种操作： 复制所有字符；粘贴 **上一次** 复制的字符。 给你一个数字`n`，返回能够打印出`n`个`'A'`的最少操作次数

## 215. 最长递增子序列的个数
* 给定一个未排序的整数数组，找到最长递增子序列的个数

## 216. 颜色分类
* 一共`n`个元素的数组，原地对它们进行排序，使得相同的元素相邻.共有三种元素

## 217. 单词搜索
* 给定一个`m x n`二维字符网格`board`和一个字符串单词`word`。如果`word`存在于网格中，返回`true`；否则，返回`false`

## 218. 删除有序数组中的重复项 II
* 给你一个有序数组`nums`，请你 **原地** 删除重复出现的元素，使每个元素 **最多出现两次** ，返回删除后数组的新长度

## 219. 分隔链表
* 给你一个链表的头节点`head`和一个特定值`x`，请你对链表进行分隔，使得所有 **小于** `x`的节点都出现在 **大于或等于** `x`的节点之前

## 220. 格雷编码
* 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。 给定一个代表编码总位数的非负整数`n`，打印其格雷编码序列的一种。格雷编码序列必须以 0 开头

## 221. 简化路径
* **路径表示**：一个点`"."`表示当前目录本身；两个点`".."`表示将目录切换到上一级；任意多个连续的斜杠`"/"*n`都被视为单个斜杠`"/"`。**规范路径** 遵循下述格式： 始终以斜杠`"/"`开头； 目录名之间有一个斜杠`"/"`； 除根目录外，不能以`"/"`结尾； 不含`"."`或`".."`。请将`path`转化为规范路径

## 222. 分隔链表
* 给你一个头结点为`head`的单链表和一个整数`k`，请你设计一个算法将链表分隔为`k`个连续的部分，返回一个由上述`k`部分组成的数组

## 223. 存在重复元素 II
* 给定一个整数数组和一个整数`k`，判断数组中是否存在两个不同的索引`i`和`j`，使得`nums [i] = nums [j]`，并且`abs(i - j) <= k`

## 224. 存在重复元素 III
* 给你一个整数数组`nums`和两个整数`k`和`t`。请你判断是否存在两个 **不同** 下标`i`和`j`，使得`abs(nums[i] - nums[j]) <= t`，同时又满足`abs(i - j) <= k`

## 225. 4的幂
* 给定一个整数，写一个函数来判断它是否是`4`的幂次方

## 226. 3的幂
* 给定一个整数，写一个函数来判断它是否是`3`的幂次方

## 227. 笨阶乘
* 笨阶乘：在整数的递减序列中，我们按操作符顺序`*，//，+，-`来依次计算，注意计算遵守乘法优先。`7*6//5+4-3*2//1`中结果是`8+4-6`

## 228. 阶乘后的零
* 给定一个整数`n`，返回`n!`结果中尾随零的数量

## 229. 扁平化多级双向链表
* 多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构。请你扁平化列表，使所有结点出现在单级双链表中

## 230. H 指数
* 给你一个整数数组`citations`，研究者的各论文论文被引用的次数。若有`h`篇论文分别被引用了至少`h`次。且其余的`n - h`篇论文每篇被引用次数不超过`h`次，则`h`为 **H指数**。根据`citations`求 **h指数**

## 231. H 指数 II
* 给你一个升序排列的整数数组`citations`，研究者的各论文论文被引用的次数。若有`h`篇论文分别被引用了至少`h`次。且其余的`n - h`篇论文每篇被引用次数不超过`h`次，则`h`为 **H指数**。根据`citations`求 **h指数**

## 232. 两个字符串的删除操作
* 给定两个单词`word1`和`word2`，找到使得`word1`和`word2`相同所需的最小步数，每步可以删除任意一个字符串中的一个字符

## 233. 交错字符串
* 给定三个字符串`s1`、`s2`、`s3`，请你帮忙验证`s3`是否是由`s1`和`s2` **交错** 组成的。交错指的是`s1`、`s2`按照原有顺序互相插入

## 234. 两整数之和
* 给你两个整数`a`和`b`，不使用运算符`+`和`-`，计算并返回两整数之和

## 235. 解码方法 II
* `'A' -> 1 , 'B' -> 2 , ...  'Z' -> 26 '*' -> 任何数字`.给你一个 **非空** 字符串`s`,请计算并返回 **解码** 方法的 **总数**

## 236. 复原 IP 地址
* 给定一个只包含数字的字符串，用以表示一个`IP`地址，返回所有可能从`s`获得的 有效`IP`地址 。你可以按任何顺序返回答案

## 237. 搜索旋转排序数组 II
* 一个按非降序数组`nums`，在某个下标`k`上进行了 **旋转** ，使数组变为`[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`。给你 **旋转后** 的数组`nums`和一个整数`target`，判断给定的目标值是否存在于数组中。

## 238. 路径总和 II
* 给你二叉树的根节点`root`和一个整数目标和`targetSum`，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径

## 239. 路径总和 III
* 给定一个二叉树的根节点`root`，和一个整数`targetSum`，求该二叉树里节点值之和等于`targetSum`的 **路径** 的数目。 **路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的

## 240. 超级洗衣机
* 有`n`台洗衣机放在同一排上。开始的时候，每台洗衣机内可能为空或者有一定量的衣服。 在每一步操作中，选择任意`m`台洗衣机，将其中每台洗衣机的一件衣服送到相邻的一台洗衣机。 给定一个整数数组`machines`代表每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的 **最少的操作步数** 。

## 241. 矩形面积
* 给你平面上两个 **平正矩形** ，请你计算并返回两个矩形覆盖的总面积。 每个矩形由其 **左下** 顶点和 **右上** 顶点坐标表示

## 242. 猜数字游戏
* 一个数字`secret`，每猜测一次就得到一个提示，告诉猜测数字中有多少位属于数字和确切位置都猜对了，称为`A`，有多少位属于数字猜对了但是位置不对，称为`A`。根据秘密数字和朋友的猜测数返回提示

## 243. 除自身以外数组的乘积
* 给你一个长度为`n`的整数数组`nums`，其中`n > 1`，返回输出数组`output`，其中`output[i]`等于`nums`中除`nums[i]`之外其余各元素的乘积

## 244. 猜数字大小
* `1`到`n`随机选择一个数字`pick`由你猜。提供`guess`接口，输入猜测的数字`nums`。`pick < num`则返回`-1`；`pick > num`则返回`1`；`pick = num`则返回`0`；

## 245. 两个数组的交集
* 给定两个数组，编写一个函数来计算它们的交集

## 246. 有效的完全平方数
* 判断给定的`n`是否是完全平方数

## 247. 字符串解码
* 编码规则为: `k[encoded_string]`，表示其中方括号内部的`encoded_string`正好重复`k`次。给定一个经过编码的字符串，返回它解码后的字符串

## 248. 回文链表
* 给你一个单链表的头节点`head`，请你判断该链表是否为回文链表。

## 249. 旅行终点站
* 线路图中的旅行线路用数组`paths`表示，其中`paths[i] = [cityAi, cityBi]`表示该线路将会从`cityAi`直接前往`cityBi`。请你找出这次旅行的终点站

## 250. 用队列实现栈
* 使用两个队列实现一个栈，并支持普通栈的全部四种操作`push top pop empty`

## 251. 超级次方
* 你的任务是计算`ab`对`1337`取模，`a`是一个正整数，`b`是一个非常大的正整数且会以数组形式给出

## 252. 数字转换为十六进制数
* 数字转换为十六进制数

## 253. 整数替换
* 给定一个正整数`n`，你可以做如下操作：`n`是偶数，则用`n / 2`替换`n`； 如果`n`是奇数，则可以用`n + 1`或`n - 1`替换`n` 。`n`变为`1`所需的最小替换次数是多少

## 254. 石子游戏
* 偶数堆石子排成一行，每堆都有`piles[i] `颗石子。两人轮流从最左或最右取，最后总数多的人胜利。

## 255. 将一维数组转变成二维数组
* 给你一个下标从`0`开始的一维整数数组`original`和两个整数`m`和`n`。你需要使用`original`中 **所有** 元素创建一个`m`行`n`列的二维数组

## 256. 连接后等于目标字符串的字符串对
* 给你一个数字字符串数组`nums`和一个字符串`target`，请你返回`nums[i] + nums[j]`结果等于`target`的下标`(i, j)`（需满足`i != j`）的数目

## 257. 最大连续1的个数 III
* 给定一个由若干`0`和`1`组成的数组`A`，我们最多可以将`K`个值从`0`变成`1`。返回仅包含`1`的最长 **连续** 子数组的长度

## 258. 考试的最大困扰度
* 给你一个字符串`answerKey`，其中`answerKey[i]`是第`i`个问题的正确结果。再给你一个整数`k`，表示你能进行操作的最多次数：每次操作中，将`answerKey[i]`改为`'T'`或者`'F'`。 返回在不超过`k`次操作的情况下，最大 **连续** `'T'`或者`'F'`的数目

## 259. 分数到小数
* 给定两个整数，分别表示分子`numerator`和分母`denominator`，以字符串形式返回小数 。 如果小数部分为循环小数，则将循环的部分括在括号内

## 260. 转换字符串的最少操作次数
* 给你一个字符串`s`只由`"X"`、`"O"`构成。 **操作** 指从`s`中选出 **三个连续字符** 并将选中的每个字符都转换为`'O'`。求将`s`中所有字符均转换为`'O'`需要执行的 **最少** 操作次数

## 261. 找出缺失的观测数据
* 一份`n + m`次投掷单个骰子的观测数据，骰子的每个面从`1`到`6`编号。数据中缺失了`n`份，`rolls`为剩余的数据。`mean`为`n + m`次投掷数据的 **平均值** ，返回一个长度为`n`的数组，包含所有缺失的观测数据。

## 262. 石子游戏 IX
* `n`个石子，整数数组`stones`的`stones[i]`是第`i`个石子的价值。A和B轮流进行自己的回合，A先手。每一回合，从`stones`中移除任一石子。如果玩家移除石子后， **已移除石子** 的价值的 **总和** 可以被`3`整除，那么该玩家就输；如果移除后没有任何剩余的石子，那么B将会直接获胜。 假设两位玩家均采用最佳决策,判断胜者。

## 263. 密钥格式化
* 有一个字符串`S`，只包含字母、数字以及`'-'`。给你一个数字 K，请重新格式化字符串，使每个分组恰好包含`K`个字符，特别地，第一个分组包含的字符个数小于等于`K`，但至少要包含`1`个字符。用`'-'`（破折号）隔开分组，并且将所有的小写字母转换为大写字母。

## 264. 提莫攻击
* 给出A对B的攻击时刻序列和A攻击的中毒持续时间，考虑中毒效果的覆盖，输出B的中毒状态总时长

## 265. 火柴拼正方形
* 输入为数组`matchsticks`，第i根火柴长度为`matchsticks[i]`。输出即为是否能用所有的火柴拼成正方形

## 266. 窥探迭代器
* 设计一个迭代器，除了支持`hasNext`和`next`操作外，还支持`peek`操作。`init`：利用给定的`iteration`初始化。`peek`：获取下一个元素，不移动指针。`next`：获取下一个元素，并移动指针。

## 267. 删除排序链表中的重复元素 II
* 存在一个按升序排列的链表，给你这个链表的头节点`head`，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 **没有重复出现** 的数字

## 268. 逆波兰表达式求值
* 根据 **逆波兰表示法**，求表达式的值

## 269. 第三大的数
* 给你一个非空数组，返回此数组中 **第三大的数** 。如果不存在，则返回数组中最大的数

## 270. 汇总区间
* 给定一个无重复元素的有序整数数组`nums`。 返回 **恰好覆盖数组中所有数字** 的区间范围列表。`"a->b"`，如果`a != b`；`"a"`，如果`a == b`

## 271. 岛屿数量
* 给你一个由`'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量

## 272. 组合总和 III
* 找出所有相加之和为`n`的`k`个数的组合。组合中只允许含有`1 - 9`的正整数，并且每种组合中不存在重复的数字

## 273. 字符串中的单词数
* 统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符

## 274. 从前序与中序遍历序列构造二叉树
* 给定一棵树的前序遍历`preorder`与中序遍历`inorder`。请构造二叉树并返回其根节点

## 275. 重复的DNA序列
* 找出所有目标子串，目标子串的长度为`10`，且在字符串`s`中出现次数超过一次

## 276. 二叉树展开为链表
* 给你二叉树的根结点`root`，请你将它展开为一个单链表： 展开后的单链表应该同样使用`TreeNode`，其中`right`子指针指向链表中下一个结点，而左子指针始终为`null`； 展开后的单链表应该与二叉树 **先序遍历** 顺序相同

## 277. 将数据流变为多个不相交区间
* 实现`SummaryRanges`类：`SummaryRanges()`使用一个空数据流初始化对象；`void addNum(int val)`向数据流中加入整数`val`；`int[][] getIntervals()`以不相交区间`[starti, endi]`的列表形式返回对数据流

## 278. 二叉树的锯齿形层序遍历
* 给定一个二叉树，返回其节点值的锯齿形层序遍历。即先从左往右，再从右往左进行下一层遍历，以此类推

## 279. 将有序数组转换为二叉搜索树
* 给你一个整数数组`nums`，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树

## 280. 至少在两个数组中出现的值
* 给你三个整数数组`nums1`、`nums2`和`nums3`，请你构造并返回一个 **不同** 数组，且由 **至少** 在 **两个** 数组中出现的所有值组成

## 281. 获取单值网格的最小操作数
* 给你一个大小为`m x n`的二维整数网格`grid`和一个整数`x`。每一次操作，你可以对`grid`中的任一元素加`x`或减`x`。**单值网格** 是全部元素都相等的网格。 返回使网格化为单值网格所需的 **最小** 操作数

## 282. 排列硬币
* 有`n`枚硬币，将它们按阶梯状排列。对于一个`k`行的阶梯，其第`i`行必须正好有`i`枚硬币。阶梯的最后一行 **可能** 是不完整的。 给你一个数字`n`，计算并返回可形成 **完整的**总行数

## 283. 整数转换英文表示
* 将非负整数`num`转换为其对应的英文表示

## 284. 对链表进行插入排序
* 对链表进行插入排序

## 285. 二叉树的右视图
* 给定一个二叉树的根节点`root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值

## 286. 最长连续序列
* 给定一个未排序的整数数组`nums`，找出数字连续的最长序列的长度

## 287. 求根节点到叶节点数字之和
* 给你一个二叉树的根节点`root`，树中每个节点都存放有一个`0`到`9`之间的数字。 每条从根节点到叶节点的路径都代表一个数字： 例如，从根节点到叶节点的路径`1 -> 2 -> 3`表示数字`123`。 计算从根节点到叶节点生成的数字之和

## 288. 二叉树的最近公共祖先
* 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先

## 289. 删除指定节点
* 在未给定`head`的前提下删除指定节点

## 290. 求众数 II
* 给定一个大小为`n`的整数数组，找出其中所有出现超过`n//3`次的元素

## 291. 分割回文串
* 给你一个字符串`s`，请你将`s`分割成一些子串，使每个子串都是 **回文串** 。返回`s`所有可能的分割方案

## 292. 分割回文串 II
* 给你一个字符串`s`，请你将`s`分割成一些子串，使每个子串都是回文。 返回符合要求的最少分割次数

## 293. 山峰数组的顶部
* 给定由整数组成的山峰形数组`arr`，求山峰的`index`

## 294. 被围绕的区域
* 给你一个`m x n`的矩阵`board`，由若干字符`'X'`和`'O'`，找到所有被`'X'`围绕的区域，并将这些区域里所有的`'O'`用`'X'`填充

## 295. 找不同
* 字符串`t`由字符串`s`随机重排，然后在随机位置添加一个字母。请找出在`t`中被添加的字母

## 296. 翻转字符串里的单词
* 给你一个字符串 s ，逐个翻转字符串中的所有 单词 

## 297. 向下的路径节点之和
* 给定一个二叉树的根节点`root`，和一个整数`targetSum`，求该二叉树里节点值之和等于`targetSum`的 **路径** 的数目。 **路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的

## 298. 二叉树的坡度
* 给定一个二叉树，计算树的坡度和 。 一个节点的 **坡度** 定义即为，该节点左子树的节点之和和右子树节点之和的 **差的绝对值** 

## 299. 给表达式添加运算符
* 给定一个仅包含数字`0-9`的字符串`num`和一个目标值整数`target`，在`num`的数字之间添加运算符`+、-、*`，返回所有能够得到目标值的表达式

## 300. 打乱数组
* 给定一个没有重复元素的数组`nums`，设计算法来随机打乱该数组。实现`Solution`。`Solution(int[] nums)`：使用整数数组`nums`初始化对象；`int[] reset()`：重设数组到它的初始状态并返回；`int[] shuffle()`：返回数组随机打乱后的结果

## 301. 使每位学生都有座位的最少移动次数
* 有`n`个座位和`n`名学生，数组`seats`，其中`seats[i]`是第`i`个座位的位置。数组`students`，其中`students[j]`是第`j`位学生的位置。 执行以下操作： 第`i`位学生从位置`x`移动到`x + 1`或者`x - 1`。 请你返回使所有学生都有座位坐的最少移动次数

## 302. 如果相邻两个颜色均相同则删除当前颜色
* 给你一个长度为`n`的字符串`colors`，其中要么是`'A'`要么是`'B'`，其中`colors[i]`表示第`i`个片段。如果一个片段为`'A'`且相邻两个都是`'A'`，那么A可以删除该颜色片段。同理B可以用同样的方式处理`"B"`。如果一人无法继续操作，则该玩家 **输** 。判断胜负

## 303. 网络空闲的时刻
* 一个有`n`个服务器的计算机网络，服务器编号为`0`到`n - 1`。同时给你一个二维整数数组`edges`，其中`edges[i] = [ui, vi]`表示服务器`ui`和`vi`之间有一条信息线路，它们之间可以在一秒内传输信息。 编号为`0`的服务器是 **主服务器**，其他服务器为 **数据服务器**。每个数据服务器向主服务器发送信息，并等待回复。信息在服务器之间按 **最优** 线路传输。主服务器会处理所有新到达的信息并 **立即** 反方向回复信息。 在`0`秒的开始，数据服务器都发送信息。 从第`1`秒开始，每秒每个数据服务器都会检查是否收到了主服务器的回复信息： 如果还没收到，数据服务器`i`每`patience[i]`秒都会重发一条信息。 请返回计算机网络变为 **没有任何信息在线路上传输或者到达某服务器** 状态的 **最早秒数**

## 304. 二叉搜索树中第K小的元素
* 给定一个二叉搜索树的根节点`root`，和一个整数`k`，请你设计一个算法查找其中第`k`个最小元素

## 305. 检查句子中的数字是否递增
* 句子是由若干`token`组成的一个列表，`token`间用空格分隔。每个`token`要么是正整数 ，要么是单词。检查由若干`token`组成的`s`中的数字是否从左到右严格递增 

## 306. 简易银行系统
* 实现`Bank`类：`Bank(long[] balance)`使用下标从`0`开始的整数数组`balance`初始化该对象；`boolean transfer(int account1, int account2, long money)`从编号为`account1`的账户向编号为`account2`的账户转帐`money`美元；`boolean deposit(int account, long money)`向编号为`account`的账户存款`money`美元。如果交易成功，返回`true`；否则，返回`false`；`boolean withdraw(int account, long money)`从编号为`account`的账户取款`money`美元。如果交易成功，返回`true`；否则，返回`false`。返回从节点`1`到节点`n`需要的 **第二短时间**

## 307. 统计按位或能得到最大值的子集数目
* 给你一个整数数组`nums`，请你找出`nums`子集 **按位或** 可能得到的 **最大值** ，并返回按位或能得到最大值的 **不同非空子集的数目**

## 308. 到达目的地的第二短时间
* 城市用一个`n`个节点的 **双向连通** 图表示。边用一个二维整数数组`edges`表示。穿过任意一条边的时间是`time`分钟。 每个节点都有一个交通信号灯，每`change`分钟改变一次，从绿色变成红色再变成绿色，循环往复。所有信号灯都同时改变。只能在节点 **信号灯是绿色时** 才能离开

## 309. 数字的补数
* 对整数`num`的二进制表示取反（`0`变`1` ，`1`变`0`）后，再转换为十进制表示，得到这个整数的补数

## 300. 数字的补数
* (本题同309)对整数`n`的二进制表示取反（`0`变`1` ，`1`变`0`）后，再转换为十进制表示，得到这个整数的补数

## 311. 省份数量
* 有`n`个城市，其中一些彼此相连。省份是一组 **直接或间接** 相连的城市。给定一个`n x n`的矩阵`isConnected`，其中`isConnected[i][j]`表示第`i`个城市和第`j`个城市是否直接相连。连返回矩阵中 省份 的数量

## 312. 除法求值
* `equations`和`values`作为已知条件，其中`equations[i] = [Ai, Bi]`和`values[i]`共同表示等式`Ai / Bi = values[i]`。`queries`表示的问题，其中`queries[j] = [Cj, Dj]`表示第`j`个问题，请你根据已知条件找出`Cj / Dj`的结果作为答案。如果存在某个无法确定的答案，则用`-1.0`替代这个答案

## 313. 添加与搜索单词 - 数据结构设计
* 实现词典类`WordDictionary`：`WordDictionary()`初始化词典对象；`void addWord(word)`将`word`添加到数据结构中，之后可以对它进行匹配；`bool search(word)`如果数据结构中存在字符串与`word`匹配，则返回`true`；否则，返回`false`。`word`中可能包含一些`'.'`，每个`'.'`都可以表示任何一个字母。

## 314. 最小操作次数使数组元素相等
* 给你一个长度为`n`的整数数组，每次操作将会使`n - 1`个元素增加`1`。返回让数组所有元素相等的最小操作次数

## 315. 重排链表
* 给定一个单链表`L`的头节点`head`，单链表`L`表示为：`0,1,2,3...n`。重排为`0,n,1,n-1`

## 316. 二叉树的层序遍历 II
* 给定一个二叉树，返回其节点值自底向上的层序遍历

## 317. 层数最深叶子节点的和
* 给你一棵二叉树的根节点`root`，请你返回 层数最深的叶子节点的和 

## 318. 最大层内元素和
* 给你一个二叉树的根节点`root`。设根节点位于二叉树的第`1`层，而根节点的子节点位于第`2`层，依此类推。 请你找出层内元素之和 **最大** 的那几层的层号，并返回其中 **最小** 的那个

## 319. 二叉树的层平均值
* 给定一个非空二叉树, 返回一个由每层节点平均值组成的数组

## 320. N 叉树的层序遍历
* 给定一个`N`叉树，返回其节点值的层序遍历。

## 321. 二叉树每层的最大值
* 给定一棵二叉树的根节点`root`，请找出该二叉树中每一层的最大值

## 322. 二叉树中的最大路径和
* 给你一个二叉树的根节点`root`，返回其 **最大路径和**

## 323. 填充每个节点的下一个右侧节点指针 II
* 填充它的每个`next`指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将`next`指针设置为`NULL`

## 324. 平衡二叉树
* 给定一个二叉树，判断它是否是高度平衡的二叉树

## 325. 数青蛙
* 给你一个字符串`croakOfFrogs`表示蛙鸣，同一时间可以有多只青蛙呱呱作响，所以`croakOfFrogs`中会混合多个`“croak”`。 依序输出`"croak"`视为一次发声。 如`croakOfFrogs`不是有效的，请返回`-1`。请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。

## 326. 构造矩形
* 面积`L*W`等于给定的`area`；`L >= W`；`L`和`W`之间的差距应当尽可能小。 按顺序输出长度`L`和宽度`W`

## 327. 克隆图
* 给你无向连通图中一个节点的引用，请你返回该图的 **深拷贝**

## 328. 课程表
* 选修`numCourses`门课程。 先修课程关系数组`prerequisites`给出，其中`prerequisites[i] = [ai, bi]`，表示学习课程`ai`则必须先学习`bi`。判断能否修完课程

## 329. 寻找重复数
* 给定一个包含`n + 1`个整数的数组`nums`，其数字都在`1`到`n`之间，`nums`只有一个重复的整数 ，找出这个重复的数 

## 330. 丑数
* 丑数就是只包含质因数`2 3 5`的正整数。请你判断`n`是否为丑数

## 331. 丢失的数字
* 给定一个包含`[0, n]`中`n`个数的数组`nums`，找出`[0, n]`这个范围内没有出现在数组中的那个数

## 332. 唯一元素的和
* 请你返回`nums`中唯一元素的和

## 333. 大礼包
* 整数数组`price`中`price[i]`是第`i`件物品的价格。整数数组`needs`中`needs[i]`是需要第`i`件物品的数量。数组`special`表示大礼包，`special[i]`中`special[i][j]`表示第`i`个大礼包中内含第`j`件物品的数量，且`special[i][n]`为大礼包的价格

## 334. 句子中的有效单词数
* 句子仅由小写字母、数字、`'-'`、`'!' '.' ','`以及空格组成。每个句子可以分解成若干由一个或者多个空格分隔的`token`。满足下述条件的`token`是一个有效单词： 至多一个`'-'`，且连字符两侧应当都存在小写字母； 至多一个`'!' '.' ','`，且位于`token`的末尾。返回`sentence`中有效单词的数目

## 335. 下一个更大的数值平衡数 
* 对于数字`x`每个数位`d`，这个数位恰好 在`x`中出现`d`次。那么整数`x`就是一个 **数值平衡数** 。 给你一个整数`n`，请你返回大于`n`的最小数值平衡数

## 336. 统计最高分的节点数目
* 给你一棵根节点为`0`的二叉树，总共有`n`个节点。整数数组`parents`表示这棵树，其中`parents[i]`是节点`i`的父节点。若将这个节点和删除，剩余部分是若干个 **非空** 树，所有这些树大小的乘积为该节点分数。请你返回有 **最高得分** 节点的 **数目**

## 337. 并行课程 III
* 所有课程编号从`1`到`n`。二维整数数组`relations`中`relations[j] = [prevCoursej, nextCoursej]`，表示课程`prevCoursej`必须在课程`nextCoursej`之前。整数数组`time`中`time[i]`表示完成第`(i+1)`课程需要花费的时间。你可以同时上 **任意** 课程 。 请你返回完成所有课程所需要的 **最少** 时间

## 338. 搜索二维矩阵 II
* 该矩阵每行的元素从左到右升序排列，每列的元素从上到下升序排列。 搜索`m x n`矩阵`matrix`中的一个目标值`target`。

## 339. 二维网格迁移
* 给`m`行`n`列的二维网格`grid`和整数`k`。「迁移」操作：位于`grid[i][j]`的元素将会移动到`grid[i][j + 1]`； 位于`grid[i][n - 1]`的元素将会移动到`grid[i + 1][0]`； 位于`grid[m - 1][n - 1]`的元素将会移动到`grid[0][0]`。返回`k`次迁移操作后的二维网格

## 340. 不同的二叉搜索树 II
* 给你一个整数`n`，请你生成并返回所有由`n`个节点组成且节点值从`1`到`n`的不同的二叉搜索树

## 341. 递增子序列
* 给你一个整数数组`nums`，找出并返回所有该数组中不同的 **非严格递增** 子序列，递增子序列中 **至少有两个元素** 。按任意顺序返回答案

## 342. 下一个更大元素 I
* 给你两个都 **没有重复元素** 的数组`nums1`和`nums2`，其中`nums1`是`nums2`的子集。 请你找出`nums1`中每个元素在`nums2`中的下一个比其大的值

## 343. 实现 Trie (前缀树)
* 请你实现`Trie`类：`Trie()`初始化；`void insert(String word)`向前缀树中插入字符串`word`；`boolean search(String word)`字符串`word`是否在前缀树中；`boolean startsWith(String prefix)`之前已经插入的字符串中是否存在`word`，其前缀为`prefix` ；

## 344. 课程表 II
* 选修`numCourses`门课程。 先修课程关系数组`prerequisites`给出，其中`prerequisites[i] = [ai, bi]`，表示学习课程`ai`则必须先学习`bi`。返回你为了学完所有课程所安排的学习顺序

## 345. 生命游戏
* 有`m × n`个细胞的面板，每个细胞`1`为活，`0`为死。每个细胞与其八个相邻位置的细胞都遵循以下： 活细胞周围八个位置的活细胞数少于`2`或超过`3`，则该活细胞死亡； 如果死细胞周围正好有`3`个活细胞，则该位置死细胞复活。返回下一个状态

## 346. 删除无效的括号
* 给你一个由若干括号和字母组成的字符串`s`，删除最小数量的无效括号，使得输入的字符串有效

## 347. 重新排序得到 2 的幂
* 给定一个数字`n`，判断其经过排列能否得到`2`的幂

## 348. 从中序与后序遍历序列构造二叉树
* 根据一棵树的中序遍历与后序遍历构造二叉树

## 349. 完全二叉树的节点个数
* 给你一棵完全二叉树的根节点`root`，求出该树的节点个数

## 350. 根据前序和后序遍历构造二叉树
* 根据前序和后序遍历构造任意一个符合条件的二叉树

## 351. 路径交叉
* 给一个整数数组`distance`。 从点`(0,0)`开始，先向上移动进行逆时针移动，每次移动`distance[i]`。判断是否交叉

## 352. 只出现一次的数字 III
* 给定一个整数数组`nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素

## 353. 数组中第 K 个独一无二的字符串
* 一个字符串数组`arr`和一个整数`k`，请你返回`arr`中第`k`个 独一无二的字符串 

## 354. 两个最好的不重叠活动
* `events`中`events[i] = [startTimei, endTimei, valuei]`表示第`i`个活动开始于`startTimei`，结束于`endTimei`，有`valuei`奖励。 **最多** 参加两个时间不重叠的活动，返回最大总奖励

## 355. 蜡烛之间的盘子
* 字符串`s`，它只包含字符`'*'`和`'|'`。数组`queries`，其中`queries[i] = [lefti, righti]`表示`s[lefti...righti]`中在两支`'|'`间的`'*'`的数目

## 356. 值相等的最小索引
* 返回`nums`中满足`i%10 == nums[i]`的最小下标`i`

## 357. 找出临界点之间的最小和最大距离
* 临界点定义为一个 **局部极大值点** 或 **局部极小值点** 。返回两个临界点之间的最小距离和最大距离。

## 358. 找出临界点之间的最小和最大距离
* `x`的值最开始设为`start`，可以按任意顺序任意次数使用每个`nums[i]`任意次，对当前`x`进行`+ - ^`，使之到达`goal`。返回所需最小步骤

## 359. 键盘行
* 给你一个字符串数组`words`，只返回可以使用键盘同一行的字母打印出来的单词

## 360. 分糖果
* 给整数数组`candyType`描述糖果类型，返回在仅吃掉`n / 2`枚糖的情况下，可以吃到糖的最多种类数

## 361. 为运算表达式设计优先级
* 给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果

## 362. 修剪二叉搜索树
* 给你二叉搜索树的根节点`root`，同时给定最小边界`low`和最大边界`high`。修剪二叉搜索树，使得所有节点的值在`[low, high]`。

## 363. 最小覆盖子串
* 个字符串`s`、一个字符串`t`。返回`s`中涵盖`t`所有字符的最小子串

## 364. 字典序排数
* 给你一个整数`n`，按字典序返回范围`[1, n]`内所有整数

## 365. 接雨水 II
* 给你一个`m x n`的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水

## 366. 设计链表
* 在链表类中实现这些功能：`get(index)`：获取链表中第`index`个节点的值。如果索引无效，则返回`-1`；`addAtHead(val)`：在链表的第一个元素之前添加一个值为`val`的节点。插入后，新节点将成为链表的第一个节点；`addAtTail(val)`：将值为`val`的节点追加到链表的最后一个元素；`addAtIndex(index,val)`：在链表中的第`index`个节点之前添加值为`val` 的节点。如果`index`等于链表的长度，则该节点将附加到链表的末尾。如果`index`大于链表长度，则不会插入节点。如果`index`小于`0`，则在头部插入节点；`deleteAtIndex(index)`：如果索引`index`有效，则删除链表中的第`index`个节点。

## 367. 出租车的最大盈利
* 一条有`n`个地点的路上。你想只前进地从`1`开到`n`，`rides`中`rides[i] = [starti, endi, tipi]`表示第`i`位乘客从地点`starti`前往`endi`，支付`tipi`元的小费与`starti - endi`的车费。返回在最优接单方案下的盈利

## 368. 最长定差子序列
* 给你一个整数数组`arr`和一个整数`difference`，请你找出并返回`arr`中最长的以`difference`为公差的等差子序列的长度

## 369. 递增的三元子序列
* 给你一个整数数组`nums`，判断这个数组中是否存在长度为`3`的递增子序列

## 370. 最大整除子集
* 给你一个由 无重复 正整数组成的集合`nums`，请你找出并返回其中最大的整除子集`answer`，子集中每一元素对`(answer[i], answer[j])`都应当满足`answer[i] % answer[j] == 0`或`answer[j] % answer[i] == 0`

## 371. 股票价格波动
* 请你设计一个算法，实现： 更新股票在某一时间的价格； 找到当前记录里 **最新股票价格** ； 找到当前记录里股票的`最高价格`； 找到当前记录里股票的`最低价格`

## 372. 打家劫舍 III
* 所有房屋的排列类似于一棵二叉树。 如果两个直接相连的房子在被打劫，房屋将报警。 计算在不触动警报的情况下，能够盗取的最高金额

## 373. 范围求和 II
* 给定一个全部为`0`，大小为`m*n`的矩阵，其每个操作用一个含有两个正整数`a`和`b`的数组表示，含义是将所有`0 <= i < a`以及`0 <= j < b`的元素`M[i][j]`的值都增加`1`。 在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数

## 374. 求平方根
* 给定一个非负整数`x`，计算并返回`x`的平方根

## 375. 目标和
* 一个整数数组`nums`和一个整数`target`。 每个整数前添加`'+'`或`'-'`，然后串联成表达式。 结果等于`target`的不同表达式的数目

## 376. 所有子集
* 给定一个整数数组`nums`，数组中的元素互不相同 。返回该数组所有可能的子集

## 377. 含有 k 个元素的组合
* 给定两个整数`n`和`k`，返回`1 ... n`中所有可能的`k`个数的组合

## 378. 合并区间
* 以数组`intervals`表示若干个区间的集合，其中单个区间为`intervals[i] = [starti, endi]`。请你合并所有重叠的区间，并返回一个不重叠的区间数组

## 379. 单词长度的最大乘积
* 给定一个字符串数组`words`，请计算当两个字符串`words[i]`和`words[j]`不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母

## 380. 数组中和为 0 的三个数
* 给定一个包含`n`个整数的数组`nums`，请找出所有和为`0`且不重复的三元组

## 381. 删除链表中的节点
* 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点`head`，只能直接访问 要被删除的节点

## 382. 祖玛游戏
* 桌面上有一列球，每个球可能是：'R'`、`'Y'`、`'B'`、`'G'`或`'W'`。你的手中也有一样的球。每一回合从你手上的球中选出一颗插入桌面上的一列球中，如果有三个或以上颜色相同的球相连，就把它们移除掉。重复这个过程，直到你清空场上的球获胜或者手中没有更多的球。返回获胜所用的球数

## 383. 数组中重复的数字
* 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。找出数组中重复的数字。

## 384. 二维数组中的查找
* 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请判断数组中是否含有某整数。

## 385. 替换空格
* 把字符串`s`中的每个空格替换成`"%20"`

## 386. 从尾到头打印链表
* 输入一个链表的头节点，从尾到头反过来返回每个节点的值

## 387. 重建二叉树
* 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点

## 388. 用两个栈实现队列
* 用两个栈实现一个队列

## 389. 矩阵中的路径
* 给定一个`m x n`二维字符网格`board`和一个字符串单词`word`，判断单词能否按照字母顺序，通过相邻的单元格内的字母构成。

## 390. K个逆序对数组
* 给出两个整数`n`和`k`，找出所有包含从`1`到`n`的数字，且恰好拥有`k`个逆序对的不同的数组的个数

## 391. 猜数字大小 II
* `1`到`n`之间猜数字，当你猜了数字`x`并且猜错了的时候，你需要支付金额为`x`的现金。返回能够 **确保你获胜** 的 **最小** 现金数

## 392. 环形链表 II
* 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回`null`

## 393. 排序链表
* 给你链表的头结点`head`，返回升序排序后的链表

## 394. 检查两个字符串是否几乎相等
* 如果两个字符串中每一个字母出现频率之差都不超过`3`，那么它们几乎相等。判断`word1`和`word2`是否几乎相等

## 395. 模拟行走机器人 II
* 实现`Robot`类：`Robot(int width, int height)`初始化一个`width * height`的网格图，机器人初始在`(0, 0)`，方向向左；`void move(int num)`给机器人下达前进`num`步的指令；`int[] getPos()`返回机器人当前所处的格子位置，用`[x, y]`表示；`String getDir()`返回当前机器人的朝向

## 396. 每一个查询的最大美丽值
* 二维整数数组`items`中`items[i] = [pricei, beautyi]`分别表示每一个物品的 **价格** 和 **美丽值**。对于数组`queries`中的`queries[j]`，求出价格小于等于`queries[j]` 的物品中，最大的美丽值

## 397. 检测大写字母
* 给你一个字符串`word`，判断大写用法正确与否，

## 398. 买票需要的时间
* 有 n 个人前来排队买票，数组`tickets`中，第`i`人想要购买的票数为`tickets[i]`。 买票都需要用掉`1`秒 。一个人一次只能买一张票 ，购买更多票，必须走到队尾。如没有剩下需要买的票，那他将会离开。 返回位于位置`k`的人完成买票需要的时间

## 399. 反转偶数长度组的节点
* 给你一个链表的头节点`head`，节点划分成若干组，这些组的长度构成`1, 2, 3, 4, ...`序列。一个组的长度就是组中分配到的节点数目。反转偶数长度组中的节点，并返回修改后链表的头节点`head`

## 400. 解码斜向换位密码
* 字符串`originalText`使用斜向换位密码 ，经由行数固定为`rows`的矩阵辅助，加密得到一个字符串`encodedText`。给定`encodedText`，求`originalText`

## 401. 键值映射
* 实现一个`MapSum`类：`MapSum()`初始化`MapSum`对象；`void insert(String key, int val)`插入键值对，字符串表示键`key`，整数表示值`val`。如果键`key`已经存在，那么原来的键值对将被替代；`int sum(string prefix)`返回所有以该前缀`prefix`开头的键`key`的值的总和。

## 402. 灯泡开关
* 初始时有`n`个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第`i`轮，你每`i`个灯泡就切换一个灯泡的开关，直到第`n`轮。 返回`n`轮后亮着的灯泡的个数

## 403. 机器人的运动范围
* 地上有一个`m*n`列的方格。一人从坐标`[0, 0]`的开始移动，每次可以向左、右、上、下移动一格，也不能进入行坐标和列坐标的数位之和大于k的格子。请问能够到达的格子的个数

## 404. 完美矩形
* 给你一个数组`rectangles`，其中`rectangles[i] = [xi, yi, ai, bi]`表示一个坐标轴平行的矩形，左下顶点是`(xi, yi)`，右上顶点是`(ai, bi)`。 判断所有矩形是否精确覆盖某个矩形区域

## 405. 剪绳子
* 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少

## 406. 剪绳子 II
* 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少

## 407. 数值的整数次方
* 实现`pow(x, n)`，即计算`x`的`n`次幂函数

## 408. 最大单词长度乘积
* 给定字符串数组`words`，找到`length(word[i]) * length(word[j])`的最大值，并且这两个单词不含有公共字母

## 409. 树的子结构
* 输入两棵二叉树A和B，判断B是不是A的子结构

## 410. 栈的压入、弹出序列
* 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序

## 411. 从上到下打印二叉树
* 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印

## 412. 从上到下打印二叉树 II
* 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行

## 413. 从上到下打印二叉树 III
* 请实现一个函数按照之字形顺序打印二叉树

## 414. 青蛙跳台阶问题
* 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个`n`级的台阶总共有多少种跳法

## 415. 寻找旋转排序数组中的最小值
* 已知一个长度为`n`的 **互不相同** 的 **升序** 数组，预先按照升序排列，经由`1`到`n`次 旋转 后，得到`nums`。返回数组中的最小元素

## 416. 寻找旋转排序数组中的最小值 II
* 已知一个长度为`n`的 **可以相同** 的 **升序** 数组，预先按照升序排列，经由`1`到`n`次 旋转 后，得到`nums`。返回数组中的最小元素

## 417. 旋转数组的最小数字
* 已知一个长度为`n`的 **可以相同** 的 **升序** 数组，预先按照升序排列，经由`1`到`n`次 旋转 后，得到`nums`。返回数组中的最小元素

## 418. 最长和谐子序列
* 和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是`1`。给你一个整数数组`nums`，在所有的子序列中找到最长的和谐子序列的长度

## 419. 二叉搜索树的后序遍历序列
* 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果

## 420. 二叉树中和为某一值的路径
* 给你二叉树的根节点`root`和一个整数目标和`targetSum`，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径

## 421. 表示数值的字符串
* 判断是否为有效数字。有效数字可以分成以下几个部分：若干空格 ；一个 **小数** 或者 **整数** ；（可选）一个`'e'`或`'E'`，后面跟着一个 **整数** ；若干空格 。  小数可以分成以下几个部分： （可选）一个符号字符（`'+'`或`'-'`）； 下述格式之一：`"x.x"`,`"x."`,`".x"` 。 整数（按顺序）可以分成以下几个部分：一个符号字符（'+' 或 '-'） ；至少一位数字

## 422. 二叉树的深度
* 求二叉树的深度

## 423. 数组中数字出现的次数
* 一个整型数组`nums`里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字

## 424. N 叉树的最大深度
* 给定一个`N`叉树，找到其深度

## 425. 两栋颜色不同且距离最远的房子
* 街上有`n`栋房子排成一列，给你一个整数数组`colors`，其中`colors[i]`表示第`i`栋房子的颜色。 返回颜色不同房子之间的最大距离。

## 426. 给植物浇水
* 当前植物浇完水之后，如没有足够的水完全浇灌下一株植物，需要返回河边重新装满水罐；你不能提前重新灌满水罐。 给你一个下标从 0 开始的整数数组`plants`，其中，`plants[i]`为第`i`株植物需要的水量。另有整数`capacity`表示水罐容量，返回从左到右浇灌所有植物需要的步数

## 427. 区间内查询数字的频率
* 请你实现`RangeFreqQuery`类：`RangeFreqQuery(int[] arr)`用整数数组`arr`构造一个类的实例；`int query(int left, int right, int value)`返回子数组`arr[left...right]`中`value`的 **频率** 

## 428. 最小基因变化
* 现在给定3个参数`start`,`end`,`bank`，分别代表起始基因序列，目标基因序列及合法基因库，请找出能够使起始基因序列变化为目标基因序列所需的最少变化次数

## 429. 无重叠区间
* 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠

## 430. 寻找右区间
* 给一个区间数组`intervals`，其中`intervals[i] = [starti, endi]`，且每个`starti`都 **不同** 。区间`i`的右侧区间可以记作区间`j`，并满足`startj >= endi`，且`startj`最小化。返回一个由每个区间`i`的右侧区间的位置的数组

## 431. 亲密字符串
* 给你两个字符串`s`和`goal`，只要我们可以通过交换`s`中的两个字母得到与`goal`相等的结果

## 432. 用最少数量的箭引爆气球
* 在坐标`x`处射出一支箭，若气球的直径的开始和结束坐标为`xstart`、`xend`， 且满足`xstart ≤ x ≤ xend`，则该气球会被引爆。给一个数组`points`，其中`points [i] = [xstart,xend]`，返回引爆所有气球的最小弓箭数

## 433. 根据字符出现频率排序
* 给定一个字符串，请将字符串里的字符按照出现的频率降序排列

## 434. 预测赢家
* 两玩家轮流进行自己的回合，玩家1先手。两个玩家的初始分值都是`0`。每一回合，玩家从数组的任意一端取一个数字，取到的数字将会从数组中移除。玩家选中的数字将会加到他的得分。当数组中没有剩余数字可取时，游戏结束，玩家1分数大于等于玩家2则前者胜利。判断游戏结果。

## 435. 和为 K 的子数组
* 给你一个整数数组`nums`和一个整数`k`，请你统计并返回该数组中和为`k`的连续子数组的个数

## 436. 对角线遍历
* 给你一个大小为`m x n`的矩阵`mat`，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素

## 437. 从英文中重建数字
* 给你一个字符串`s`，其中包含字母顺序打乱的用英文单词表示的若干数字（0-9）。按升序返回原始的数字

## 438. UTF-8 编码验证
* 给定一个表示数据的整数数组，返回它是否为有效的utf-8编码

## 439. 可怜的小猪
* 有`buckets`桶液体，其中有一桶含有毒药，其余装的都是水。喂猪的规则如下： 小猪同时饮用任意数量的桶中的水； 小猪喝完水后有`minutesToDie`分钟的冷却时间； 过了`minutesToDie`分钟后，喝到毒药的猪会死。给你桶的数目`buckets`，`minutesToDie`和`minutesToTest`，返回在规定时间内判断哪个桶有毒所需的 **最小** 猪数

## 440. 汉明距离总和 
* 两个整数的 **汉明距离** 指的是这两个数字的二进制数对应位不同的数量。 给你一个整数数组`nums`，请你计算并返回`nums`中任意两个数之间汉明距离的总和 

## 441. 随机翻转矩阵
* 实现 Solution 类：`Solution(int m, int n)`使用二元矩阵的大小`m`和`n`初始化该对象；`int[] flip()`返回一个满足`matrix[i][j] == 0`的随机下标`[i, j]`，并将其对应格子中的值变为`1`；`void reset()`将矩阵中所有的值重置为`0`

## 442. 统计出现过一次的公共字符串
* 给你两个字符串数组`words1`和`words2`，请你返回在两个字符串数组中 都恰好出现一次的字符串的数目

## 443. 从房屋收集雨水需要的最少水桶数
* 给你一个字符串`street`。`street`中每个字符要么是表示房屋的`'H'`，要么是表示空位的`'.'`。在空位放置水桶，位置在 i - 1 或者`i + 1`的水桶可以收集位置为`i`处房屋的雨水。在确保每个房屋旁边都 **至少** 有一个水桶的前提下，请你返回需要的 **最少** 水桶数。

## 444. 网格图中机器人回家的最小代价
* 给你一个`m x n`的网格图，`startPos = [startrow, startcol]`表示 初始在格子`(startrow, startcol)`处。同时给你一个整数数组`homePos = [homerow, homecol]`表示家在格子`(homerow, homecol)`处。你两个下标从`0`开始的额整数数组：长度为`m`的数组`rowCosts `和长度为`n`的数组`colCosts`。 往 **上下** 移动到第`r`行的格子，那么代价为`rowCosts[r]`； 往 **左右** 移动到第`c`列 的格子，那么代价为`colCosts[c]`。 请你返回机器人回家需要的最小总代价

## 445. 找出数组排序后的目标下标
* 给你一整数数组`nums`以及一个目标元素 target`。将`nums`按非递减顺序排序后，返回由`nums`中目标下标组成的列表

## 446. 半径为 k 的子数组平均值
* 给你一个下标从`0`开始的数组`nums`，另给你一个整数`k`。构建并返回一个长度为`n`的数组`avgs`，其中`avgs[i]`是以下标`i`为中心的半径为`k`的子数组平均值

## 447. 从数组中移除最大值和最小值
* 给你一个双端队列`nums`，数组由互不相同的整数组成。你的目标是从数组中移除最大值最小值。返回最小操作次数。

## 448. 找出知晓秘密的所有专家
* 给你一个整数`n`，表示有`n`个专家。另外给你一个二维整数数组`meetings`，其中`meetings[i] = [xi, yi, timei]`表示专家`xi`和专家`yi`在时间`timei`开会。专家`0`有秘密 ，在时间`0`将这个秘密分享给了专家`firstPerson`。每次会议，如果专家`xi`在时间`timei`时已经知晓秘密，那么他将会与专家`yi`分享秘密。在所有会议都结束之后，返回所有知晓这个秘密的专家列表。

## 449. 找到字符串中所有字母异位词
* 给定两个字符串`s`和`p`，找到`s`中所有`p`的 **异位词** 的子串，返回这些子串的起始索引

## 450. 有序矩阵中第 K 小的元素
* 给你一个`n x n`矩阵`matrix`，其中每行和每列元素均按升序排序，找到矩阵中第`k`小的元素

## 451. 第 K 个最小的素数分数
* 给你一个按递增顺序排序的数组`arr`和一个整数`k`。数组`arr`由`1`和若干 **素数** 组成，且其中所有整数互不相同。 对于每对满足`0 <= i < j < arr.length`的`i`和`j`，可以得到分数`arr[i] / arr[j]`。 那么第`k`个最小的分数是多少

## 452. 第 N 位数字
* 给你一个整数`n`，请你在无限的整数序列`[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]`中找出并返回第`n`位上的数字

## 453. 连续字符
* 给你一个字符串`s`，字符串的能量定义为：只包含一种字符的最长非空子字符串的长度。 请你返回字符串的能量

## 454. 相对名次
* 给你一个整数数组`score`，其中`score[i]`是第`i`位运动员在比赛中的得分。所有得分都互不相同。使用长度为`n`的数组`answer`返回获奖情况

## 455. K 次取反后最大化的数组和
* 给你一个整数数组`nums`和一个整数`k`,对数组进行`k`次操作，每次任意取一个元素为负。求`k`次操作后的最大结果

## 456. 二叉搜索树与双向链表
* 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表

## 457. 序列化二叉树
* 请实现两个函数，分别用来按照leetcode格式序列化和反序列化二叉树。

## 458. 序列化二叉树
* 请实现两个函数，分别用来按照leetcode格式序列化和反序列化二叉树。

## 459. 找出 3 位偶数
* 给你一个整数数组`digits`，其中每个元素是一个`0 - 9`的数字。数组中可能存在重复元素。将找出的所有互不相同的三位偶整数按递增排列返回。

## 460. 删除链表的中间节点
* 给你一个链表的头节点 head 。删除 链表的 中间节点 

## 461. 从二叉树一个节点到另一个节点每一步的方向
* 给你一棵二叉树的根节点`root`，每个节点的值互不相同。给你一个整数`startValue`，表示起点节点`s`的值，和另一个不同的整数`destValue`，表示终点节点`t`的值，请找到从节点`s`到节点`t`的最短路径

## 462. 截断句子
* 给你一个句子`s`和一个整数`k`，请你将`s`截断，使截断后的句子仅含前`k`个单词

## 463. 边界着色
* 给你一个大小为`m x n`的整数矩阵`grid`，表示一个网格。网格中的每个值表示该位置处的网格块的颜色。请你使用指定颜色`color`为所有包含网格块`grid[row][col]`的 **连通分量的边界** 进行着色

## 464. 长度最小的子数组
* 给定一个含有`n`个正整数的数组和一个正整数`target`。 找出该数组中满足其和大于等于`target`的长度最小的连续子数组的长度

## 465. 三个无重叠子数组的最大和
* 给你一个整数数组`nums`和一个整数`k`，找出三个长度为`k`、互不重叠、且`3 * k`项的和最大的子数组，并返回这三个子数组

## 466. 有效的井字游戏
* 给你一个字符串数组`board`表示井字游戏的棋盘。判断棋盘是否有可能达到`board`所显示的状态

## 467. 最短补全词
* 给你一个字符串`licensePlate`和一个字符串数组`words`，忽略`licensePlate`中的 数字和空格，不区分大小写，请你找出并返回`words`中的最短补全词。

## 468. 在线选举
* 实现`TopVotedCandidate`类：`TopVotedCandidate(int[] persons, int[] times)`使用`persons`和`times`数组初始化对象，在选举中，第`i`张票是在时刻为`times[i]`时投给候选人`persons[i]`的；`int q(int t)`返回在时刻`t`在选举中领先的候选人的编号。在`t`时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。

## 469. 转换成小写字母
* 转换成小写字母

## 470. 保持城市天际线
* 给你一个矩阵`grid`，其中`grid[r][c]`表示坐落于`r`行`c`列的建筑物的高度。城市的天际线是从远处观察城市时，所有建筑物形成的外部轮廓。在不改变从 **上下左右方向** 观测到的城市天际线的前提下，返回建筑物可以增加的 **最大高度增量总和** 。

## 471. 课程表 III
* 给你一个数组`courses`，其中`courses[i] = [durationi, lastDayi]`表示第`i`门课将会持续上`durationi`天课，并且必须在不晚于`lastDayi`的时候完成。不能同时修读两门及两门以上的课程。 返回你最多可以修读的课程数目

## 472. 喧闹和富有
* 给你一个数组`richer`，其中`richer[i] = [ai, bi]`表示`ai`比`bi`更有钱。另给你一个整数数组`quiet`，其中`quiet[i]`是`i`的安静值。返回一个数组`answer`作为答案，其中`answer[x] = y`的前提是，在所有拥有的钱肯定不少于`x`的人中，`y`是最安静的人

## 473. 可见点的最大数目
* 你的位置是`location`，其中`location = [posx, posy]`表示自己在`(posx, posy)`。给一个点集`points`，其中`points[i] = [xi, yi]`表示点在`(xi,yi)`。你的视野范围的角度用`angle`表示，可以通过自转调整观测角度。返回你能看到的点的最大数目

## 474. 换酒问题 
* 小区便利店正在促销，用`numExchange`个空酒瓶可以兑换一瓶新酒。你购入了`numBottles`瓶酒。请你计算能喝到多少瓶酒。

## 475. 甲板上的战舰
* 给你一个矩阵`board`表示水面，每个单元格可以是战舰`'X'`或者是一个空位`'.'`。一艘战舰是一个`1*k`或者`k*1`的连续`'X'`。已知没有战舰相连。求`board`上的战舰数

## 476. 找到小镇的法官
* 法官满足如下条件：小镇的法官不相信任何人；除了小镇法官本人，所有人都信任小镇的法官。小镇有`1-n`总计`n`个人。给定数组`trust`，其中`trust[i] = [a, b]`组成，表示`a`信任`b`。如果小镇存在秘密法官，请返回该法官的编号。

## 477. 供暖器
* 给出位于一条水平线上的房屋`houses`和供暖器`heaters`的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。

## 478. 一年中的第几天
* 给你一个字符串`date`，按`YYYY-MM-DD`格式表示一个日期。请你计算并返回该日期是当年的第几天

## 479. 重复叠加字符串匹配
* 给定两个字符串`a`和`b`，寻找重复叠加字符串`a`的最小次数，使得字符串`b`成为叠加后的字符串`a`的子串，如果不存在则返回`-1`

## 480. 最长重复子串
* 给你一个字符串`s`，考虑其所有重复子串 ：即`s`的连续子串，在`s`中出现多次。这些出现之间可能存在重叠。 返回具有最长长度的重复子串。

## 481. 吃苹果的最大数目
* 苹果树一连`n`天，每天都可以长出若干个苹果。在第`i`天，树上会长出`apples[i]`个苹果，这些苹果将会在第`i + days[i]`天时腐烂。每天最多吃一个苹果。无限制时间，最多吃多少个苹果

## 482. 奇偶树
* 奇偶树 ： 奇数层上的所有节点的值都是奇整数，从左到右按顺序严格递增；偶数层上的所有节点的值都是偶整数，从左到右按顺序严格递减。判断是否是奇偶树

## 483. Bigram 分词
* 给出第一个词`first`和第二个词`second`，给定有若干单词的`text`如果 `first``second`紧随出现，其后一个则称为`third`，统计所有`third`

## 484. 适龄的朋友
* 有`n`个用户。给你一个整数数组`ages`，其中`ages[i]`是第`i`个用户的年龄。如果下述任意一个条件为真，那么用户`x`将不会向用户`y`发送好友请求： `ages[y] <= 0.5 * ages[x] + 7`；`ages[y] > ages[x]`；`x = y`。返回在该社交媒体网站上产生的好友请求总数。
  
## 485. 连接词
* 给你一个 不含重复 单词的字符串数组 words ，请你找出并返回 words 中的所有 连接词 
 
## 486. 统计特殊四元组
* 给你一个整数数组`nums`，返回满足下述条件的四元组`(a, b, c, d)`的数目 ：`nums[a] + nums[b] + nums[c] == nums[d]`，且`a < b < c < d`

## 487. 至少是其他数字两倍的最大数
* 请你找出数组中的最大元素并检查它是否至少是数组中每个其他数字的两倍 。如果是，则返回最大元素的下标

## 488. 查找和最小的 K 对数字
* 给定两个以升序的整数数组`nums1`和`nums2`,以及一个整数`k`。 定义一对值`(u,v)`，其中`u`来自`nums1`，`v`来自`nums2`。 请找到和最小的`k`个数对

## 489. 计算力扣银行的钱
* 周一的时候存入`1`块钱。从周二到周日，每天都比前一天多存入`1`块钱。在接下来每一个周一，他都会比前一个周一多存入`1`块钱。 返回在第`n`天结束的时候他在力扣银行总共存了多少块钱。

## 490. 链表随机节点
* 实现`Solution`类：`Solution(ListNode head)`使用整数数组初始化对象；`int getRandom()`从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。

## 491. 统计元音字母序列的数目
* 统计一下我们可以按下述规则形成多少个长度为`n`的字符串： 字符串中的每个字符都应当是`'a', 'e', 'i', 'o', 'u'`中的一个； 每个元音`'a'`后面都只能跟着`'e'`； 每个元音`'e'`后面只能跟着`'a'`或者是`'i'`； 每个元音`'i'`后面 不能 再跟着另一个`'i'`； 每个元音`'o'`后面只能跟着`'i'`或者是`'u'`； 每个元音`'u'`后面只能跟着`'a'`。

## 492. 将字符串拆分为若干长度为 k 的组
* 字符串`s`可以按下述步骤划分为若干长度为`k`的组，如果最后一个部分长度不足`k`则用`fill`补充

## 493. 得到目标值的最少行动次数
* 从整数`1`开始，期望得到整数`target`。 在一次行动中，你可以对当前数字加一或者加倍；可以使用任意次加一；只能使用`maxDoubles`次加倍。 给你两个整数`target`和`maxDoubles`，返回从`1`开始得到`target`需要的最少行动次数。

## 494. 解决智力问题
* 二维整数数组`questions`，其中`questions[i] = [pointsi, brainpoweri]`。 这个数组表示一系列题目，按顺序针对每个问题选择 **解决** 或者 **跳过** 。解决问题`i`将获得`pointsi`的分数，但是你将只能跳过接下来的`brainpoweri`个问题。 请你返回这场考试里你能获得的最高分数

## 495. 最小时间差
* 给定一个 **小时:分钟** = `"HH:MM"` 的时间列表，找出列表中最小时间差

## 496. 
* 

## 497. 
*

## 498. 
* 

## 499. 
* 
