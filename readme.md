## 1. 第一个错误的版本
* 所以错误的版本之后的所有版本都是错的. 假设你有`n`个版本 `[1, 2, ..., n]`,你想找出导致之后所有版本出错的第一个错误的版本

## 2. 二分查找
* 给定一个`n`个元素有序的（升序）整型数组`nums`和一个目标值`target` ,写一个函数搜索`nums`中的`target`,如果目标值存在返回下标,否则返回`-1

## 3. 搜索插入位置
* 给定一个排序数组和一个目标值,在数组中找到目标值,并返回其索引.如果目标值不存在于数组中,返回它将会被按顺序插入的位置.

## 4. 旋转数组
* 给定一个数组,将数组中的元素向右移动`k`个位置,其中`k`是非负数

## 5. 有序数组的平方
* 给你一个按 **非递减顺序** 排序的整数数组`nums`,返回 **每个数字的平方** 组成的新数组,要求也按 **非递减顺序** 排序

## 6. 移动零
* 给定一个数组`nums`,编写一个函数将所有`0`移动到数组的末尾,同时保持非零元素的相对顺序.

## 7. 两数之和 II - 输入有序数组
* 给定一个已按照 **升序排列** 的整数数组`numbers`,请你从数组中找出两个数满足相加之和等于目标数`target`

## 8. 反转字符串
* 编写一个函数,其作用是将输入的字符串反转过来.输入字符串以字符数组`char[]`的形式给出. 不要给另外的数组分配额外的空间,你必须原地修改输入数组、使用`O(1)`的额外空间解决这一问题.

## 9. 反转字符串中的单词 III
* 给定一个字符串,你需要反转字符串中每个单词的字符顺序,同时仍保留空格和单词的初始顺序

## 10. 链表的中间结点
* 给定一个头结点为`head`的非空单链表,返回链表的中间结点

## 11. 删除链表的倒数第 N 个结点
* 给你一个链表,删除链表的倒数第`n`个结点,并且返回链表的头结点

## 12. 无重复字符的最长子串
* 给定一个字符串`s`,请你找出其中不含有重复字符的 **最长子串** 的长度

## 13. 字符串的排列
* 给你两个字符串`s1`和`s2`,写一个函数来判断`s2`是否包含`s1`的排列

## 14. 图像渲染
* 图像中所有颜色相同且上下左右相邻的像素点可以看作一个区域,将初始点所在区域内的所有像素点的颜色值换成新的颜色

## 15. 岛屿的最大面积
* 一个 **岛屿** 是由一些相邻的`1`(代表土地)构成的组合,这里的「相邻」要求两个`1`必须在水平或者竖直方向上相邻.你可以假设`grid`的四个边缘都被`0`（代表水）包围着. 找到给定的二维数组中最大的岛屿面积.

## 16.合并二叉树
* 将两个合并为一个新的二叉树.合并的规则是如果两个节点重叠,那么将他们的值相加作为节点合并后的新值,否则不为`NULL`的节点将直接作为新二叉树的节点

## 17. 填充每个节点的下一个右侧节点指针
* 给定一个 **完美二叉树** ,其所有叶子节点都在同一层,每个父节点都有两个子节点填充它的每个`next`指针,让这个指针指向其下一个右侧节点.

## 18. 01 矩阵
* 给定一个由`0`和`1`组成的矩阵`mat`,请输出一个大小相同的矩阵,其中每一个格子是`mat`中对应位置元素到最近的`0`的距离

## 19.腐烂的橘子
* 每分钟,任何与腐烂的橘子（在`4`个正方向上）相邻的新鲜橘子都会腐烂. 返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数

## 20. 合并两个有序链表
* 将两个升序链表合并为一个新的 **升序** 链表并返回.新链表是通过拼接给定的两个链表的所有节点组成的

## 21. 反转链表
* 给你单链表的头节点`head`,请你反转链表,并返回反转后的链表

## 22. 组合
* 给定两个整数`n`和`k,返回范围`[1, n]`中所有可能的`k`个数的组合

## 23. 全排列
* 给定一个不含重复数字的数组`nums`,返回其所有可能的全排列

## 24. 字母大小写全排列
* 给定一个字符串S,通过将字符串S中的每个字母转变大小写,我们可以获得一个新的字符串.返回所有可能得到的字符串集合

## 25. 爬楼梯
* 每次你可以爬`1`或`2`个台阶.你有多少种不同的方法可以爬到楼顶呢

## 26. 打家劫舍
* 每间房内都藏有一定的现金,影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统,如果两间相邻的房屋在同一晚上被小偷闯入,系统会自动报警.计算你 **不触动警报装置的情况下** ,一夜之内能够偷窃到的最高金额

## 27. 三角形最小路径和
* 给定一个三角形`triangle`,找出自顶向下的最小路径和

## 28. 2 的幂
* 给你一个整数`n`,请你判断该整数是否是`2`的幂次方

## 29. 位1的个数
* 编写一个函数,输入是一个无符号整数（以二进制串的形式）,返回其二进制表达式中数字位数为`'1'`的个数

## 30. 颠倒二进制位
* 颠倒给定的`32`位无符号整数的二进制位

## 31. 只出现一次的数字
* 给定一个非空整数数组,除了某个元素只出现一次以外,其余每个元素均出现两次.找出那个只出现了一次的元素

## 32. 存在重复元素
* 给定一个整数数组,判断是否存在重复元素

## 33. 最大子序和
* 给定一个整数数组`nums`,找到一个具有最大和的连续子数组（子数组最少包含一个元素）,返回其最大和

## 34. 两数之和
* 给定一个整数数组`nums`和一个整数目标值`target`,请你在该数组中找出和为目标值 **target**  的那 两个 整数,并返回它们的数组下标

## 35. 合并两个有序数组
* 给你两个有序整数数组`nums1`和`nums2`,请你将`nums2`合并到`nums1`中,使`nums1`成为一个有序数组

## 36. 斐波那契数 
* 斐波那契数,通常用`F(n)`表示,形成的序列称为 **斐波那契数列** .该数列由`0`和`1`开始,后面的每一项数字都是前面两项数字的和

## 37. 第 N 个泰波那契数
* 请返回第`n`个泰波那契数`Tn`的值

## 38. 使用最小花费爬楼梯
* 每当你爬上一个阶梯你都要花费对应的体力值,一旦支付了相应的体力值,你就可以选择向上爬一个阶梯或者爬两个阶梯. 请你找出达到楼层顶部的最低花费

## 39. 打家劫舍 II
* 每间房内都藏有一定的现金.这个地方所有的房屋都 **围成一圈** ,这意味着第一个房屋和最后一个房屋是紧挨着的.同时,相邻的房屋装有相互连通的防盗系统,如果两间 **相邻** 的房屋在同一晚上被小偷闯入,系统会自动报警 .计算你 **在不触动警报装置的情况下** ,今晚能够偷窃到的最高金额

## 40. 删除并获得点数
* 给你一个整数数组nums, 每次操作中,选择任意一个`nums[i]`,删除它并获得`nums[i]`的点数.之后,你必须删除 **所有** 等于`nums[i] - 1`和 nums[i] + 1的元素. 返回你能通过这些操作获得的最大点数

## 41. 两个数组的交集 II
* 给定两个数组,编写一个函数来计算它们的交集

## 42. 买卖股票的最佳时机
* 给定一个数组`prices`,它的第`i`个元素`prices[i]`表示一支给定股票第`i`天的价格. 你只能选择 **某一天** 买入这只股票,并选择在 **未来的某一个不同的日子** 卖出该股票.计算你所能获取的最大利润

## 43. 重塑矩阵
* 将一个`m x n`矩阵重塑为另一个大小不同`r x c`的新矩阵,但保留其原始数据

## 44. 杨辉三角
* 给定一个非负整数`numRows`,生成「杨辉三角」的前`numRows`行

## 45. 有效的数独
* 请你判断一个`9x9`的数独是否有效.数字`1-9`在每一行只能出现一次. 数字`1-9`在每一列只能出现一次. 数字`1-9`在每一个以粗实线分隔的`3x3`宫内只能出现一次.

## 46. 矩阵置零
* 给定一个`m x n`的矩阵,如果一个元素为`0`,则将其所在行和列的所有元素都设为`0`.请使用 **原地** 算法

## 47. 字符串中的第一个唯一字符
* 给定一个字符串,找到它的第一个不重复的字符,并返回它的索引

## 48. 赎金信
* 给定一个赎金信字符串和一个杂志字符串,判断第一个字符串`ransom`能不能由第二个字符串`magazines`里面的字符构成

## 49. 有效的字母异位词
* 给定两个字符串`s`和`t`,编写一个函数来判断`t`是否是`s`的字母异位词

## 50. 环形链表
* 给定一个链表,判断链表中是否有环

## 51. 移除链表元素
* 给你一个链表的头节点`head`和一个整数`val`,请你删除链表中所有满足`Node.val == val`的节点,并返回 新的头节点

## 52. 删除排序链表中的重复元素
* 存在一个按升序排列的链表,给你这个链表的头节点`head`,请你删除所有重复的元素,使每个元素 **只出现一次** 

## 53. 跳跃游戏
* 给定一个非负整数数组`nums`,你最初位于数组的 **第一个下标** . 数组中的每个元素代表你在该位置可以跳跃的最大长度. 判断你是否能够到达最后一个下标

## 54. 跳跃游戏 II
* 给你一个非负整数数组`nums`,你最初位于数组的第一个位置. 数组中的每个元素代表你在该位置可以跳跃的最大长度. 你的目标是使用最少的跳跃次数到达数组的最后一个位置.

## 55. 环形子数组的最大和
* 给定一个由整数数组`A`表示的环形数组`C`,求`C`的非空子数组的最大可能和

## 56. 乘积最大子数组
* 给你一个整数数组`nums`,请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）,并返回该子数组所对应的乘积

## 57. 乘积为正数的最长子数组长度
* 给你一个整数数组`nums`,请你求出乘积为正数的最长子数组的长度. 一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组. 请你返回乘积为正数的最长子数组长度

## 58. 最佳观光组合
* 给你一个正整数数组`values`,其中`values[i]`表示第`i`个观光景点的评分,并且两个景点`i`和`j`之间的 **距离** 为`j - i`. 一对景点组成的观光组合的得分为`values[i] + values[j] + i - j`,也就是景点的评分之和 **减去** 它们两者之间的距离. 返回一对观光景点能取得的最高分

## 59. 买卖股票的最佳时机 II
* 给定一个数组`prices`,其中`prices[i]`是一支给定股票第`i`天的价格. 设计一个算法来计算你所能获取的最大利润.你可以尽可能地完成更多的交易

## 60. 最佳买卖股票时机含冷冻期
* 给定一个整数数组,其中第`i`个元素代表了第`i`天的股票价格 .设计一个算法计算出最大利润.在满足以下约束条件下,你可以尽可能地完成更多的交易.你不能同时参与多笔交易.卖出股票后,你无法在第二天买入股票 (即冷冻期为`1`天)

## 61. 买卖股票的最佳时机含手续费
* 给定一个整数数组`prices`,其中第`i`个元素代表了第`i`天的股票价格 ；整数`fee`代表了交易股票的手续费用. 你可以无限次地完成交易,但是你每笔交易都需要付手续费.如果你已经购买了一个股票,在卖出它之前你就不能再继续购买股票了. 返回获得利润的最大值

## 62. 单词拆分
* 给定一个非空字符串`s`和一个包含非空单词的列表`wordDict`,判定`s`是否可以被空格拆分为一个或多个在字典中出现的单词

## 63. 接雨水
* 给定`n`个非负整数表示每个宽度为`1`的柱子的高度图,计算按此排列的柱子,下雨之后能接多少雨水

## 64. 有效的括号
* 给定一个只包括`'(',')','{','}','[',']'`的字符串`s`,判断字符串是否有效

## 65. 用栈实现队列
* 请你仅使用两个栈实现先入先出队列.队列应当支持一般队列支持的所有操作（push、pop、peek、empty）

## 66. 二叉树的中序遍历
* 二叉树的中序遍历

## 67. 二叉树的前序遍历
* 二叉树的前序遍历

## 68. 二叉树的后序遍历
* 二叉树的后序遍历

## 69. 等差数列划分
* 给你一个整数数组`nums`,返回数组`nums`中所有为等差数组的 **子数组** 个数

## 70. 解码方法
*`'A' -> 1 , 'B' -> 2 , ...  'Z' -> 26 `.给你一个只含数字的 **非空** 字符串`s`,请计算并返回 **解码** 方法的 **总数**

## 71. 对称二叉树
* 给定一个二叉树,检查它是否是镜像对称的

## 72. 二叉树的层序遍历
* 给你一个二叉树,请你返回其按 **层序遍历** 得到的节点值.

## 73. 二叉树的最大深度
* 给定一个二叉树,找出其最大深度

## 74. 丑数 II
* 给你一个整数`n`,请你找出并返回第`n`个 丑数 . 丑数 **就是只包含质因数**` 2`、`3`和/或`5`的正整数.

## 75. 不同的二叉搜索树
* 给你一个整数`n`,求恰由`n`个节点组成且节点值从`1`到`n`互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数

## 76. 杨辉三角 II
* 给定一个非负索引`rowIndex`,返回「杨辉三角」的第`rowIndex`行

## 77. 下降路径最小和
* 给你一个`n x n`的 **方形** 整数数组`matrix`,请你找出并返回通过`matrix`的下降路径的 **最小和** 

## 78. 矩阵区域和
* 给你一个`m x n`的矩阵`mat`和一个整数 k ,请你返回一个矩阵`answer`,其中每个`answer[i][j]`是所有满足下述条件的元素`mat[r][c] 的和,i - k <= r <= i + k, j - k <= c <= j + k ,(r, c)`在矩阵内

## 79. 二维区域和检索 - 矩阵不可变
* 计算其子矩形范围内元素的总和,该子矩阵的左上角为`(row1, col1)`,右下角为`(row2, col2)`

## 80. 不同路径
* 一个机器人位于一个`m x n`网格的左上角. 机器人每次只能向下或者向右移动一步.机器人试图达到网格的右下角. 问总共有多少条不同的路径？

## 81. 不同路径 II
* 一个机器人位于一个`m x n`网格的左上角. 机器人每次只能向下或者向右移动一步.机器人试图达到网格的右下角. 现在考虑网格中有障碍物.那么从左上角到右下角将会有多少条不同的路径？

## 82. 翻转二叉树
* 翻转一棵二叉树

## 83. 路径总和
* 给你二叉树的根节点`root`和一个表示目标和的整数`targetSum`,判断该树中是否存在 **根节点到叶子节点** 的路径,这条路径上所有节点值相加等于目标和·targetSum·

## 84. 验证二叉搜索树
* 给定一个二叉树,判断其是否是一个有效的二叉搜索树

## 85. 两数之和 IV - 输入 BST
* 给定一个二叉搜索树`root`和一个目标结果`k`,如果`BST`中存在两个元素且它们的和等于给定的目标结果,则返回`true`.

## 86. 二叉搜索树的最近公共祖先
* 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先

## 87. 最小路径和
* 给定一个包含非负整数的`m x n`网格`grid`,请找出一条从左上角到右下角的路径,使得路径上的数字总和为最小

## 88. 最大正方形
* 在一个由`0`和`1`组成的二维矩阵内,找到只包含`1`的最大正方形,并返回其面积

## 89. 最长回文子串
* 给你一个字符串`s`,找到`s`中最长的回文子串

## 90. 最长回文子序列
* 给你一个字符串`s`,找出其中最长的回文子序列,并返回该序列的长度。子序列定义为：不改变剩余字符顺序的情况下,删除某些字符或者不删除任何字符形成的一个序列

## 91. 最长递增子序列
* 给你一个整数数组`nums`,找到其中最长严格递增子序列的长度。子序列是由数组派生而来的序列,删除（或不删除）数组中的元素而不改变其余元素的顺序。例如,`[3,6,2,7]`是数组`[0,3,1,6,2,2,7]`的子序列

## 92. 摆动序列
* 如果连续数字之间的差严格地在正数和负数之间交替,则数字序列称为 摆动序列 。给你一个整数数组`nums`,返回`nums`中作为 **摆动序列** 的 **最长子序列的长度**

## 93. 判断子序列
* 给定字符串`s`和`t`,判断`s`是否为`t`的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串

## 94. 最长公共子序列
* 给定两个字符串`text1`和`text2`,返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ,返回`0`。 一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串

## 95. 编辑距离
* 给你两个单词`word1`和`word2`,请你计算出将`word1`转换成`word2`所使用的最少操作数

## 96. 零钱兑8换
* 给你一个整数数组`coins`,表示不同面额的硬币；以及一个整数`amount`,表示总金额。 计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额,返回`-1`

## 97. 零钱兑换 II
* 给你一个整数数组`coins`表示不同面额的硬币,另给一个整数`amount`表示总金额。 请你计算并返回可以凑成总金额的硬币组合数

## 98. 组合总和 Ⅳ
* 给你一个由 **不同** 整数组成的数组`nums`,和一个目标整数`target`。请你从`nums`中找出并返回总和为`target`的元素组合的个数

## 99. 整数拆分
* 给定一个正整数`n`,将其拆分为至少两个正整数的和,并使这些整数的乘积最大化。 返回你可以获得的最大乘积

## 100. 完全平方数
* 给定正整数`n`,找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于`n`。你需要让组成和的完全平方数的个数最少。 给你一个整数`n`,返回和为`n`的完全平方数的 **最少数量**

## 101. 二叉搜索树中的搜索
* 给定二叉搜索树（`BST`）的根节点和一个值。 你需要在 `BST` 中找到节点值等于给定值的节点。

## 102. 二叉搜索树中的插入操作
* 给定二叉搜索树（`BST`）的根节点和要插入树中的值，将值插入 `BST` 。 返回插入后 `BST` 的根节点

## 103.  统计不开心的朋友
* 给你一份`n`位朋友的亲近程度列表，其中`n`总是 **偶数** 。对每位朋友`i`，`preferences[i]`包含一份 **按亲近程度从高到低排列** 的朋友列表。换句话说，排在列表前面的朋友与`i`的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以`0`到`n-1`之间的整数表示。 所有的朋友被分成几对，配对情况以列表`pairs`给出，其中`pairs[i] = [xi, yi]`表示`xi`与`yi`配对，且`yi`与`xi`配对。 但是，这样的配对情况可能会是其中部分朋友感到不开心：在 x 与 y 配对且 u 与 `v` 配对的情况下，如果同时满足下述两个条件，`x`就会不开心：`x`与`u`的亲近程度胜过`x`与`y`，且`u`与`x`的亲近程度胜过`u`与`v`。返回 **不开心的朋友的数目** 。

## 104.  出界的路径数
* 给你一个大小为`m x n`的网格和一个球。球的起始坐标为`[startRow, startColumn]`。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 **最多** 可以移动`maxMove`次球。 找出并返回可以将球移出边界的路径数量。

## 105.  两数相加
* 给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表

## 106. 寻找两个正序数组的中位数
* 给定两个大小分别为`m`和`n`的正序（从小到大）数组`nums1`和`nums2`。请你找出并返回这两个正序数组的 **中位数**

## 107. 优美的排列
* 假设有从`1`到`N`的`N`个整数，如果从这`N`个数字中成功构造出一个数组，使得数组的第`i`位 (`1 <= i <= N`) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列： 1:第`i`位的数字能被`i`整除。 2:`i`能被第 i 位上的数字整除。现在给定一个整数 N，请问可以构造多少个优美的排列

## 108. Z 字形变换
* 将一个给定字符串`s`根据给定的行数`numRows`，以从上往下、从左到右进行 **N** 字形排列

## 109. 学生出勤记录 I
* 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：'A'：Absent，缺勤；'L'：Late，迟到；'P'：Present，到场。 如果学生能够 **同时** 满足下面两个条件，则可以获得出勤奖励： 按 **总出勤** 计，学生缺勤（'A'）严格 **少于两天** 。 学生 不会 存在 连续 3 天或 3 天以上的迟到（'L'）记录。 如果学生可以获得出勤奖励，返回`true`；否则，返回`false`

## 110. 学生出勤记录 II
* 可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：'A'：Absent，缺勤；  'L'：Late，迟到；  'P'：Present，到场。  如果学生能够 **同时** 满足下面两个条件，则可以获得出勤奖励： 按 **总出勤** 计，学生缺勤（'A'）严格 **少于两天** 。 学生 **不会** 存在 连续`3`天或连续`3`天以上的迟到（'L'）记录。 给你一个整数`n`，表示出勤记录的长度（次数）。请你返回记录长度为`n`时，可能获得出勤奖励的记录情况 **数量**

## 111. 整数反转
* 给你一个 32 位的有符号整数`x`，返回将`x`中的数字部分反转后的结果

## 112. 字符串转换整数 (atoi)
* 请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数。除开头符号外，如某字符为非数字，之后的字符忽略

## 113. 回文数
*给你一个整数`x`,不转换成字符串,判断是否回文

## 114. 反转字符串中的元音字母
* 编写一个函数，以字符串作为输入，反转该字符串中的元音字母

## 115. 正则表达式匹配
* 给你一个字符串`s`和一个字符规律`p`，请你来实现一个支持`'.'`和`'*'`的正则表达式匹配。`'.'`配任意单个字符; `'*'`匹配零个或多个前面的那一个元素

## 116. 反转字符串 II
* 给定一个字符串`s`和一个整数`k`，从字符串开头算起，每`2k`个字符反转前`k`个字符。 如果剩余字符少于`k`个，则将剩余字符全部反转。 如果剩余字符小于`2k`但大于或等于`k`个，则反转前`k`个字符，其余字符保持原样。

## 117. 盛最多水的容器
* 给你`n`个非负整数`a1，a2，...，an`，每个数代表坐标中的一个点在`i`处高为`ai`的边。找出其中的两条边，使得它们与`x`轴共同构成的容器可以容纳最多的水

## 118. 整数转罗马数字
* 罗马数字中小的数字在大的数字的右边。但也存在特例。例如数字`4`写做`IV`，数字`9`表示为`IX`。给你一个整数，将其转为罗马数字。

## 119. 压缩字符串
* 给你一个字符数组 chars ，请使用下述算法压缩： 从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ： 如果这一组长度为`1`，则将字符追加到`s`中。 否则，需要向`s`追加字符，后跟这一组的长度。 压缩后得到的字符串`s`不应该直接返回 ，需要转储到字符数组`chars`中。需要注意的是，组长度本身也要被拆分成多个字符。 请在 **修改完输入数组后** ，返回该数组的新长度。

## 120. 罗马数字转整数
* 罗马数字中小的数字在大的数字的右边。但也存在特例。例如数字`4`写做`IV`，数字`9`表示为`IX`。给你一个罗马数字，将其转为整数。

## 121. 最长公共前缀
* 编写一个函数来查找字符串数组中的最长公共前缀

## 122. 逃脱阻碍者
* 你在进行一个简化版的吃豆人游戏。你从`[0, 0]`点开始出发，你的目的地是`target = [xtarget, ytarget]`。地图上有一些阻碍者，以数组`ghosts`给出，第`i`个阻碍者从`ghosts[i] = [xi, yi]`出发。所有输入均为 **整数坐标** 。 每一回合，你和阻碍者们可以同时向上下左右移动，每次可以移动到距离原位置`1`个单位的新位置。当然，也可以选择 **不动** 。所有动作 **同时** 发生。 返回你是否可以在任何阻碍者抓住你 **之前** 到达目的地

## 123. 三数之和
* 给你一个包含`n`个整数的数组`nums`，判断`nums`中是否存在三个元素`a，b，c`，使得`a + b + c = 0`？请你找出所有和为`0`且不重复的三元组

## 124. 获取生成数组中的最大值
* 给你一个整数`n`。按下述规则生成一个长度为`n + 1`的数组`nums`：`nums[0] = 0`；`nums[1] = 1`； 当`2 <= 2 * i <= n`时，`nums[2 * i] = nums[i]`； 当`2 <= 2 * i + 1 <= n`时，`nums[2 * i + 1] = nums[i] + nums[i + 1]`。返回生成数组`nums`中的 **最大** 值

## 125. 最接近的三数之和
* 给定一个包括`n`个整数的数组`nums`和一个目标值`target`。找出`nums`中的三个整数，使得它们的和与`target`最接近。返回这三个数的和。假定每组输入只存在唯一答案

## 126. 电话号码的字母组合
* 给定一个仅包含数字`2-9`的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回

## 127. K 站中转内最便宜的航班
* 有`n`个城市通过一些航班连接。给你一个数组`flights`，其中`flights[i] = [fromi, toi, pricei]`，表示该航班都从城市`fromi`开始，以价格`pricei`抵达`toi`。 现在给定所有的城市和航班，以及出发城市`src`和目的地`dst`，你的任务是找到出一条最多经过`k`站中转的路线，使得从`src`到`dst`的 **价格最便宜** 。 如果不存在这样的路线，则输出`-1`

## 128. 四数之和
* 给你一个由`n`个整数组成的数组`nums`，和一个目标值`target`。请你找出并返回满足下述全部条件且不重复的四元组`[nums[a], nums[b], nums[c], nums[d]]`：`0 <= a, b, c, d < n`；`a`、`b`、`c`和`d`互不相同；`nums[a] + nums[b] + nums[c] + nums[d] == target`

## 129. 所有可能的路径
* 给你一个有`n`个节点的 **有向无环图（DAG）** ，请你找出所有从节点`0`到节点`n-1`的路径

## 130. 救生艇
* 第`i`个人的体重为`people[i]`，每艘船可以承载的最大重量为`limit`。 每艘船最多可同时载两人，但条件是这些人的重量之和最多为`limit`。 返回最小船数。

## 131. 括号生成
* 数字`n`代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合

## 132. 数据流的中位数
* 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中; double findMedian() - 返回目前所有元素的中位数

## 133. 合并K个升序链表
* 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表

## 134. 一维数组的动态和
* 给你一个数组`nums`。数组「动态和」的计算公式为：`runningSum[i] = sum(nums[0]…nums[i])`

## 135. 两两交换链表中的节点
* 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换

## 136. 所有奇数长度子数组的和
* 给你一个正整数数组`arr`，请你计算所有可能的奇数长度子数组的和

## 137. K 个一组翻转链表
* 给你一个链表，每`k`个节点一组进行翻转，请你返回翻转后的链表

## 138. 按权重随机选择
* 给定一个正整数数组`w`，其中`w[i]`代表下标`i`的权重（下标从`0`开始），请写一个函数`pickIndex`，它可以随机地获取下标`i`，选取下标`i`的概率与`w[i]`成正比

## 139. 删除有序数组中的重复项
* 给你一个有序数组`nums`，请你 原地 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度

## 140. 反转字符串中的元音字母
* 给你一个字符串`s`，仅反转字符串中的所有元音字母，并返回结果字符串

## 141. 移除元素
* 给你一个数组`nums`和一个值`val`，你需要 **原地** 移除所有数值等于`val`的元素，并返回移除后数组的新长度

## 142. 实现 strStr()
* 给你两个字符串`haystack`和`needle`，请你在`haystack`字符串中找出`needle`字符串出现的第一个位置（下标从`0`开始）。如果不存在，则返回`-1`

## 143. 航班预订统计
* 这里有`n`个航班，它们分别从`1`到`n`进行编号。 有一份航班预订表`bookings`，表中第`i`条预订记录`bookings[i] = [firsti, lasti, seatsi]`意味着在从`firsti`到`lasti`（包含`firsti`和`lasti`）的 **每个航班** 上预订了`seatsi`个座位。 请你返回一个长度为`n`的数组`answer`，其中`answer[i]`是航班`i`上预订的座位总数

## 144. 比较版本号
* 给你两个版本号`version1`和`version2`，请你比较它们。从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 **忽略任何前导零后的整数值** 

## 145. 两数相除
* 给定两个整数，被除数`dividend`和除数`divisor`。将两数相除，要求不使用乘法、除法和`mod`运算符

## 146. 串联所有单词的子串
* 给定一个字符串`s`和一些 **长度相同** 的单词`words`。找出`s`中恰好可以由`words`中所有单词串联形成的子串的起始位置

## 147. 链表中倒数第k个节点
* 输入一个链表，输出该链表中倒数第`k`个节点

## 148. 下一个排列
* 实现获取 **下一个排列** 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即组合出下一个更大的整数）

## 149. 最小K个数
* 设计一个算法，找出数组中最小的`k`个数。

## 150. 最长有效括号
* 给你一个只包含`'('`和`')'`的字符串，找出最长有效（格式正确且连续）括号子串的长度

## 151. 斐波那契数列
* 写一个函数，输入`n`，求斐波那契（Fibonacci）数列的第`n`项（即`F(N)`）

## 152. 搜索旋转排序数组
* 整数数组`nums`按升序排列，数组中的值 **互不相同** 。 在传递给函数之前，`nums`在预先未知的某个下标`k`上进行了 **旋转** ，使数组变为`[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标从`0`开始计数）。例如，`[0,1,2,4,5,6,7]`在下标`3`处经旋转后可能变为`[4,5,6,7,0,1,2]`。 给你 **旋转后** 的数组`nums`和一个整数`target`，如果`nums`中存在这个目标值`target`，则返回它的下标，否则返回`-1`

## 153. 在排序数组中查找元素的第一个和最后一个位置
* 给定一个按照升序排列的整数数组`nums`，和一个目标值`target`。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值`target`，返回`[-1, -1]`

## 154. 组合总和
* 给定一个无重复元素的正整数数组`candidates`和一个正整数`target`，找出`candidates`中所有可以使数字和为目标数`target`的唯一组合。`candidates`中的数字可以无限制重复被选取

## 155. 组合总和 II
* 给定一个数组`candidates`和一个目标数`target`，找出`candidates`中所有可以使数字和为`target`的组合。`candidates`中的每个数字在每个组合中只能使用一次

## 156. 用 Rand7() 实现 Rand10()
* 已有方法`rand7`可生成`1`到`7`范围内的均匀随机整数，试写一个方法`rand10`生成`1`到`10`范围内的均匀随机整数

## 157. 字符串相加
* 给定两个字符串形式的非负整数`num1`和`num2`，计算它们的和

## 158. 字符串相乘
* 给定两个以字符串形式表示的非负整数`num1`和`num2`，返回`num1`和`num2`的乘积，它们的乘积也表示为字符串形式

## 159. 解数独
* 编写一个程序，通过填充空格来解决数独问题。 数独的解法需 遵循如下规则： 数字`1-9`在每一行只能出现一次； 数字`1-9`在每一列只能出现一次； 数字`1-9`在每一个以粗实线分隔的`3x3`宫内只能出现一次

## 160. 全排列 II
* 给定一个可包含重复数字的序列`nums`，按任意顺序 返回所有不重复的全排列

## 161. Pow(x, n)
* 实现`pow(x, n)`，即计算`x`的`n`次幂函数

## 162. 缺失的第一个正数
* 给你一个未排序的整数数组`nums`，请你找出其中没有出现的最小的正整数

## 163. 分割平衡字符串
* 在一个 **平衡字符串** 中，`'L'`和`'R'`字符的数量是相同的。 给你一个平衡字符串`s`，请你将它分割成尽可能多的平衡字符串

## 164. IPO
* 给你`n`个项目。对于每个项目`i`，它都有一个 **纯利润** `profits[i]`，和启动该项目 **需要的最小资本** `capital[i]`。你的资本为`w`。当你完成一个项目时，利润将被添加到你的总资本中。 在IPO之前完成最多`k`个不同的项目。设计完成最多`k`个不同项目后得到最大总资本的方式。

## 165. 外观数列
* 给定一个正整数`n`，输出外观数列的第`n`项。 1.`"1"`；2.`"11"`；3.`"21"`； 第二项，这个数是`"1"`即 “ 一 个 1 ”，记作`"11"`；第三项，这个数是`"11"`即 “ 二 个 1 ” ，记作 "21"
  
## 166. 旋转图像
* 给定一个`n × n`的二维矩阵`matrix`表示一个图像。请你将图像顺时针旋转`90`度

## 167. 文本左右对齐
* 给定一个单词数组和一个长度`maxWidth`，重新排版单词，使其成为每行恰好有`maxWidth`个字符，左右两端对齐。 要求尽可能均匀分配单词间的空格数量，单词之间至少有一个空格。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。 文本的最后一行应为左对齐，且单词之间不插入额外的空格。

## 168. 字母异位词分组
* 给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。 **字母异位词** 是由重新排列源单词的字母得到的一个新单词。所有源单词中的字母都恰好只用一次

## 169. 数字 1 的个数
* 给定一个整数`n`，计算所有小于等于`n`的非负整数中数字`1`出现的个数

## 170. 找到需要补充粉笔的学生编号
*有`n`人，编号为`0`到`n - 1`，从`0`到`n-1`号依次回答问题，然后重复这个过程。 给你一个长度为`n`的整数数组`chalk`和一个整数`k`。一开始总共有`k`支粉笔。编号为`i`的学生回答问题时，消耗`chalk[i]`支粉笔。如果剩余粉笔数量 **严格小于** `chalk[i]`，此人需要补充粉笔。 请你返回需要补充粉笔的人的编号

## 171. N 皇后
* **n皇后问题** 研究的是如何将`n`个皇后放置在`n×n`的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数`n`，返回所有`n`皇后问题的解决方案

## 172. N皇后 II
* **n皇后问题** 研究的是如何将`n`个皇后放置在`n×n`的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数`n`，返回`n`皇后问题解决方案的数量。

## 173. 通配符匹配
* 给定一个字符串`s`和一个字符模式`p`，实现一个支持`'?'`和`'*'`的通配符匹配。`'?'`可以匹配任何单个字符；`'*'`可以匹配任意字符串（包括空字符串）

## 174. 不含连续1的非负整数
* 给定一个正整数`n`，找出小于或等于`n`的非负整数中，其二进制表示不包含 **连续的1** 的个数

## 175. 无人机方阵
* 给定两个大小均为`N*M`的二维数组`source`和`target`表示无人机方阵表演的两种颜色图案，请返回从`source`到`target`最少需要多少架无人机切换灯光颜色

## 176. 心算挑战
* 从`N`张卡牌中选出`cnt`张卡牌，若这`cnt`张卡牌数字总和为偶数，则选手成绩 **「有效」** 且得分为`cnt`张卡牌数字总和。`cards[i]`表示第`i`张卡牌上的数字。 计算最大的有效得分。若不存在获取有效得分的卡牌方案，则返回`0`

## 177. 有效的括号字符串
* 一个只包含三种字符的字符串：`"("`,`")"`,`"*"`，检验字符串是否有效：1.`"*"`可以被视为`")"`，或`"("`，或一个空字符串；2.左右括号必须互相匹配

## 178. 判断能否形成等差数列
* 给你一个数字数组`arr`。判断能否重新排列数组形成等差数列

## 179. 所有蚂蚁掉下来前的最后一刻
* 一些蚂蚁在木板上移动，每只蚂蚁都以 **每秒一个单位** 的速度移动。其中，一部分蚂蚁向 **左** 移动，其他蚂蚁向 **右** 移动。当两只 **不同** 方向移动的蚂蚁相遇时，它们会同时改变移动方向并继续移动。当蚂蚁到达木板的一端时，它立即从木板上掉下来。 给你一个整数`n`和两个整数数组`left`以及`right`。木板长度为`n`个单位。两个数组分别标识向左向右移动的蚂蚁在`t = 0`时的位置。请你返回最后一只蚂蚁掉下来的时刻

## 180. 反转单词前缀
* 给你一个字符串`word`和一个字符`ch`。找出`ch`第一次出现的下标`i`，反转`word`中从下标`0`开始、直到下标`i`结束（含下标`i`）的那段字符。如果`word`中不存在字符`ch`，则无需进行任何操作

## 181. 相同的树
* 给你两棵二叉树的根节点`p`和`q`，编写一个函数来检验这两棵树是否相同

## 182. 删除二叉搜索树中的节点
* 给定一个二叉搜索树的根节点`root`和一个值`key`，若存在则删除二叉搜索树中的`key`对应的节点，并保证二叉搜索树的性质不变

## 183. 回旋镖的数量
* 给定平面上`n`对 **互不相同** 的点`points`，其中`points[i] = [xi, yi]`。回旋镖 是由点`(i, j, k)`表示的元组 ，其中`i`和`j`之间的距离和`i`和`k`之间的距离相等（需要考虑元组的顺序）

## 184. 螺旋矩阵
* 给你一个`m`行`n`列的矩阵`matrix`，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素

## 185. 合并区间
* 以数组`intervals`表示若干个区间的集合，其中单个区间为`intervals[i] = [starti, endi]`。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间

## 186. 插入区间
* 给你一个 **无重叠的** ，按照区间起始端点排序的区间列表。 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠。如果有必要，可以合并区间

## 187. 通过删除字母匹配到字典里最长单词
* 给你一个字符串`s`和一个字符串数组`dictionary`作为字典，找出并返回字典中最长的字符串，该字符串可以通过删除`s`中的某些字符得到。 如果答案不止一个，返回长度最长且字典序最小的字符串。如果答案不存在，则返回空字符串

## 188. 最后一个单词的长度
* 给你一个字符串`s`，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度

## 189. 螺旋矩阵 II
* 给你一个正整数`n`，生成一个包含`1`到`n2`所有元素，且元素按顺时针顺序螺旋排列的`n x n`正方形矩阵`matrix`

## 190. 排列序列
* 给出集合`[1,2,3,...,n]`，其所有元素共有`n!`种排列。 按大小顺序列出所有排列情况，并一一标记，给定`n`和`k`，返回第`k`个排列

## 191. 旋转链表
* 给你一个链表的头节点`head`，旋转链表，将链表每个节点向右移动`k`个位置

## 192. 恢复二叉搜索树
* 给你二叉搜索树的根节点`root`，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树

## 193. 加一
* 给定一个数组所表示的非负整数，在该数的基础上加一，用数组表示新数字

## 194. 二进制求和
* 给你两个二进制字符串，返回它们的和（用二进制表示）

## 195. x 的平方根
* 给你一个非负整数`x`，计算并返回`x`的 **平方根** ，只保留整数部分

## 196. 寻找峰值
* 峰值元素是指其值严格大于左右相邻值的元素。 给你一个整数数组`nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可

## 197. 有效数字
* 判断是否为有效数字。有效数字可以分成以下几个部分： 一个 **小数** 或者 **整数** ；（可选）一个`'e'`或`'E'`，后面跟着一个 **整数** 。  小数可以分成以下几个部分： （可选）一个符号字符（`'+'`或`'-'`）； 下述格式之一：`"x.x"`,`"x."`,`".x"` 。 整数（按顺序）可以分成以下几个部分：一个符号字符（'+' 或 '-'） ；至少一位数字

## 198. 单词搜索 II
* 给定一个`m x n`二维字符网格`board`和一个单词（字符串）列表`words`，找出所有同时在二维网格和字典中出现的单词。 单词必须按照字母顺序，通过 **相邻的单元格** 内的字母构成。同一个单元格内的字母在一个单词中不允许被重复使用

## 199. 搜索二维矩阵
* 编写一个高效的算法来判断`m x n`矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列； 每行的第一个整数大于前一行的最后一个整数。

## 200. 子集
* 给你一个整数数组`nums`，数组中的元素 **互不相同** 。返回该数组所有可能的子集

## 201. 单词搜索 II
* 给定一个`m x n`二维字符网格`board`和一个单词（字符串）列表`words`，找出所有同时在二维网格和字典中出现的单词。 单词必须按照字母顺序，通过 **相邻的单元格** 内的字母构成，其中 **相邻** 单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用

## 202. 验证回文串
* 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，其他字符忽略，可以忽略字母的大小写

## 203. 相交链表
* 给你两个单链表的头节点，`headA`和`headB`，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回`null`

## 204. 反转链表 II
* 给你单链表的头指针`head`和两个整数`left`和`right`，其中`left <= right`。请你反转从位置`left`到位置`right`的链表节点，返回 **反转后的链表**

## 205. 同构字符串
* 给定两个字符串`s`和`t`，判断它们是否是同构的。 如果`s`中的字符可以按某种映射关系替换得到`t`，那么这两个字符串是同构的。 每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上

## 206. Nim 游戏
* 每一回合，轮到的人拿掉`1 - 3`块石头。 拿掉最后一块石头的人就是获胜者。给定石头总数，判断能否获胜。

## 207. 二叉树的最小深度
* 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量

## 208. 快乐数
* 「快乐数」定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和； 然后重复这个过程直到这个数变为`1`，也可能是 **无限循环** 但始终变不到`1` ；如果可以变为`1`，那么这个数就是快乐数。 判断一个数`n`是不是快乐数

## 209. 差的绝对值为 K 的数对数目
* 给你一个整数数组`nums`和一个整数`k`，请你返回数对`(i, j)`的数目，满足`i < j`且`|nums[i] - nums[j]| == k`

## 210. 从双倍数组中还原原数组
* 一个整数数组`original`可以转变成一个 **双倍数组** `changed`，转变方式为将`original`中每个元素值乘以`2`加入数组中，然后将所有元素 **随机打乱**。 给你一个数组`changed`，如果`change`是 **双倍** 数组，那么请你返回`original`数组，否则请返回空数组。`original`的元素可以以 **任意** 顺序返回

## 211. 执行操作后的变量值
* `"++X"`和`"X++"`使变量`X`的值加`1`；`"--X"`和`"X--"`使变量`X`的值减`1`。`X`的初值是`0`，给你一个由操作组成的字符串数组`operations`，返回执行所有操作后`X`的值

## 212. 数组美丽值求和
* 给你一个下标从`0`开始的整数数组`nums`。对于每个下标`i`，`nums[i]`的 **美丽值** 等于：`2`：对于所有`0 <= j < i`且`i < k <= nums.length - 1`，满足`nums[j] < nums[i] < nums[k]`；`1`：如果满足`nums[i - 1] < nums[i] < nums[i + 1]`，且不满足前面的条件。`0`：如果上述条件全部不满足。返回符合`1 <= i <= nums.length - 2`的所有`nums[i]`的 **美丽值** 的总和

## 213. 检测正方形
* 给你一个平面上的点构成的数据流。设计一个满足下述要求的算法： 1.添加 **一个在数据流中的新点** 到某个数据结构中。可以添加 **重复** 的点，并会视作不同的点进行处理； 2.给你一个查询点，请你从数据结构中选出三个点，使这三个点和查询点一同构成一个 **面积为正*8 的 **轴对齐正方形** ，统计 **满足该要求的方案数目**。实现一个满足要求的类

## 214. 只有两个键的键盘
* 最初只有一个字符`'A'`。你每次可以进行两种操作： 复制所有字符；粘贴 **上一次** 复制的字符。 给你一个数字`n`，返回能够打印出`n`个`'A'`的最少操作次数

## 215. 最长递增子序列的个数
* 给定一个未排序的整数数组，找到最长递增子序列的个数

## 216. 颜色分类
* 一共`n`个元素的数组，原地对它们进行排序，使得相同的元素相邻.共有三种元素

## 217. 单词搜索
* 给定一个`m x n`二维字符网格`board`和一个字符串单词`word`。如果`word`存在于网格中，返回`true`；否则，返回`false`

## 218. 删除有序数组中的重复项 II
* 给你一个有序数组`nums`，请你 **原地** 删除重复出现的元素，使每个元素 **最多出现两次** ，返回删除后数组的新长度

## 219. 分隔链表
* 给你一个链表的头节点`head`和一个特定值`x`，请你对链表进行分隔，使得所有 **小于** `x`的节点都出现在 **大于或等于** `x`的节点之前

## 220. 格雷编码
* 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。 给定一个代表编码总位数的非负整数`n`，打印其格雷编码序列的一种。格雷编码序列必须以 0 开头

## 221. 简化路径
* **路径表示**：一个点`"."`表示当前目录本身；两个点`".."`表示将目录切换到上一级；任意多个连续的斜杠`"/"*n`都被视为单个斜杠`"/"`。**规范路径** 遵循下述格式： 始终以斜杠`"/"`开头； 目录名之间有一个斜杠`"/"`； 除根目录外，不能以`"/"`结尾； 不含`"."`或`".."`。请将`path`转化为规范路径

## 222. 分隔链表
* 给你一个头结点为`head`的单链表和一个整数`k`，请你设计一个算法将链表分隔为`k`个连续的部分，返回一个由上述`k`部分组成的数组

## 223. 存在重复元素 II
* 给定一个整数数组和一个整数`k`，判断数组中是否存在两个不同的索引`i`和`j`，使得`nums [i] = nums [j]`，并且`abs(i - j) <= k`

## 224. 存在重复元素 III
* 给你一个整数数组`nums`和两个整数`k`和`t`。请你判断是否存在两个 **不同** 下标`i`和`j`，使得`abs(nums[i] - nums[j]) <= t`，同时又满足`abs(i - j) <= k`

## 225. 4的幂
* 给定一个整数，写一个函数来判断它是否是`4`的幂次方

## 226. 3的幂
* 给定一个整数，写一个函数来判断它是否是`3`的幂次方

## 227. 笨阶乘
* 笨阶乘：在整数的递减序列中，我们按操作符顺序`*，//，+，-`来依次计算，注意计算遵守乘法优先。`7*6//5+4-3*2//1`中结果是`8+4-6`

## 228. 阶乘后的零
* 给定一个整数`n`，返回`n!`结果中尾随零的数量

## 229. 扁平化多级双向链表
* 多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构。请你扁平化列表，使所有结点出现在单级双链表中

## 230. H 指数
* 给你一个整数数组`citations`，研究者的各论文论文被引用的次数。若有`h`篇论文分别被引用了至少`h`次。且其余的`n - h`篇论文每篇被引用次数不超过`h`次，则`h`为 **H指数**。根据`citations`求 **h指数**

## 231. H 指数 II
* 给你一个升序排列的整数数组`citations`，研究者的各论文论文被引用的次数。若有`h`篇论文分别被引用了至少`h`次。且其余的`n - h`篇论文每篇被引用次数不超过`h`次，则`h`为 **H指数**。根据`citations`求 **h指数**

## 232. 两个字符串的删除操作
* 给定两个单词`word1`和`word2`，找到使得`word1`和`word2`相同所需的最小步数，每步可以删除任意一个字符串中的一个字符

## 233. 交错字符串
* 给定三个字符串`s1`、`s2`、`s3`，请你帮忙验证`s3`是否是由`s1`和`s2` **交错** 组成的。交错指的是`s1`、`s2`按照原有顺序互相插入

## 234. 两整数之和
* 给你两个整数`a`和`b`，不使用运算符`+`和`-`，计算并返回两整数之和

## 235. 解码方法 II
* `'A' -> 1 , 'B' -> 2 , ...  'Z' -> 26 '*' -> 任何数字`.给你一个 **非空** 字符串`s`,请计算并返回 **解码** 方法的 **总数**

## 236. 复原 IP 地址
* 给定一个只包含数字的字符串，用以表示一个`IP`地址，返回所有可能从`s`获得的 有效`IP`地址 。你可以按任何顺序返回答案

## 237. 搜索旋转排序数组 II
* 一个按非降序数组`nums`，在某个下标`k`上进行了 **旋转** ，使数组变为`[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`。给你 **旋转后** 的数组`nums`和一个整数`target`，判断给定的目标值是否存在于数组中。

## 238. 路径总和 II
* 给你二叉树的根节点`root`和一个整数目标和`targetSum`，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径

## 239. 路径总和 III
* 给定一个二叉树的根节点`root`，和一个整数`targetSum`，求该二叉树里节点值之和等于`targetSum`的 **路径** 的数目。 **路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的

## 240. 超级洗衣机
* 有`n`台洗衣机放在同一排上。开始的时候，每台洗衣机内可能为空或者有一定量的衣服。 在每一步操作中，选择任意`m`台洗衣机，将其中每台洗衣机的一件衣服送到相邻的一台洗衣机。 给定一个整数数组`machines`代表每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的 **最少的操作步数** 。

## 241. 矩形面积
* 给你平面上两个 **平正矩形** ，请你计算并返回两个矩形覆盖的总面积。 每个矩形由其 **左下** 顶点和 **右上** 顶点坐标表示

## 242. 猜数字游戏
* 一个数字`secret`，每猜测一次就得到一个提示，告诉猜测数字中有多少位属于数字和确切位置都猜对了，称为`A`，有多少位属于数字猜对了但是位置不对，称为`A`。根据秘密数字和朋友的猜测数返回提示

## 243. 除自身以外数组的乘积
* 给你一个长度为`n`的整数数组`nums`，其中`n > 1`，返回输出数组`output`，其中`output[i]`等于`nums`中除`nums[i]`之外其余各元素的乘积

## 244. 猜数字大小
* `1`到`n`随机选择一个数字`pick`由你猜。提供`guess`接口，输入猜测的数字`nums`。`pick < num`则返回`-1`；`pick > num`则返回`1`；`pick = num`则返回`0`；

## 245. 两个数组的交集
* 给定两个数组，编写一个函数来计算它们的交集

## 246. 有效的完全平方数
* 判断给定的`n`是否是完全平方数

## 247. 字符串解码
* 编码规则为: `k[encoded_string]`，表示其中方括号内部的`encoded_string`正好重复`k`次。给定一个经过编码的字符串，返回它解码后的字符串

## 248. 回文链表
* 给你一个单链表的头节点`head`，请你判断该链表是否为回文链表。

## 249. 旅行终点站
* 线路图中的旅行线路用数组`paths`表示，其中`paths[i] = [cityAi, cityBi]`表示该线路将会从`cityAi`直接前往`cityBi`。请你找出这次旅行的终点站

## 250. 用队列实现栈
* 使用两个队列实现一个栈，并支持普通栈的全部四种操作`push top pop empty`

## 251. 超级次方
* 你的任务是计算`ab`对`1337`取模，`a`是一个正整数，`b`是一个非常大的正整数且会以数组形式给出

## 252. 数字转换为十六进制数
* 数字转换为十六进制数

## 253. 整数替换
* 给定一个正整数`n`，你可以做如下操作：`n`是偶数，则用`n / 2`替换`n`； 如果`n`是奇数，则可以用`n + 1`或`n - 1`替换`n` 。`n`变为`1`所需的最小替换次数是多少

## 254. 石子游戏
* 偶数堆石子排成一行，每堆都有`piles[i] `颗石子。两人轮流从最左或最右取，最后总数多的人胜利。

## 255. 将一维数组转变成二维数组
* 给你一个下标从`0`开始的一维整数数组`original`和两个整数`m`和`n`。你需要使用`original`中 **所有** 元素创建一个`m`行`n`列的二维数组

## 256. 连接后等于目标字符串的字符串对
* 给你一个数字字符串数组`nums`和一个字符串`target`，请你返回`nums[i] + nums[j]`结果等于`target`的下标`(i, j)`（需满足`i != j`）的数目

## 257. 最大连续1的个数 III
* 给定一个由若干`0`和`1`组成的数组`A`，我们最多可以将`K`个值从`0`变成`1`。返回仅包含`1`的最长 **连续** 子数组的长度

## 258. 考试的最大困扰度
* 给你一个字符串`answerKey`，其中`answerKey[i]`是第`i`个问题的正确结果。再给你一个整数`k`，表示你能进行操作的最多次数：每次操作中，将`answerKey[i]`改为`'T'`或者`'F'`。 返回在不超过`k`次操作的情况下，最大 **连续** `'T'`或者`'F'`的数目

## 259. 分数到小数
* 给定两个整数，分别表示分子`numerator`和分母`denominator`，以字符串形式返回小数 。 如果小数部分为循环小数，则将循环的部分括在括号内

## 260. 转换字符串的最少操作次数
* 给你一个字符串`s`只由`"X"`、`"O"`构成。 **操作** 指从`s`中选出 **三个连续字符** 并将选中的每个字符都转换为`'O'`。求将`s`中所有字符均转换为`'O'`需要执行的 **最少** 操作次数

## 261. 找出缺失的观测数据
* 一份`n + m`次投掷单个骰子的观测数据，骰子的每个面从`1`到`6`编号。数据中缺失了`n`份，`rolls`为剩余的数据。`mean`为`n + m`次投掷数据的 **平均值** ，返回一个长度为`n`的数组，包含所有缺失的观测数据。

## 262. 石子游戏 IX
* `n`个石子，整数数组`stones`的`stones[i]`是第`i`个石子的价值。A和B轮流进行自己的回合，A先手。每一回合，从`stones`中移除任一石子。如果玩家移除石子后， **已移除石子** 的价值的 **总和** 可以被`3`整除，那么该玩家就输；如果移除后没有任何剩余的石子，那么B将会直接获胜。 假设两位玩家均采用最佳决策,判断胜者。

## 263. 密钥格式化
* 有一个字符串`S`，只包含字母、数字以及`'-'`。给你一个数字 K，请重新格式化字符串，使每个分组恰好包含`K`个字符，特别地，第一个分组包含的字符个数小于等于`K`，但至少要包含`1`个字符。用`'-'`（破折号）隔开分组，并且将所有的小写字母转换为大写字母。

## 264. 提莫攻击
* 给出A对B的攻击时刻序列和A攻击的中毒持续时间，考虑中毒效果的覆盖，输出B的中毒状态总时长

## 265. 火柴拼正方形
* 输入为数组`matchsticks`，第i根火柴长度为`matchsticks[i]`。输出即为是否能用所有的火柴拼成正方形

## 266. 窥探迭代器
* 设计一个迭代器，除了支持`hasNext`和`next`操作外，还支持`peek`操作。`init`：利用给定的`iteration`初始化。`peek`：获取下一个元素，不移动指针。`next`：获取下一个元素，并移动指针。

## 267. 删除排序链表中的重复元素 II
* 存在一个按升序排列的链表，给你这个链表的头节点`head`，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 **没有重复出现** 的数字

## 268. 逆波兰表达式求值
* 根据 **逆波兰表示法**，求表达式的值

## 269. 第三大的数
* 给你一个非空数组，返回此数组中 **第三大的数** 。如果不存在，则返回数组中最大的数

## 270. 汇总区间
* 给定一个无重复元素的有序整数数组`nums`。 返回 **恰好覆盖数组中所有数字** 的区间范围列表。`"a->b"`，如果`a != b`；`"a"`，如果`a == b`

## 271. 岛屿数量
* 给你一个由`'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量

## 272. 组合总和 III
* 找出所有相加之和为`n`的`k`个数的组合。组合中只允许含有`1 - 9`的正整数，并且每种组合中不存在重复的数字

## 273. 字符串中的单词数
* 统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符

## 274. 从前序与中序遍历序列构造二叉树
* 给定一棵树的前序遍历`preorder`与中序遍历`inorder`。请构造二叉树并返回其根节点

## 275. 重复的DNA序列
* 找出所有目标子串，目标子串的长度为`10`，且在字符串`s`中出现次数超过一次

## 276. 二叉树展开为链表
* 给你二叉树的根结点`root`，请你将它展开为一个单链表： 展开后的单链表应该同样使用`TreeNode`，其中`right`子指针指向链表中下一个结点，而左子指针始终为`null`； 展开后的单链表应该与二叉树 **先序遍历** 顺序相同

## 277. 将数据流变为多个不相交区间
* 实现`SummaryRanges`类：`SummaryRanges()`使用一个空数据流初始化对象；`void addNum(int val)`向数据流中加入整数`val`；`int[][] getIntervals()`以不相交区间`[starti, endi]`的列表形式返回对数据流

## 278. 二叉树的锯齿形层序遍历
* 给定一个二叉树，返回其节点值的锯齿形层序遍历。即先从左往右，再从右往左进行下一层遍历，以此类推

## 279. 将有序数组转换为二叉搜索树
* 给你一个整数数组`nums`，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树

## 280. 至少在两个数组中出现的值
* 给你三个整数数组`nums1`、`nums2`和`nums3`，请你构造并返回一个 **不同** 数组，且由 **至少** 在 **两个** 数组中出现的所有值组成

## 281. 获取单值网格的最小操作数
* 给你一个大小为`m x n`的二维整数网格`grid`和一个整数`x`。每一次操作，你可以对`grid`中的任一元素加`x`或减`x`。**单值网格** 是全部元素都相等的网格。 返回使网格化为单值网格所需的 **最小** 操作数

## 282. 排列硬币
* 有`n`枚硬币，将它们按阶梯状排列。对于一个`k`行的阶梯，其第`i`行必须正好有`i`枚硬币。阶梯的最后一行 **可能** 是不完整的。 给你一个数字`n`，计算并返回可形成 **完整的**总行数

## 283. 整数转换英文表示
* 将非负整数`num`转换为其对应的英文表示

## 284. 对链表进行插入排序
* 对链表进行插入排序

## 285. 二叉树的右视图
* 给定一个二叉树的根节点`root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值

## 286. 最长连续序列
* 给定一个未排序的整数数组`nums`，找出数字连续的最长序列的长度

## 287. 求根节点到叶节点数字之和
* 给你一个二叉树的根节点`root`，树中每个节点都存放有一个`0`到`9`之间的数字。 每条从根节点到叶节点的路径都代表一个数字： 例如，从根节点到叶节点的路径`1 -> 2 -> 3`表示数字`123`。 计算从根节点到叶节点生成的数字之和

## 288. 二叉树的最近公共祖先
* 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先

## 289. 删除指定节点
* 在未给定`head`的前提下删除指定节点

## 290. 求众数 II
* 给定一个大小为`n`的整数数组，找出其中所有出现超过`n//3`次的元素

## 291. 分割回文串
* 给你一个字符串`s`，请你将`s`分割成一些子串，使每个子串都是 **回文串** 。返回`s`所有可能的分割方案

## 292. 分割回文串 II
* 给你一个字符串`s`，请你将`s`分割成一些子串，使每个子串都是回文。 返回符合要求的最少分割次数

## 293. 山峰数组的顶部
* 给定由整数组成的山峰形数组`arr`，求山峰的`index`

## 294. 被围绕的区域
* 给你一个`m x n`的矩阵`board`，由若干字符`'X'`和`'O'`，找到所有被`'X'`围绕的区域，并将这些区域里所有的`'O'`用`'X'`填充

## 295. 找不同
* 字符串`t`由字符串`s`随机重排，然后在随机位置添加一个字母。请找出在`t`中被添加的字母

## 296. 翻转字符串里的单词
* 给你一个字符串 s ，逐个翻转字符串中的所有 单词 

## 297. 向下的路径节点之和
* 给定一个二叉树的根节点`root`，和一个整数`targetSum`，求该二叉树里节点值之和等于`targetSum`的 **路径** 的数目。 **路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的

## 298. 二叉树的坡度
* 给定一个二叉树，计算树的坡度和 。 一个节点的 **坡度** 定义即为，该节点左子树的节点之和和右子树节点之和的 **差的绝对值** 

## 299. 给表达式添加运算符
* 给定一个仅包含数字`0-9`的字符串`num`和一个目标值整数`target`，在`num`的数字之间添加运算符`+、-、*`，返回所有能够得到目标值的表达式

## 300. 打乱数组
* 给定一个没有重复元素的数组`nums`，设计算法来随机打乱该数组。实现`Solution`。`Solution(int[] nums)`：使用整数数组`nums`初始化对象；`int[] reset()`：重设数组到它的初始状态并返回；`int[] shuffle()`：返回数组随机打乱后的结果

## 301. 使每位学生都有座位的最少移动次数
* 有`n`个座位和`n`名学生，数组`seats`，其中`seats[i]`是第`i`个座位的位置。数组`students`，其中`students[j]`是第`j`位学生的位置。 执行以下操作： 第`i`位学生从位置`x`移动到`x + 1`或者`x - 1`。 请你返回使所有学生都有座位坐的最少移动次数

## 302. 如果相邻两个颜色均相同则删除当前颜色
* 给你一个长度为`n`的字符串`colors`，其中要么是`'A'`要么是`'B'`，其中`colors[i]`表示第`i`个片段。如果一个片段为`'A'`且相邻两个都是`'A'`，那么A可以删除该颜色片段。同理B可以用同样的方式处理`"B"`。如果一人无法继续操作，则该玩家 **输** 。判断胜负

## 303. 网络空闲的时刻
* 一个有`n`个服务器的计算机网络，服务器编号为`0`到`n - 1`。同时给你一个二维整数数组`edges`，其中`edges[i] = [ui, vi]`表示服务器`ui`和`vi`之间有一条信息线路，它们之间可以在一秒内传输信息。 编号为`0`的服务器是 **主服务器**，其他服务器为 **数据服务器**。每个数据服务器向主服务器发送信息，并等待回复。信息在服务器之间按 **最优** 线路传输。主服务器会处理所有新到达的信息并 **立即** 反方向回复信息。 在`0`秒的开始，数据服务器都发送信息。 从第`1`秒开始，每秒每个数据服务器都会检查是否收到了主服务器的回复信息： 如果还没收到，数据服务器`i`每`patience[i]`秒都会重发一条信息。 请返回计算机网络变为 **没有任何信息在线路上传输或者到达某服务器** 状态的 **最早秒数**

## 304. 二叉搜索树中第K小的元素
* 给定一个二叉搜索树的根节点`root`，和一个整数`k`，请你设计一个算法查找其中第`k`个最小元素

## 305. 检查句子中的数字是否递增
* 句子是由若干`token`组成的一个列表，`token`间用空格分隔。每个`token`要么是正整数 ，要么是单词。检查由若干`token`组成的`s`中的数字是否从左到右严格递增 

## 306. 简易银行系统
* 实现`Bank`类：`Bank(long[] balance)`使用下标从`0`开始的整数数组`balance`初始化该对象；`boolean transfer(int account1, int account2, long money)`从编号为`account1`的账户向编号为`account2`的账户转帐`money`美元；`boolean deposit(int account, long money)`向编号为`account`的账户存款`money`美元。如果交易成功，返回`true`；否则，返回`false`；`boolean withdraw(int account, long money)`从编号为`account`的账户取款`money`美元。如果交易成功，返回`true`；否则，返回`false`。返回从节点`1`到节点`n`需要的 **第二短时间**

## 307. 统计按位或能得到最大值的子集数目
* 给你一个整数数组`nums`，请你找出`nums`子集 **按位或** 可能得到的 **最大值** ，并返回按位或能得到最大值的 **不同非空子集的数目**

## 308. 到达目的地的第二短时间
* 城市用一个`n`个节点的 **双向连通** 图表示。边用一个二维整数数组`edges`表示。穿过任意一条边的时间是`time`分钟。 每个节点都有一个交通信号灯，每`change`分钟改变一次，从绿色变成红色再变成绿色，循环往复。所有信号灯都同时改变。只能在节点 **信号灯是绿色时** 才能离开

## 309. 数字的补数
* 对整数`num`的二进制表示取反（`0`变`1` ，`1`变`0`）后，再转换为十进制表示，得到这个整数的补数

## 300. 数字的补数
* (本题同309)对整数`n`的二进制表示取反（`0`变`1` ，`1`变`0`）后，再转换为十进制表示，得到这个整数的补数

## 311. 省份数量
* 有`n`个城市，其中一些彼此相连。省份是一组 **直接或间接** 相连的城市。给定一个`n x n`的矩阵`isConnected`，其中`isConnected[i][j]`表示第`i`个城市和第`j`个城市是否直接相连。连返回矩阵中 省份 的数量

## 312. 除法求值
* `equations`和`values`作为已知条件，其中`equations[i] = [Ai, Bi]`和`values[i]`共同表示等式`Ai / Bi = values[i]`。`queries`表示的问题，其中`queries[j] = [Cj, Dj]`表示第`j`个问题，请你根据已知条件找出`Cj / Dj`的结果作为答案。如果存在某个无法确定的答案，则用`-1.0`替代这个答案

## 313. 
* 

## 314. 
*

## 315. 
* 

## 316. 
* 

## 317. 
*

## 318. 
* 

## 319. 
* 

## 320. 
*

## 321. 
*

## 322. 
* 

## 323. 
* 

## 324. 
*

## 325. 
* 

## 326. 
* 

## 327. 
*

## 328. 
* 

## 329. 
* 

## 330. 
*

## 331. 
*

## 332. 
* 

## 333. 
* 

## 334. 
*

## 335. 
* 

## 336. 
* 

## 337. 
*

## 338. 
* 

## 339. 
* 

## 340. 
*

## 341. 
*

## 342. 
* 

## 343. 
* 

## 344. 
*

## 345. 
* 

## 346. 
* 

## 347. 
*

## 348. 
* 

## 349. 
* 

## 350. 
*

## 351. 
*

## 352. 
* 

## 353. 
* 

## 354. 
*

## 355. 
* 

## 356. 
* 

## 357. 
*

## 358. 
* 

## 359. 
* 

## 360. 
*

## 361. 
*

## 362. 
* 

## 363. 
* 

## 364. 
*

## 365. 
* 

## 366. 
* 

## 367. 
*

## 368. 
* 

## 369. 
* 

## 370. 
*

## 371. 
*

## 372. 
* 

## 373. 
* 

## 374. 
*

## 375. 
* 

## 376. 
* 

## 377. 
*

## 378. 
* 

## 379. 
* 

## 380. 
*

## 381. 
*

## 382. 
* 

## 383. 
* 

## 384. 
*

## 385. 
* 

## 386. 
* 

## 387. 
*

## 388. 
* 

## 389. 
* 

## 390. 
*

## 391. 
*

## 392. 
* 

## 393. 
* 

## 394. 
*

## 395. 
* 

## 396. 
* 

## 397. 
*

## 398. 
* 

## 399. 
* 

## 400. 
*

## 401. 
*

## 402. 
* 

## 403. 
* 

## 404. 
*

## 405. 
* 

## 406. 
* 

## 407. 
*

## 408. 
* 

## 409. 
* 

## 400. 
*

## 411. 
*

## 412. 
* 

## 413. 
* 

## 414. 
*

## 415. 
* 

## 416. 
* 

## 417. 
*

## 418. 
* 

## 419. 
* 

## 420. 
*

## 421. 
*

## 422. 
* 

## 423. 
* 

## 424. 
*

## 425. 
* 

## 426. 
* 

## 427. 
*

## 428. 
* 

## 429. 
* 

## 430. 
*

## 431. 
*

## 432. 
* 

## 433. 
* 

## 434. 
*

## 435. 
* 

## 436. 
* 

## 437. 
*

## 438. 
* 

## 439. 
* 

## 440. 
*

## 441. 
*

## 442. 
* 

## 443. 
* 

## 444. 
*

## 445. 
* 

## 446. 
* 

## 447. 
*

## 448. 
* 

## 449. 
* 

## 450. 
*

## 451. 
*

## 452. 
* 

## 453. 
* 

## 454. 
*

## 455. 
* 

## 456. 
* 

## 457. 
*

## 458. 
* 

## 459. 
* 

## 460. 
*

## 461. 
*

## 462. 
* 

## 463. 
* 

## 464. 
*

## 465. 
* 

## 466. 
* 

## 467. 
*

## 468. 
* 

## 469. 
* 

## 470. 
*

## 471. 
*

## 472. 
* 

## 473. 
* 

## 474. 
*

## 475. 
* 

## 476. 
* 

## 477. 
*

## 478. 
* 

## 479. 
* 

## 480. 
*

## 481. 
*

## 482. 
* 

## 483. 
* 

## 484. 
*

## 485. 
* 

## 486. 
* 

## 487. 
*

## 488. 
* 

## 489. 
* 

## 490. 
*

## 491. 
*

## 492. 
* 

## 493. 
* 

## 494. 
*

## 495. 
* 

## 496. 
* 

## 497. 
*

## 498. 
* 

## 499. 
* 
