## 1. 第一个错误的版本
* 所以错误的版本之后的所有版本都是错的. 假设你有`n`个版本 `[1, 2, ..., n]`,你想找出导致之后所有版本出错的第一个错误的版本

## 2. 二分查找
* 给定一个`n`个元素有序的（升序）整型数组`nums`和一个目标值`target` ,写一个函数搜索`nums`中的`target`,如果目标值存在返回下标,否则返回`-1

## 3. 搜索插入位置
* 给定一个排序数组和一个目标值,在数组中找到目标值,并返回其索引.如果目标值不存在于数组中,返回它将会被按顺序插入的位置.

## 4. 旋转数组
* 给定一个数组,将数组中的元素向右移动`k`个位置,其中`k`是非负数

## 5. 有序数组的平方
* 给你一个按 **非递减顺序** 排序的整数数组`nums`,返回 **每个数字的平方** 组成的新数组,要求也按 **非递减顺序** 排序

## 6. 移动零
* 给定一个数组`nums`,编写一个函数将所有`0`移动到数组的末尾,同时保持非零元素的相对顺序.

## 7. 两数之和 II - 输入有序数组
* 给定一个已按照 **升序排列** 的整数数组`numbers`,请你从数组中找出两个数满足相加之和等于目标数`target`

## 8.反转字符串
* 编写一个函数,其作用是将输入的字符串反转过来.输入字符串以字符数组`char[]`的形式给出. 不要给另外的数组分配额外的空间,你必须原地修改输入数组、使用`O(1)`的额外空间解决这一问题.

## 9. 反转字符串中的单词 III
* 给定一个字符串,你需要反转字符串中每个单词的字符顺序,同时仍保留空格和单词的初始顺序

## 10. 链表的中间结点
* 给定一个头结点为`head`的非空单链表,返回链表的中间结点

## 11. 删除链表的倒数第 N 个结点
* 给你一个链表,删除链表的倒数第`n`个结点,并且返回链表的头结点

## 12. 无重复字符的最长子串
* 给定一个字符串`s`,请你找出其中不含有重复字符的 **最长子串** 的长度

## 13. 字符串的排列
* 给你两个字符串`s1`和`s2`,写一个函数来判断`s2`是否包含`s1`的排列

## 14. 图像渲染
* 图像中所有颜色相同且上下左右相邻的像素点可以看作一个区域,将初始点所在区域内的所有像素点的颜色值换成新的颜色

## 15. 岛屿的最大面积
* 一个 **岛屿** 是由一些相邻的`1`(代表土地)构成的组合,这里的「相邻」要求两个`1`必须在水平或者竖直方向上相邻.你可以假设`grid`的四个边缘都被`0`（代表水）包围着. 找到给定的二维数组中最大的岛屿面积.

## 16.合并二叉树
* 将两个合并为一个新的二叉树.合并的规则是如果两个节点重叠,那么将他们的值相加作为节点合并后的新值,否则不为`NULL`的节点将直接作为新二叉树的节点

## 17. 填充每个节点的下一个右侧节点指针
* 给定一个 **完美二叉树** ,其所有叶子节点都在同一层,每个父节点都有两个子节点填充它的每个`next`指针,让这个指针指向其下一个右侧节点.

## 18. 01 矩阵
* 给定一个由`0`和`1`组成的矩阵`mat`,请输出一个大小相同的矩阵,其中每一个格子是`mat`中对应位置元素到最近的`0`的距离

## 19.腐烂的橘子
* 每分钟,任何与腐烂的橘子（在`4`个正方向上）相邻的新鲜橘子都会腐烂. 返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数

## 20. 合并两个有序链表
* 将两个升序链表合并为一个新的 **升序** 链表并返回.新链表是通过拼接给定的两个链表的所有节点组成的

## 21. 反转链表
* 给你单链表的头节点`head`,请你反转链表,并返回反转后的链表

## 22. 组合
* 给定两个整数`n`和`k,返回范围`[1, n]`中所有可能的`k`个数的组合

## 23. 全排列
* 给定一个不含重复数字的数组`nums`,返回其所有可能的全排列

## 24. 字母大小写全排列
* 给定一个字符串S,通过将字符串S中的每个字母转变大小写,我们可以获得一个新的字符串.返回所有可能得到的字符串集合

## 25. 爬楼梯
* 每次你可以爬`1`或`2`个台阶.你有多少种不同的方法可以爬到楼顶呢

## 26. 打家劫舍
* 每间房内都藏有一定的现金,影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统,如果两间相邻的房屋在同一晚上被小偷闯入,系统会自动报警.计算你 **不触动警报装置的情况下** ,一夜之内能够偷窃到的最高金额

## 27. 三角形最小路径和
* 给定一个三角形`triangle`,找出自顶向下的最小路径和

## 28. 2 的幂
* 给你一个整数`n`,请你判断该整数是否是`2`的幂次方

## 29. 位1的个数
* 编写一个函数,输入是一个无符号整数（以二进制串的形式）,返回其二进制表达式中数字位数为`'1'`的个数

## 30. 颠倒二进制位
* 颠倒给定的`32`位无符号整数的二进制位

## 31. 只出现一次的数字
* 给定一个非空整数数组,除了某个元素只出现一次以外,其余每个元素均出现两次.找出那个只出现了一次的元素

## 32. 存在重复元素
* 给定一个整数数组,判断是否存在重复元素

## 33. 最大子序和
* 给定一个整数数组`nums`,找到一个具有最大和的连续子数组（子数组最少包含一个元素）,返回其最大和

## 34. 两数之和
* 给定一个整数数组`nums`和一个整数目标值`target`,请你在该数组中找出和为目标值 **target**  的那 两个 整数,并返回它们的数组下标

## 35. 合并两个有序数组
* 给你两个有序整数数组`nums1`和`nums2`,请你将`nums2`合并到`nums1`中,使`nums1`成为一个有序数组

## 36. 斐波那契数 
* 斐波那契数,通常用`F(n)`表示,形成的序列称为 **斐波那契数列** .该数列由`0`和`1`开始,后面的每一项数字都是前面两项数字的和

## 37. 第 N 个泰波那契数
* 请返回第`n`个泰波那契数`Tn`的值

## 38. 使用最小花费爬楼梯
* 每当你爬上一个阶梯你都要花费对应的体力值,一旦支付了相应的体力值,你就可以选择向上爬一个阶梯或者爬两个阶梯. 请你找出达到楼层顶部的最低花费

## 39. 打家劫舍 II
* 每间房内都藏有一定的现金.这个地方所有的房屋都 **围成一圈** ,这意味着第一个房屋和最后一个房屋是紧挨着的.同时,相邻的房屋装有相互连通的防盗系统,如果两间 **相邻** 的房屋在同一晚上被小偷闯入,系统会自动报警 .计算你 **在不触动警报装置的情况下** ,今晚能够偷窃到的最高金额

## 40. 删除并获得点数
* 给你一个整数数组nums, 每次操作中,选择任意一个`nums[i]`,删除它并获得`nums[i]`的点数.之后,你必须删除 **所有** 等于`nums[i] - 1`和 nums[i] + 1的元素. 返回你能通过这些操作获得的最大点数

## 41. 两个数组的交集 II
* 给定两个数组,编写一个函数来计算它们的交集

## 42. 买卖股票的最佳时机
* 给定一个数组`prices`,它的第`i`个元素`prices[i]`表示一支给定股票第`i`天的价格. 你只能选择 **某一天** 买入这只股票,并选择在 **未来的某一个不同的日子** 卖出该股票.计算你所能获取的最大利润

## 43. 重塑矩阵
* 将一个`m x n`矩阵重塑为另一个大小不同`r x c`的新矩阵,但保留其原始数据

## 44. 杨辉三角
* 给定一个非负整数`numRows`,生成「杨辉三角」的前`numRows`行

## 45. 有效的数独
* 请你判断一个`9x9`的数独是否有效.数字`1-9`在每一行只能出现一次. 数字`1-9`在每一列只能出现一次. 数字`1-9`在每一个以粗实线分隔的`3x3`宫内只能出现一次.

## 46. 矩阵置零
* 给定一个`m x n`的矩阵,如果一个元素为`0`,则将其所在行和列的所有元素都设为`0`.请使用 **原地** 算法

## 47. 字符串中的第一个唯一字符
* 给定一个字符串,找到它的第一个不重复的字符,并返回它的索引

## 48. 赎金信
* 给定一个赎金信字符串和一个杂志字符串,判断第一个字符串`ransom`能不能由第二个字符串`magazines`里面的字符构成

## 49. 有效的字母异位词
* 给定两个字符串`s`和`t`,编写一个函数来判断`t`是否是`s`的字母异位词

## 50. 环形链表
* 给定一个链表,判断链表中是否有环

## 51. 移除链表元素
* 给你一个链表的头节点`head`和一个整数`val`,请你删除链表中所有满足`Node.val == val`的节点,并返回 新的头节点

## 52. 删除排序链表中的重复元素
* 存在一个按升序排列的链表,给你这个链表的头节点`head`,请你删除所有重复的元素,使每个元素 **只出现一次** 

## 53. 跳跃游戏
* 给定一个非负整数数组`nums`,你最初位于数组的 **第一个下标** . 数组中的每个元素代表你在该位置可以跳跃的最大长度. 判断你是否能够到达最后一个下标

## 54. 跳跃游戏 II
* 给你一个非负整数数组`nums`,你最初位于数组的第一个位置. 数组中的每个元素代表你在该位置可以跳跃的最大长度. 你的目标是使用最少的跳跃次数到达数组的最后一个位置.

## 55. 环形子数组的最大和
* 给定一个由整数数组`A`表示的环形数组`C`,求`C`的非空子数组的最大可能和

## 56. 乘积最大子数组
* 给你一个整数数组`nums`,请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）,并返回该子数组所对应的乘积

## 57. 乘积为正数的最长子数组长度
* 给你一个整数数组`nums`,请你求出乘积为正数的最长子数组的长度. 一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组. 请你返回乘积为正数的最长子数组长度

## 58. 最佳观光组合
* 给你一个正整数数组`values`,其中`values[i]`表示第`i`个观光景点的评分,并且两个景点`i`和`j`之间的 **距离** 为`j - i`. 一对景点组成的观光组合的得分为`values[i] + values[j] + i - j`,也就是景点的评分之和 **减去** 它们两者之间的距离. 返回一对观光景点能取得的最高分

## 59. 买卖股票的最佳时机 II
* 给定一个数组`prices`,其中`prices[i]`是一支给定股票第`i`天的价格. 设计一个算法来计算你所能获取的最大利润.你可以尽可能地完成更多的交易

## 60. 最佳买卖股票时机含冷冻期
* 给定一个整数数组,其中第`i`个元素代表了第`i`天的股票价格 .设计一个算法计算出最大利润.在满足以下约束条件下,你可以尽可能地完成更多的交易.你不能同时参与多笔交易.卖出股票后,你无法在第二天买入股票 (即冷冻期为`1`天)

## 61. 买卖股票的最佳时机含手续费
* 给定一个整数数组`prices`,其中第`i`个元素代表了第`i`天的股票价格 ；整数`fee`代表了交易股票的手续费用. 你可以无限次地完成交易,但是你每笔交易都需要付手续费.如果你已经购买了一个股票,在卖出它之前你就不能再继续购买股票了. 返回获得利润的最大值

## 62. 单词拆分
* 给定一个非空字符串`s`和一个包含非空单词的列表`wordDict`,判定`s`是否可以被空格拆分为一个或多个在字典中出现的单词

## 63. 接雨水
* 给定`n`个非负整数表示每个宽度为`1`的柱子的高度图,计算按此排列的柱子,下雨之后能接多少雨水

## 64. 有效的括号
* 给定一个只包括`'(',')','{','}','[',']'`的字符串`s`,判断字符串是否有效

## 65. 用栈实现队列
* 请你仅使用两个栈实现先入先出队列.队列应当支持一般队列支持的所有操作（push、pop、peek、empty）

## 66. 二叉树的中序遍历
* 二叉树的中序遍历

## 67. 二叉树的前序遍历
* 二叉树的前序遍历

## 68. 二叉树的后序遍历
* 二叉树的后序遍历

## 69. 等差数列划分
* 给你一个整数数组`nums`,返回数组`nums`中所有为等差数组的 **子数组** 个数

## 70. 解码方法
*`'A' -> 1 , 'B' -> 2 , ...  'Z' -> 26 `.给你一个只含数字的 **非空** 字符串`s`,请计算并返回 **解码** 方法的 **总数**

## 71. 对称二叉树
* 给定一个二叉树,检查它是否是镜像对称的

## 72. 二叉树的层序遍历
* 给你一个二叉树,请你返回其按 **层序遍历** 得到的节点值.

## 73. 二叉树的最大深度
* 给定一个二叉树,找出其最大深度

## 74. 丑数 II
* 给你一个整数`n`,请你找出并返回第`n`个 丑数 . 丑数 **就是只包含质因数**` 2`、`3`和/或`5`的正整数.

## 75. 不同的二叉搜索树
* 给你一个整数`n`,求恰由`n`个节点组成且节点值从`1`到`n`互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数

## 76. 杨辉三角 II
* 给定一个非负索引`rowIndex`,返回「杨辉三角」的第`rowIndex`行

## 77. 下降路径最小和
* 给你一个`n x n`的 **方形** 整数数组`matrix`,请你找出并返回通过`matrix`的下降路径的 **最小和** 

## 78. 矩阵区域和
* 给你一个`m x n`的矩阵`mat`和一个整数 k ,请你返回一个矩阵`answer`,其中每个`answer[i][j]`是所有满足下述条件的元素`mat[r][c] 的和,i - k <= r <= i + k, j - k <= c <= j + k ,(r, c)`在矩阵内

## 79. 二维区域和检索 - 矩阵不可变
* 计算其子矩形范围内元素的总和,该子矩阵的左上角为`(row1, col1)`,右下角为`(row2, col2)`

## 80. 不同路径
* 一个机器人位于一个`m x n`网格的左上角. 机器人每次只能向下或者向右移动一步.机器人试图达到网格的右下角. 问总共有多少条不同的路径？

## 81. 不同路径 II
* 一个机器人位于一个`m x n`网格的左上角. 机器人每次只能向下或者向右移动一步.机器人试图达到网格的右下角. 现在考虑网格中有障碍物.那么从左上角到右下角将会有多少条不同的路径？

## 82. 翻转二叉树
* 翻转一棵二叉树

## 83. 路径总和
* 给你二叉树的根节点`root`和一个表示目标和的整数`targetSum`,判断该树中是否存在 **根节点到叶子节点** 的路径,这条路径上所有节点值相加等于目标和·targetSum·

## 84. 验证二叉搜索树
* 给定一个二叉树,判断其是否是一个有效的二叉搜索树

## 85. 两数之和 IV - 输入 BST
* 给定一个二叉搜索树`root`和一个目标结果`k`,如果`BST`中存在两个元素且它们的和等于给定的目标结果,则返回`true`.

## 86. 二叉搜索树的最近公共祖先
* 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先

## 87. 
* 

## 88. 
* 

## 89.
* 

## 90. 
* 

## 91.
* 

## 92. 
* 

## 93.
* 

## 94. 
* 

## 95.
* 

## 96. 
* 

## 97.
* 

## 98. 
* 

## 99.
* 