## 1. 第一个错误的版本
* 所以错误的版本之后的所有版本都是错的. 假设你有`n`个版本 `[1, 2, ..., n]`,你想找出导致之后所有版本出错的第一个错误的版本

## 2. 二分查找
* 给定一个`n`个元素有序的（升序）整型数组`nums`和一个目标值`target` ,写一个函数搜索`nums`中的`target`,如果目标值存在返回下标,否则返回`-1

## 3. 搜索插入位置
* 给定一个排序数组和一个目标值,在数组中找到目标值,并返回其索引.如果目标值不存在于数组中,返回它将会被按顺序插入的位置.

## 4. 旋转数组
* 给定一个数组,将数组中的元素向右移动`k`个位置,其中`k`是非负数

## 5. 有序数组的平方
* 给你一个按 **非递减顺序** 排序的整数数组`nums`,返回 **每个数字的平方** 组成的新数组,要求也按 **非递减顺序** 排序

## 6. 移动零
* 给定一个数组`nums`,编写一个函数将所有`0`移动到数组的末尾,同时保持非零元素的相对顺序.

## 7. 两数之和 II - 输入有序数组
* 给定一个已按照 **升序排列** 的整数数组`numbers`,请你从数组中找出两个数满足相加之和等于目标数`target`

## 8.反转字符串
* 编写一个函数,其作用是将输入的字符串反转过来.输入字符串以字符数组`char[]`的形式给出. 不要给另外的数组分配额外的空间,你必须原地修改输入数组、使用`O(1)`的额外空间解决这一问题.

## 9. 反转字符串中的单词 III
* 给定一个字符串,你需要反转字符串中每个单词的字符顺序,同时仍保留空格和单词的初始顺序

## 10. 链表的中间结点
* 给定一个头结点为`head`的非空单链表,返回链表的中间结点

## 11. 删除链表的倒数第 N 个结点
* 给你一个链表,删除链表的倒数第`n`个结点,并且返回链表的头结点

## 12. 无重复字符的最长子串
* 给定一个字符串`s`,请你找出其中不含有重复字符的 **最长子串** 的长度

## 13. 字符串的排列
* 给你两个字符串`s1`和`s2`,写一个函数来判断`s2`是否包含`s1`的排列

## 14. 图像渲染
* 图像中所有颜色相同且上下左右相邻的像素点可以看作一个区域,将初始点所在区域内的所有像素点的颜色值换成新的颜色

## 15. 岛屿的最大面积
* 一个 **岛屿** 是由一些相邻的`1`(代表土地)构成的组合,这里的「相邻」要求两个`1`必须在水平或者竖直方向上相邻.你可以假设`grid`的四个边缘都被`0`（代表水）包围着. 找到给定的二维数组中最大的岛屿面积.

## 16.合并二叉树
* 将两个合并为一个新的二叉树.合并的规则是如果两个节点重叠,那么将他们的值相加作为节点合并后的新值,否则不为`NULL`的节点将直接作为新二叉树的节点

## 17. 填充每个节点的下一个右侧节点指针
* 给定一个 **完美二叉树** ,其所有叶子节点都在同一层,每个父节点都有两个子节点填充它的每个`next`指针,让这个指针指向其下一个右侧节点.

## 18. 01 矩阵
* 给定一个由`0`和`1`组成的矩阵`mat`,请输出一个大小相同的矩阵,其中每一个格子是`mat`中对应位置元素到最近的`0`的距离

## 19.腐烂的橘子
* 每分钟,任何与腐烂的橘子（在`4`个正方向上）相邻的新鲜橘子都会腐烂. 返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数

## 20. 合并两个有序链表
* 将两个升序链表合并为一个新的 **升序** 链表并返回.新链表是通过拼接给定的两个链表的所有节点组成的

## 21. 反转链表
* 给你单链表的头节点`head`,请你反转链表,并返回反转后的链表

## 22. 组合
* 给定两个整数`n`和`k,返回范围`[1, n]`中所有可能的`k`个数的组合

## 23. 全排列
* 给定一个不含重复数字的数组`nums`,返回其所有可能的全排列

## 24. 字母大小写全排列
* 给定一个字符串S,通过将字符串S中的每个字母转变大小写,我们可以获得一个新的字符串.返回所有可能得到的字符串集合

## 25. 爬楼梯
* 每次你可以爬`1`或`2`个台阶.你有多少种不同的方法可以爬到楼顶呢

## 26. 打家劫舍
* 每间房内都藏有一定的现金,影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统,如果两间相邻的房屋在同一晚上被小偷闯入,系统会自动报警.计算你 **不触动警报装置的情况下** ,一夜之内能够偷窃到的最高金额

## 27. 三角形最小路径和
* 给定一个三角形`triangle`,找出自顶向下的最小路径和

## 28. 2 的幂
* 给你一个整数`n`,请你判断该整数是否是`2`的幂次方

## 29. 位1的个数
* 编写一个函数,输入是一个无符号整数（以二进制串的形式）,返回其二进制表达式中数字位数为`'1'`的个数

## 30. 颠倒二进制位
* 颠倒给定的`32`位无符号整数的二进制位

## 31. 只出现一次的数字
* 给定一个非空整数数组,除了某个元素只出现一次以外,其余每个元素均出现两次.找出那个只出现了一次的元素

## 32. 存在重复元素
* 给定一个整数数组,判断是否存在重复元素

## 33. 最大子序和
* 给定一个整数数组`nums`,找到一个具有最大和的连续子数组（子数组最少包含一个元素）,返回其最大和

## 34. 两数之和
* 给定一个整数数组`nums`和一个整数目标值`target`,请你在该数组中找出和为目标值 **target**  的那 两个 整数,并返回它们的数组下标

## 35. 合并两个有序数组
* 给你两个有序整数数组`nums1`和`nums2`,请你将`nums2`合并到`nums1`中,使`nums1`成为一个有序数组

## 36. 斐波那契数 
* 斐波那契数,通常用`F(n)`表示,形成的序列称为 **斐波那契数列** .该数列由`0`和`1`开始,后面的每一项数字都是前面两项数字的和

## 37. 第 N 个泰波那契数
* 请返回第`n`个泰波那契数`Tn`的值

## 38. 使用最小花费爬楼梯
* 每当你爬上一个阶梯你都要花费对应的体力值,一旦支付了相应的体力值,你就可以选择向上爬一个阶梯或者爬两个阶梯. 请你找出达到楼层顶部的最低花费

## 39. 打家劫舍 II
* 每间房内都藏有一定的现金.这个地方所有的房屋都 **围成一圈** ,这意味着第一个房屋和最后一个房屋是紧挨着的.同时,相邻的房屋装有相互连通的防盗系统,如果两间 **相邻** 的房屋在同一晚上被小偷闯入,系统会自动报警 .计算你 **在不触动警报装置的情况下** ,今晚能够偷窃到的最高金额

## 40. 删除并获得点数
* 给你一个整数数组nums, 每次操作中,选择任意一个`nums[i]`,删除它并获得`nums[i]`的点数.之后,你必须删除 **所有** 等于`nums[i] - 1`和 nums[i] + 1的元素. 返回你能通过这些操作获得的最大点数

## 41. 两个数组的交集 II
* 给定两个数组,编写一个函数来计算它们的交集

## 42. 买卖股票的最佳时机
* 给定一个数组`prices`,它的第`i`个元素`prices[i]`表示一支给定股票第`i`天的价格. 你只能选择 **某一天** 买入这只股票,并选择在 **未来的某一个不同的日子** 卖出该股票.计算你所能获取的最大利润

## 43. 重塑矩阵
* 将一个`m x n`矩阵重塑为另一个大小不同`r x c`的新矩阵,但保留其原始数据

## 44. 杨辉三角
* 给定一个非负整数`numRows`,生成「杨辉三角」的前`numRows`行

## 45. 有效的数独
* 请你判断一个`9x9`的数独是否有效.数字`1-9`在每一行只能出现一次. 数字`1-9`在每一列只能出现一次. 数字`1-9`在每一个以粗实线分隔的`3x3`宫内只能出现一次.

## 46. 矩阵置零
* 给定一个`m x n`的矩阵,如果一个元素为`0`,则将其所在行和列的所有元素都设为`0`.请使用 **原地** 算法

## 47. 字符串中的第一个唯一字符
* 给定一个字符串,找到它的第一个不重复的字符,并返回它的索引

## 48. 赎金信
* 给定一个赎金信字符串和一个杂志字符串,判断第一个字符串`ransom`能不能由第二个字符串`magazines`里面的字符构成

## 49. 有效的字母异位词
* 给定两个字符串`s`和`t`,编写一个函数来判断`t`是否是`s`的字母异位词

## 50. 环形链表
* 给定一个链表,判断链表中是否有环

## 51. 移除链表元素
* 给你一个链表的头节点`head`和一个整数`val`,请你删除链表中所有满足`Node.val == val`的节点,并返回 新的头节点

## 52. 删除排序链表中的重复元素
* 存在一个按升序排列的链表,给你这个链表的头节点`head`,请你删除所有重复的元素,使每个元素 **只出现一次** 

## 53. 跳跃游戏
* 给定一个非负整数数组`nums`,你最初位于数组的 **第一个下标** . 数组中的每个元素代表你在该位置可以跳跃的最大长度. 判断你是否能够到达最后一个下标

## 54. 跳跃游戏 II
* 给你一个非负整数数组`nums`,你最初位于数组的第一个位置. 数组中的每个元素代表你在该位置可以跳跃的最大长度. 你的目标是使用最少的跳跃次数到达数组的最后一个位置.

## 55. 环形子数组的最大和
* 给定一个由整数数组`A`表示的环形数组`C`,求`C`的非空子数组的最大可能和

## 56. 乘积最大子数组
* 给你一个整数数组`nums`,请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）,并返回该子数组所对应的乘积

## 57. 乘积为正数的最长子数组长度
* 给你一个整数数组`nums`,请你求出乘积为正数的最长子数组的长度. 一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组. 请你返回乘积为正数的最长子数组长度

## 58. 最佳观光组合
* 给你一个正整数数组`values`,其中`values[i]`表示第`i`个观光景点的评分,并且两个景点`i`和`j`之间的 **距离** 为`j - i`. 一对景点组成的观光组合的得分为`values[i] + values[j] + i - j`,也就是景点的评分之和 **减去** 它们两者之间的距离. 返回一对观光景点能取得的最高分

## 59. 买卖股票的最佳时机 II
* 给定一个数组`prices`,其中`prices[i]`是一支给定股票第`i`天的价格. 设计一个算法来计算你所能获取的最大利润.你可以尽可能地完成更多的交易

## 60. 最佳买卖股票时机含冷冻期
* 给定一个整数数组,其中第`i`个元素代表了第`i`天的股票价格 .设计一个算法计算出最大利润.在满足以下约束条件下,你可以尽可能地完成更多的交易.你不能同时参与多笔交易.卖出股票后,你无法在第二天买入股票 (即冷冻期为`1`天)

## 61. 买卖股票的最佳时机含手续费
* 给定一个整数数组`prices`,其中第`i`个元素代表了第`i`天的股票价格 ；整数`fee`代表了交易股票的手续费用. 你可以无限次地完成交易,但是你每笔交易都需要付手续费.如果你已经购买了一个股票,在卖出它之前你就不能再继续购买股票了. 返回获得利润的最大值

## 62. 单词拆分
* 给定一个非空字符串`s`和一个包含非空单词的列表`wordDict`,判定`s`是否可以被空格拆分为一个或多个在字典中出现的单词

## 63. 接雨水
* 给定`n`个非负整数表示每个宽度为`1`的柱子的高度图,计算按此排列的柱子,下雨之后能接多少雨水

## 64. 有效的括号
* 给定一个只包括`'(',')','{','}','[',']'`的字符串`s`,判断字符串是否有效

## 65. 用栈实现队列
* 请你仅使用两个栈实现先入先出队列.队列应当支持一般队列支持的所有操作（push、pop、peek、empty）

## 66. 二叉树的中序遍历
* 二叉树的中序遍历

## 67. 二叉树的前序遍历
* 二叉树的前序遍历

## 68. 二叉树的后序遍历
* 二叉树的后序遍历

## 69. 等差数列划分
* 给你一个整数数组`nums`,返回数组`nums`中所有为等差数组的 **子数组** 个数

## 70. 解码方法
*`'A' -> 1 , 'B' -> 2 , ...  'Z' -> 26 `.给你一个只含数字的 **非空** 字符串`s`,请计算并返回 **解码** 方法的 **总数**

## 71. 对称二叉树
* 给定一个二叉树,检查它是否是镜像对称的

## 72. 二叉树的层序遍历
* 给你一个二叉树,请你返回其按 **层序遍历** 得到的节点值.

## 73. 二叉树的最大深度
* 给定一个二叉树,找出其最大深度

## 74. 丑数 II
* 给你一个整数`n`,请你找出并返回第`n`个 丑数 . 丑数 **就是只包含质因数**` 2`、`3`和/或`5`的正整数.

## 75. 不同的二叉搜索树
* 给你一个整数`n`,求恰由`n`个节点组成且节点值从`1`到`n`互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数

## 76. 杨辉三角 II
* 给定一个非负索引`rowIndex`,返回「杨辉三角」的第`rowIndex`行

## 77. 下降路径最小和
* 给你一个`n x n`的 **方形** 整数数组`matrix`,请你找出并返回通过`matrix`的下降路径的 **最小和** 

## 78. 矩阵区域和
* 给你一个`m x n`的矩阵`mat`和一个整数 k ,请你返回一个矩阵`answer`,其中每个`answer[i][j]`是所有满足下述条件的元素`mat[r][c] 的和,i - k <= r <= i + k, j - k <= c <= j + k ,(r, c)`在矩阵内

## 79. 二维区域和检索 - 矩阵不可变
* 计算其子矩形范围内元素的总和,该子矩阵的左上角为`(row1, col1)`,右下角为`(row2, col2)`

## 80. 不同路径
* 一个机器人位于一个`m x n`网格的左上角. 机器人每次只能向下或者向右移动一步.机器人试图达到网格的右下角. 问总共有多少条不同的路径？

## 81. 不同路径 II
* 一个机器人位于一个`m x n`网格的左上角. 机器人每次只能向下或者向右移动一步.机器人试图达到网格的右下角. 现在考虑网格中有障碍物.那么从左上角到右下角将会有多少条不同的路径？

## 82. 翻转二叉树
* 翻转一棵二叉树

## 83. 路径总和
* 给你二叉树的根节点`root`和一个表示目标和的整数`targetSum`,判断该树中是否存在 **根节点到叶子节点** 的路径,这条路径上所有节点值相加等于目标和·targetSum·

## 84. 验证二叉搜索树
* 给定一个二叉树,判断其是否是一个有效的二叉搜索树

## 85. 两数之和 IV - 输入 BST
* 给定一个二叉搜索树`root`和一个目标结果`k`,如果`BST`中存在两个元素且它们的和等于给定的目标结果,则返回`true`.

## 86. 二叉搜索树的最近公共祖先
* 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先

## 87. 最小路径和
* 给定一个包含非负整数的`m x n`网格`grid`,请找出一条从左上角到右下角的路径,使得路径上的数字总和为最小

## 88. 最大正方形
* 在一个由`0`和`1`组成的二维矩阵内,找到只包含`1`的最大正方形,并返回其面积

## 89. 最长回文子串
* 给你一个字符串`s`,找到`s`中最长的回文子串

## 90. 最长回文子序列
* 给你一个字符串`s`,找出其中最长的回文子序列,并返回该序列的长度。子序列定义为：不改变剩余字符顺序的情况下,删除某些字符或者不删除任何字符形成的一个序列

## 91. 最长递增子序列
* 给你一个整数数组`nums`,找到其中最长严格递增子序列的长度。子序列是由数组派生而来的序列,删除（或不删除）数组中的元素而不改变其余元素的顺序。例如,`[3,6,2,7]`是数组`[0,3,1,6,2,2,7]`的子序列

## 92. 摆动序列
* 如果连续数字之间的差严格地在正数和负数之间交替,则数字序列称为 摆动序列 。给你一个整数数组`nums`,返回`nums`中作为 **摆动序列** 的 **最长子序列的长度**

## 93. 判断子序列
* 给定字符串`s`和`t`,判断`s`是否为`t`的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串

## 94. 最长公共子序列
* 给定两个字符串`text1`和`text2`,返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ,返回`0`。 一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串

## 95. 编辑距离
* 给你两个单词`word1`和`word2`,请你计算出将`word1`转换成`word2`所使用的最少操作数

## 96. 零钱兑8换
* 给你一个整数数组`coins`,表示不同面额的硬币；以及一个整数`amount`,表示总金额。 计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额,返回`-1`

## 97. 零钱兑换 II
* 给你一个整数数组`coins`表示不同面额的硬币,另给一个整数`amount`表示总金额。 请你计算并返回可以凑成总金额的硬币组合数

## 98. 组合总和 Ⅳ
* 给你一个由 **不同** 整数组成的数组`nums`,和一个目标整数`target`。请你从`nums`中找出并返回总和为`target`的元素组合的个数

## 99. 整数拆分
* 给定一个正整数`n`,将其拆分为至少两个正整数的和,并使这些整数的乘积最大化。 返回你可以获得的最大乘积

## 100. 完全平方数
* 给定正整数`n`,找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于`n`。你需要让组成和的完全平方数的个数最少。 给你一个整数`n`,返回和为`n`的完全平方数的 **最少数量**

## 101. 二叉搜索树中的搜索
* 给定二叉搜索树（`BST`）的根节点和一个值。 你需要在 `BST` 中找到节点值等于给定值的节点。

## 102. 二叉搜索树中的插入操作
* 给定二叉搜索树（`BST`）的根节点和要插入树中的值，将值插入 `BST` 。 返回插入后 `BST` 的根节点

## 103.  统计不开心的朋友
* 给你一份`n`位朋友的亲近程度列表，其中`n`总是 **偶数** 。对每位朋友`i`，`preferences[i]`包含一份 **按亲近程度从高到低排列** 的朋友列表。换句话说，排在列表前面的朋友与`i`的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以`0`到`n-1`之间的整数表示。 所有的朋友被分成几对，配对情况以列表`pairs`给出，其中`pairs[i] = [xi, yi]`表示`xi`与`yi`配对，且`yi`与`xi`配对。 但是，这样的配对情况可能会是其中部分朋友感到不开心：在 x 与 y 配对且 u 与 `v` 配对的情况下，如果同时满足下述两个条件，`x`就会不开心：`x`与`u`的亲近程度胜过`x`与`y`，且`u`与`x`的亲近程度胜过`u`与`v`。返回 **不开心的朋友的数目** 。

## 104.  出界的路径数
* 给你一个大小为`m x n`的网格和一个球。球的起始坐标为`[startRow, startColumn]`。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 **最多** 可以移动`maxMove`次球。 找出并返回可以将球移出边界的路径数量。

## 105.  两数相加
* 给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表

## 106. 寻找两个正序数组的中位数
* 给定两个大小分别为`m`和`n`的正序（从小到大）数组`nums1`和`nums2`。请你找出并返回这两个正序数组的 **中位数**

## 107. 优美的排列
* 假设有从`1`到`N`的`N`个整数，如果从这`N`个数字中成功构造出一个数组，使得数组的第`i`位 (`1 <= i <= N`) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列： 1:第`i`位的数字能被`i`整除。 2:`i`能被第 i 位上的数字整除。现在给定一个整数 N，请问可以构造多少个优美的排列

## 108. Z 字形变换
* 将一个给定字符串`s`根据给定的行数`numRows`，以从上往下、从左到右进行 **N** 字形排列

## 109. 学生出勤记录 I
* 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：'A'：Absent，缺勤；'L'：Late，迟到；'P'：Present，到场。 如果学生能够 **同时** 满足下面两个条件，则可以获得出勤奖励： 按 **总出勤** 计，学生缺勤（'A'）严格 **少于两天** 。 学生 不会 存在 连续 3 天或 3 天以上的迟到（'L'）记录。 如果学生可以获得出勤奖励，返回`true`；否则，返回`false`

## 110. 学生出勤记录 II
* 可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：'A'：Absent，缺勤；  'L'：Late，迟到；  'P'：Present，到场。  如果学生能够 **同时** 满足下面两个条件，则可以获得出勤奖励： 按 **总出勤** 计，学生缺勤（'A'）严格 **少于两天** 。 学生 **不会** 存在 连续`3`天或连续`3`天以上的迟到（'L'）记录。 给你一个整数`n`，表示出勤记录的长度（次数）。请你返回记录长度为`n`时，可能获得出勤奖励的记录情况 **数量**

## 111. 整数反转
* 给你一个 32 位的有符号整数`x`，返回将`x`中的数字部分反转后的结果

## 112. 字符串转换整数 (atoi)
* 请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数。除开头符号外，如某字符为非数字，之后的字符忽略

## 113. 回文数
*给你一个整数`x`,不转换成字符串,判断是否回文

## 114. 反转字符串中的元音字母
* 编写一个函数，以字符串作为输入，反转该字符串中的元音字母

## 115. 正则表达式匹配
* 给你一个字符串`s`和一个字符规律`p`，请你来实现一个支持`'.'`和`'*'`的正则表达式匹配。`'.'`配任意单个字符; `'*'`匹配零个或多个前面的那一个元素

## 116. 反转字符串 II
* 给定一个字符串`s`和一个整数`k`，从字符串开头算起，每`2k`个字符反转前`k`个字符。 如果剩余字符少于`k`个，则将剩余字符全部反转。 如果剩余字符小于`2k`但大于或等于`k`个，则反转前`k`个字符，其余字符保持原样。

## 117. 盛最多水的容器
* 给你`n`个非负整数`a1，a2，...，an`，每个数代表坐标中的一个点在`i`处高为`ai`的边。找出其中的两条边，使得它们与`x`轴共同构成的容器可以容纳最多的水

## 118. 整数转罗马数字
* 罗马数字中小的数字在大的数字的右边。但也存在特例。例如数字`4`写做`IV`，数字`9`表示为`IX`。给你一个整数，将其转为罗马数字。

## 119. 压缩字符串
* 给你一个字符数组 chars ，请使用下述算法压缩： 从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ： 如果这一组长度为`1`，则将字符追加到`s`中。 否则，需要向`s`追加字符，后跟这一组的长度。 压缩后得到的字符串`s`不应该直接返回 ，需要转储到字符数组`chars`中。需要注意的是，组长度本身也要被拆分成多个字符。 请在 **修改完输入数组后** ，返回该数组的新长度。

## 120. 罗马数字转整数
* 罗马数字中小的数字在大的数字的右边。但也存在特例。例如数字`4`写做`IV`，数字`9`表示为`IX`。给你一个罗马数字，将其转为整数。

## 121. 最长公共前缀
* 编写一个函数来查找字符串数组中的最长公共前缀

## 122. 逃脱阻碍者
* 你在进行一个简化版的吃豆人游戏。你从`[0, 0]`点开始出发，你的目的地是`target = [xtarget, ytarget]`。地图上有一些阻碍者，以数组`ghosts`给出，第`i`个阻碍者从`ghosts[i] = [xi, yi]`出发。所有输入均为 **整数坐标** 。 每一回合，你和阻碍者们可以同时向上下左右移动，每次可以移动到距离原位置`1`个单位的新位置。当然，也可以选择 **不动** 。所有动作 **同时** 发生。 返回你是否可以在任何阻碍者抓住你 **之前** 到达目的地

## 123. 三数之和
* 给你一个包含`n`个整数的数组`nums`，判断`nums`中是否存在三个元素`a，b，c`，使得`a + b + c = 0`？请你找出所有和为`0`且不重复的三元组

## 124. 获取生成数组中的最大值
* 给你一个整数`n`。按下述规则生成一个长度为`n + 1`的数组`nums`：`nums[0] = 0`；`nums[1] = 1`； 当`2 <= 2 * i <= n`时，`nums[2 * i] = nums[i]`； 当`2 <= 2 * i + 1 <= n`时，`nums[2 * i + 1] = nums[i] + nums[i + 1]`。返回生成数组`nums`中的 **最大** 值

## 125. 最接近的三数之和
* 给定一个包括`n`个整数的数组`nums`和一个目标值`target`。找出`nums`中的三个整数，使得它们的和与`target`最接近。返回这三个数的和。假定每组输入只存在唯一答案

## 126. 电话号码的字母组合
* 给定一个仅包含数字`2-9`的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回

## 127. K 站中转内最便宜的航班
* 有`n`个城市通过一些航班连接。给你一个数组`flights`，其中`flights[i] = [fromi, toi, pricei]`，表示该航班都从城市`fromi`开始，以价格`pricei`抵达`toi`。 现在给定所有的城市和航班，以及出发城市`src`和目的地`dst`，你的任务是找到出一条最多经过`k`站中转的路线，使得从`src`到`dst`的 **价格最便宜** 。 如果不存在这样的路线，则输出`-1`

## 128. 四数之和
* 给你一个由`n`个整数组成的数组`nums`，和一个目标值`target`。请你找出并返回满足下述全部条件且不重复的四元组`[nums[a], nums[b], nums[c], nums[d]]`：`0 <= a, b, c, d < n`；`a`、`b`、`c`和`d`互不相同；`nums[a] + nums[b] + nums[c] + nums[d] == target`

## 129. 所有可能的路径
* 给你一个有`n`个节点的 **有向无环图（DAG）** ，请你找出所有从节点`0`到节点`n-1`的路径

## 130. 
*

## 131. 
*

## 132. 
* 

## 133. 
* 

## 134. 
*

## 135. 
* 

## 136. 
* 

## 137. 
*

## 138. 
* 

## 139. 
* 

## 140. 
*

## 141. 
*

## 142. 
* 

## 143. 
* 

## 144. 
*

## 145. 
* 

## 146. 
* 

## 147. 
*

## 148. 
* 

## 149. 
* 

## 150. 
*

## 151. 
*

## 152. 
* 

## 153. 
* 

## 154. 
*

## 155. 
* 

## 156. 
* 

## 157. 
*

## 158. 
* 

## 159. 
* 

## 160. 
*

## 161. 
*

## 162. 
* 

## 163. 
* 

## 164. 
*

## 165. 
* 

## 166. 
* 

## 167. 
*

## 168. 
* 

## 169. 
* 

## 170. 
*

## 171. 
*

## 172. 
* 

## 173. 
* 

## 174. 
*

## 175. 
* 

## 176. 
* 

## 177. 
*

## 178. 
* 

## 179. 
* 

## 180. 
*

## 181. 
*

## 182. 
* 

## 183. 
* 

## 184. 
*

## 185. 
* 

## 186. 
* 

## 187. 
*

## 188. 
* 

## 189. 
* 

## 190. 
*

## 191. 
*

## 192. 
* 

## 193. 
* 

## 194. 
*

## 195. 
* 

## 196. 
* 

## 197. 
*

## 198. 
* 

## 199. 
* 

## 200. 
*

## 201. 
*

## 202. 
* 

## 203. 
* 

## 204. 
*

## 205. 
* 

## 206. 
* 

## 207. 
*

## 208. 
* 

## 209. 
* 

## 200. 
*

## 211. 
*

## 212. 
* 

## 213. 
* 

## 214. 
*

## 215. 
* 

## 216. 
* 

## 217. 
*

## 218. 
* 

## 219. 
* 

## 220. 
*

## 221. 
*

## 222. 
* 

## 223. 
* 

## 224. 
*

## 225. 
* 

## 226. 
* 

## 227. 
*

## 228. 
* 

## 229. 
* 

## 230. 
*

## 231. 
*

## 232. 
* 

## 233. 
* 

## 234. 
*

## 235. 
* 

## 236. 
* 

## 237. 
*

## 238. 
* 

## 239. 
* 

## 240. 
*

## 241. 
*

## 242. 
* 

## 243. 
* 

## 244. 
*

## 245. 
* 

## 246. 
* 

## 247. 
*

## 248. 
* 

## 249. 
* 

## 250. 
*

## 251. 
*

## 252. 
* 

## 253. 
* 

## 254. 
*

## 255. 
* 

## 256. 
* 

## 257. 
*

## 258. 
* 

## 259. 
* 

## 260. 
*

## 261. 
*

## 262. 
* 

## 263. 
* 

## 264. 
*

## 265. 
* 

## 266. 
* 

## 267. 
*

## 268. 
* 

## 269. 
* 

## 270. 
*

## 271. 
*

## 272. 
* 

## 273. 
* 

## 274. 
*

## 275. 
* 

## 276. 
* 

## 277. 
*

## 278. 
* 

## 279. 
* 

## 280. 
*

## 281. 
*

## 282. 
* 

## 283. 
* 

## 284. 
*

## 285. 
* 

## 286. 
* 

## 287. 
*

## 288. 
* 

## 289. 
* 

## 290. 
*

## 291. 
*

## 292. 
* 

## 293. 
* 

## 294. 
*

## 295. 
* 

## 296. 
* 

## 297. 
*

## 298. 
* 

## 299. 
* 

## 300. 
*

## 301. 
*

## 302. 
* 

## 303. 
* 

## 304. 
*

## 305. 
* 

## 306. 
* 

## 307. 
*

## 308. 
* 

## 309. 
* 

## 300. 
*

## 311. 
*

## 312. 
* 

## 313. 
* 

## 314. 
*

## 315. 
* 

## 316. 
* 

## 317. 
*

## 318. 
* 

## 319. 
* 

## 320. 
*

## 321. 
*

## 322. 
* 

## 323. 
* 

## 324. 
*

## 325. 
* 

## 326. 
* 

## 327. 
*

## 328. 
* 

## 329. 
* 

## 330. 
*

## 331. 
*

## 332. 
* 

## 333. 
* 

## 334. 
*

## 335. 
* 

## 336. 
* 

## 337. 
*

## 338. 
* 

## 339. 
* 

## 340. 
*

## 341. 
*

## 342. 
* 

## 343. 
* 

## 344. 
*

## 345. 
* 

## 346. 
* 

## 347. 
*

## 348. 
* 

## 349. 
* 

## 350. 
*

## 351. 
*

## 352. 
* 

## 353. 
* 

## 354. 
*

## 355. 
* 

## 356. 
* 

## 357. 
*

## 358. 
* 

## 359. 
* 

## 360. 
*

## 361. 
*

## 362. 
* 

## 363. 
* 

## 364. 
*

## 365. 
* 

## 366. 
* 

## 367. 
*

## 368. 
* 

## 369. 
* 

## 370. 
*

## 371. 
*

## 372. 
* 

## 373. 
* 

## 374. 
*

## 375. 
* 

## 376. 
* 

## 377. 
*

## 378. 
* 

## 379. 
* 

## 380. 
*

## 381. 
*

## 382. 
* 

## 383. 
* 

## 384. 
*

## 385. 
* 

## 386. 
* 

## 387. 
*

## 388. 
* 

## 389. 
* 

## 390. 
*

## 391. 
*

## 392. 
* 

## 393. 
* 

## 394. 
*

## 395. 
* 

## 396. 
* 

## 397. 
*

## 398. 
* 

## 399. 
* 

## 400. 
*

## 401. 
*

## 402. 
* 

## 403. 
* 

## 404. 
*

## 405. 
* 

## 406. 
* 

## 407. 
*

## 408. 
* 

## 409. 
* 

## 400. 
*

## 411. 
*

## 412. 
* 

## 413. 
* 

## 414. 
*

## 415. 
* 

## 416. 
* 

## 417. 
*

## 418. 
* 

## 419. 
* 

## 420. 
*

## 421. 
*

## 422. 
* 

## 423. 
* 

## 424. 
*

## 425. 
* 

## 426. 
* 

## 427. 
*

## 428. 
* 

## 429. 
* 

## 430. 
*

## 431. 
*

## 432. 
* 

## 433. 
* 

## 434. 
*

## 435. 
* 

## 436. 
* 

## 437. 
*

## 438. 
* 

## 439. 
* 

## 440. 
*

## 441. 
*

## 442. 
* 

## 443. 
* 

## 444. 
*

## 445. 
* 

## 446. 
* 

## 447. 
*

## 448. 
* 

## 449. 
* 

## 450. 
*

## 451. 
*

## 452. 
* 

## 453. 
* 

## 454. 
*

## 455. 
* 

## 456. 
* 

## 457. 
*

## 458. 
* 

## 459. 
* 

## 460. 
*

## 461. 
*

## 462. 
* 

## 463. 
* 

## 464. 
*

## 465. 
* 

## 466. 
* 

## 467. 
*

## 468. 
* 

## 469. 
* 

## 470. 
*

## 471. 
*

## 472. 
* 

## 473. 
* 

## 474. 
*

## 475. 
* 

## 476. 
* 

## 477. 
*

## 478. 
* 

## 479. 
* 

## 480. 
*

## 481. 
*

## 482. 
* 

## 483. 
* 

## 484. 
*

## 485. 
* 

## 486. 
* 

## 487. 
*

## 488. 
* 

## 489. 
* 

## 490. 
*

## 491. 
*

## 492. 
* 

## 493. 
* 

## 494. 
*

## 495. 
* 

## 496. 
* 

## 497. 
*

## 498. 
* 

## 499. 
* 
